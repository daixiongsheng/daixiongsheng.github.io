<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/assets/1630237858228jfs4nc.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/1630237858228jfs4nc.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/1630237858228jfs4nc.png"><link rel="mask-icon" href="/assets/1630237858228jfs4nc.png" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"daixiongsheng.github.io",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!1,comments:{style:"tabs",active:"gitalk",storage:!0,lazyload:!1,nav:{gitalk:{order:-1}},activeClass:"gitalk"},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.json"}</script><meta property="og:type" content="article"><meta property="og:title" content="我读过的书更新ing"><meta property="og:url" content="https://daixiongsheng.github.io/201807/%E6%88%91%E8%AF%BB%E8%BF%87%E7%9A%84%E4%B9%A6%E6%9B%B4%E6%96%B0ing/index.html"><meta property="og:site_name" content="none"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2018-07-28T07:55:59.000Z"><meta property="article:modified_time" content="2022-04-21T15:21:44.000Z"><meta property="article:author" content="Xiongsheng Dai"><meta property="article:tag" content="书"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://daixiongsheng.github.io/201807/%E6%88%91%E8%AF%BB%E8%BF%87%E7%9A%84%E4%B9%A6%E6%9B%B4%E6%96%B0ing/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>我读过的书更新ing | none</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="none" type="application/atom+xml">
</head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">none</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><a href="https://github.com/daixiongsheng" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://daixiongsheng.github.io/201807/%E6%88%91%E8%AF%BB%E8%BF%87%E7%9A%84%E4%B9%A6%E6%9B%B4%E6%96%B0ing/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Xiongsheng Dai"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="none"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">我读过的书更新ing<a href="https://github.com/daixiongsheng/blog/tree/master/source/_posts/201807/%E6%88%91%E8%AF%BB%E8%BF%87%E7%9A%84%E4%B9%A6%E6%9B%B4%E6%96%B0ing.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pencil-alt"></i></a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-07-28 15:55:59" itemprop="dateCreated datePublished" datetime="2018-07-28T15:55:59+08:00">2018-07-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-04-21 23:21:44" itemprop="dateModified" datetime="2022-04-21T23:21:44+08:00">2022-04-21</time></span><div class="post-description"></div></div></header><div class="post-body" itemprop="articleBody"><hr><h1 id="section">2018</h1><hr><h2 id="人性的弱点----卡耐基">1. 人性的弱点 ---卡耐基</h2><p>对个人的剖析</p><h2 id="你一年的-8760-小时----艾力">2. 你一年的 8760 小时 ---艾力</h2><p>一切都不晚</p><h2 id="大数据时代生活工作与思维的大变革----维克托迈尔舍恩伯格">3. 大数据时代：生活、工作与思维的大变革 ---维克托•迈尔•舍恩伯格</h2><p>大数据下的我们是透明的</p><h2 id="编码隐匿在计算机软硬件背后的语言----查尔斯佩措尔德">4. 编码：隐匿在计算机软硬件背后的语言 ---查尔斯•佩措尔德</h2><p>从简单电路到逻辑门，到锁存器寄存器，再到整个系统。 从简单的 01 到复杂的图形图像等</p><h2 id="head-first-python----paul-barry">5. Head First Python ---Paul Barry</h2><p>适合新手学习 Python</p><h2 id="像计算机科学家一样思考-python----艾伦-b.-唐尼">6.像计算机科学家一样思考 Python ---艾伦 B. 唐尼</h2><p>python2 的语法 适合入门</p><h2 id="python-编程从入门到实践----埃里克马瑟斯">7. Python 编程：从入门到实践 ---埃里克·马瑟斯</h2><p>很好的一本 python 书 语法为 Python3 内容切合书名、 前章讲 python 语法，还提到了测试驱动开发(TDD) 后面接着讲了一些框架，pygame, matplotlib, django</p><h2 id="重构-改善既有代码的设计----马丁福勒">8. 重构-改善既有代码的设计 ---马丁•福勒</h2><p>一本程序员的武功秘籍，时不时走一回心法</p><h2 id="你只是看起来很努力">9. 你只是看起来很努力</h2><p>路走过就一定有他的意义 感情最重要的是两个人拥有独立的心灵和共同进步，不是一个迁就另一个、一个牵制另一个 当你决定旅行的时候，最难的一步已经迈出来了。可是，他还有后面一旬，如果你第一步不迈出，永远不知道你 的梦想是多么容易实现。</p><h2 id="如何阅读一本书----轻阅读编写组">10. 如何阅读一本书 ---轻阅读编写组</h2><p>读书 4 问 转述，如果能将书的内容转述给其他尚未读过该书的人是一个很好的体现你对这本书的内容是否清楚明了。 人与书的交流，人与人的交流</p><h2 id="小王子----安托万德圣埃克苏佩里">11. 小王子 ---安托万•德•圣埃克苏佩里</h2><p>我也不知道那只羊有没有把那朵花吃了</p><h2 id="一只特立独行的猪">12. 一只特立独行的猪</h2><ul><li>感觉我还不能读进去</li><li>王小波的书可能目前我的心态，我的年龄暂时很难理解。</li></ul><h2 id="万万没想到用理工科思维理解世界">13. 万万没想到：用理工科思维理解世界</h2><p>如题：理性</p><h2 id="点起床最养生和高效的时间管理">14. 4 点起床：最养生和高效的时间管理</h2><p>3*8 = 24 小时</p><h2 id="追风筝的人">15. 追风筝的人</h2><h2 id="活着">16. 活着</h2><h2 id="必然">17. 必然</h2><h2 id="未来简史">18. 未来简史</h2><hr><h1 id="section-1">2019</h1><hr><h2 id="一辈子很长要和有趣的人在一起">1.一辈子很长，要和有趣的人在一起</h2><h2 id="android-编程权威指南第二版">2.Android 编程权威指南(第二版)</h2><ul><li>将 Android 开发架构、整体布局是如何的。</li></ul><h2 id="汇编语言第-3-版-王爽著">3.《汇编语言(第 3 版) 》王爽著</h2><ul><li>汇编可能离现在程序员很远，但还是有必要阅读的。了解计算机的底层是如何工作的。任何一门语言到最后都会变成汇编，这也是能和计算机真实交流的唯一途径。</li></ul><h2 id="the-great-gatsby">4.The Great Gatsby</h2><h2 id="高性能-javascript">5.高性能 JavaScript</h2><ul><li>将所有 <code>&lt;script&gt;</code> 标签放在尽可能接近 <code>&lt;body&gt;</code> 标签底部的位置，尽量减少对整个页面下载的影响* 浏览器遇到 script 会下载文件并执行，阻塞页面渲染。</li><li>每个 HTTP 请求都会产生额外的性能负担，下载一个 100KB 的文件比下载四个 25KB 的文件要快。</li><li>defer 指明元素所含脚本不会修改 DOM，可以延迟执行。并行下载，onload 之前执行</li><li>当需要多次访问 DOM 时使用局部变量存储 DOM 引用</li><li>使用更快的 API <code>querySelectorAll</code> <code>firstElementChild</code></li><li>使用事件委托</li><li>循环使用局部变量存储长度，每次循环 8 次操作</li><li>递归改迭代</li><li>浏览器一次同一个域名可以并行的发 6 个请求，所以不必要为了减少网络请求而网络请求</li></ul><h2 id="爱你就像有生命">6.爱你就像有生命</h2><h2 id="倚天屠龙记">7.倚天屠龙记</h2><ul><li>因新版倚天屠龙记上映，说是尊重原著，就看了看原著。</li></ul><hr><h1 id="section-2">2020</h1><hr><h2 id="圣女的救济">1.圣女的救济</h2><ul><li>一次完美犯罪 1 年内凶手都在保护被害者，当需要杀害他的时候只需要什么都不做。</li></ul><h2 id="javascript-dom-编程艺术">2.JavaScript DOM 编程艺术</h2><ul><li>古老的书了，现在手动操作 dom 编程已经很少了。</li></ul><h2 id="ecmascript-6-入门">3.ECMAScript 6 入门</h2><ul><li>ES6 入门的书，细节全面。</li></ul><h2 id="css-世界">4.CSS 世界</h2><ul><li>优先级 min-height/width&gt;&gt;&gt;max-height/width&gt;&gt;&gt;width:!important&gt;&gt;&gt; 内联 style 超越！ important 超越最大</li></ul><h2 id="你不知道的-javascript-上卷">5.你不知道的 JavaScript 上卷</h2><h3 id="理解作用域">1.2 理解作用域</h3><ul><li>引擎会为变量 a 进行 LHS（左值）查询。另外一个查找的类型叫作 RHS（右值）</li><li>RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是试图找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS 并不是真正意义上的“赋值操作的右侧”，更准确地说是“非左侧”。</li></ul><h3 id="词法阶段">2.1 词法阶段</h3><ul><li>没有任何函数的气泡可以（部分地）同时出现在两个外部作用域的气泡中，就如同没有任何函数可以部分地同时出现在两个父级函数中一样。</li></ul><h3 id="欺骗词法">2.2 欺骗词法</h3><ul><li>在执行<code>eval(..)</code>之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态形式插入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找</li><li>with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。</li></ul><h3 id="隐藏内部实现">3.2 隐藏内部实现</h3><ul><li>从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际上就是把这些代码“隐藏”起来了。</li></ul><h3 id="内容">3.3 内容</h3><ul><li>把 configurable 修改成 false 是单向操作，无法撤销！要注意有一个小小的例外：即便属性是<code>writable:false</code>，我们还是可以把<code>writable</code>的状态由 true 改为 false，但是无法由 false 改为 true。除了无法修改，<code>configurable:false</code>还会禁止删除这个属性：</li><li>是否会出现在对象的属性枚举中，比如说 for..in 循环。如果把 enumerable 设置成 false，这个属性就不会出现在枚举中，虽然仍然可以正常访问它。相对地，设置成 true 就会让它出现在枚举中。</li><li>如果你想禁止一个对象添加新属性并且保留已有属性，可以使用<code>Object.prevent Extensions(..)</code>：</li><li><code>Object.preventExtensions(myObject)</code>;</li><li>Object.seal(..)<code>会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用</code>Object.preventExtensions(..)<code>并把所有现有属性标记为</code>configurable:false<code>。</code></li><li><code>Object.freeze(..)</code>会创建一个冻结对象，这个方法实际上会在一个现有对象上调用<code>Object.seal(..)</code>并把所有“数据访问”属性标记为<code>writable:false</code>，这样就无法修改它们的值。</li><li>in<code>和</code>hasOwnProperty(..)<code>的区别在于是否查找</code>[[Prototype]]<code>链，然而，</code>Object.keys(..)<code>和</code>Object.getOwnPropertyNames(..)`都只会查找对象直接包含的属性。</li></ul><h3 id="遍历">3.4 遍历</h3><ul><li>遍历对象属性时的顺序是不确定的，在不同的 JavaScript 引擎中可能不一样。因此，在不同的环境中需要保证一致性时，一定不要相信任何观察到的顺序，它们是不可靠的</li><li>ES6 增加了一种用来遍历数组的 for..of 循环语法（如果对象本身定义了迭代器的话也可以遍历对象</li><li>数组有内置的@<span class="citation" data-cites="iterator">@iterator</span>，因此 for..of 可以直接应用在数组上。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myArray = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ];</span><br><span class="line"><span class="keyword">const</span> it = myArray[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line">it.<span class="title function_">next</span>(); <span class="comment">// &#123; value:1, done:false &#125;</span></span><br><span class="line">it.<span class="title function_">next</span>(); <span class="comment">// &#123; value:2, done:false &#125;</span></span><br><span class="line">it.<span class="title function_">next</span>(); <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line">it.<span class="title function_">next</span>(); <span class="comment">// &#123; done:true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以给任何想遍历的对象定义@@iterator</span></span><br><span class="line"><span class="keyword">const</span> myObject = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(myObject, <span class="title class_">Symbol</span>.<span class="property">iterator</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> o = <span class="variable language_">this</span></span><br><span class="line">        <span class="keyword">let</span> idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">const</span> ks = <span class="title class_">Object</span>.<span class="title function_">keys</span>(o)</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">next</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123; <span class="attr">value</span>: o[ks[idx++]], <span class="attr">done</span>: idx &gt; ks.<span class="property">length</span> &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 手动遍历myObject</span></span><br><span class="line"><span class="keyword">const</span> it = myObject[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()</span><br><span class="line">it.<span class="title function_">next</span>() <span class="comment">//value:1, done:false</span></span><br><span class="line">it.<span class="title function_">next</span>() <span class="comment">//value:2, done:false</span></span><br><span class="line">it.<span class="title function_">next</span>() <span class="comment">//value:undefine, done:true</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="prototype">5.1 [[Prototype]]</h3><ul><li>对于默认的<code>[[Get]]</code>操作来说，如果无法在对象本身找到需要的属性，就会继续访问对象的<code>[[Prototype]]</code>链：<ol type="1"><li>如果在<code>[[Prototype]]</code>链上层存在名为 foo 的普通数据访问属性并且没有被标记为只读（writable:false），那就会直接在 myObject 中添加一个名为 foo 的新属性，它是屏蔽属性。</li><li>如果在<code>[[Prototype]]</code>链上层存在 foo，但是它被标记为只读（writable:false），那么无法修改已有属性或者在 myObject 上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。</li><li>如果在<code>[[Prototype]]</code>链上层存在 foo 并且它是一个 setter，那就一定会调用这个 setter。foo 不会被添加到（或者说屏蔽于）myObject，也不会重新定义 foo 这个 setter。</li></ol></li></ul><h3 id="原型继承">5.3 （原型）继承</h3><ul><li>Bar.prototype = Object.create(Foo.prototype)。调用 Object.create(..)会凭空创建一个“新”对象并把新对象内部的<code>[[Prototype]]</code>关联到你指定的对象（本例中是 Foo.prototype）。换句话说，这条语句的意思是：“创建一个新的 Bar.prototype 对象并把它关联到<code>Foo.prototype</code>”。</li><li>// ES6 之前需要抛弃默认的 Bar.prototype Bar.ptototype = Object.create(Foo.prototype); // ES6 开始可以直接修改现有的 Bar.prototype Object.setPrototypeOf(Bar.prototype, Foo.prototype);</li><li>bind(..)函数来生成一个硬绑定函数，该函数是没有<code>.prototype</code>属性的</li><li>.<strong>proto</strong>`看起来很像一个属性，但是实际上它更像一个 getter/setter。</li></ul><h3 id="面向委托的设计">6.1 面向委托的设计</h3><ul><li>Chrome 会动态跟踪并把实际执行构造过程的函数名当作一个内置属性，但是其他浏览器并不会跟踪这些额外的信息。</li><li>Chrome 内部跟踪（只用于调试输出）“构造函数名称”的方法是 Chrome 自身的一种扩展行为，并不包含在 JavaScript 的规范中。</li><li>JavaScript 中的函数之所以可以访问 call(..)、apply(..)和 bind(..)（，就是因为函数本身是对象。而函数对象同样有[[Prototype]]属性并且关联到 Function.prototype 对象，因此所有函数对象都可以通过委托调用这些默认方法。</li></ul><h3 id="更好的语法">6.4 更好的语法</h3><ul><li>匿名函数没有 name 标识符，这会导致：1．调试栈更难追踪；2．自我引用（递归、事件（解除）绑定，等等）更难；3．代码（稍微）更难理解。</li></ul><h2 id="生命不息折腾不止">6.生命不息，折腾不止</h2><ul><li>罗老师</li></ul><h2 id="react-技术栈">7.React 技术栈</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentWillUpdate</span><br><span class="line">componentDidUpdate</span><br><span class="line">render</span><br><span class="line">中调用</span><br><span class="line">setState会死循环</span><br></pre></td></tr></table></figure><h2 id="高效能人的七个习惯">8.高效能人的七个习惯</h2><ul><li>由内而外</li><li>积极主动</li><li>要事第一</li><li>统合综效</li><li>双赢</li></ul><h2 id="javascript-教程"><a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/index.html">9.JavaScript 教程</a></h2><h2 id="你不知道的-javascript中卷">10.《你不知道的 JavaScript（中卷）》</h2><h3 id="第-1-章-类型">第 1 章 类型</h3><ul><li>ECMAScript 语言类型包括<code>Undefined、Null、Boolean、String、Number和Object</code>。</li><li>typeof null === "object"`; // true 正确的返回结果应该是"null"，但这个 bug 由来已久，在 JavaScript 中已经存在了将近二十年，也许永远也不会修复，因为这牵涉到太多的 Web 系统，“修复”它会产生更多的 bug，令许多系统无法正常工作。</li><li>vaScript 中的变量是没有类型的，只有值才有。</li><li>大多数开发者倾向于将 undefined 等同于 undeclared（未声明），但在 JavaScript 中它们完全是两回事。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable constant_">DEBUG</span> !== <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;Debugging is starting&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第-2-章-值">第 2 章 值</h3><p>IEEE 754 标准来</p><p>JavaScript 使用的是“双精度”格</p><p><code>a.toExponential(); // "5e+10"</code></p><p>因此数字值可以调用 Number.prototype 中的方法</p><p><code>tofixed(..)</code>方法可指定小数部分的显示位数：</p><p><code>toPrecision(..)</code>方法用来指定有效数位的显示位数：</p><p>ES6 开始，严格模式（strict mode）不再支持 0363 八进制格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ES6</span>支持以下新格式：</span><br><span class="line"><span class="number">0o363</span>;      <span class="comment">// 243的八进制</span></span><br><span class="line"><span class="number">0O363</span>;      <span class="comment">// 同上</span></span><br><span class="line"><span class="number">0b11110011</span>; <span class="comment">// 243的二进制</span></span><br><span class="line"><span class="number">0B11110011</span>; <span class="comment">// 同上</span></span><br></pre></td></tr></table></figure><p>二进制浮点数最大的问题（不仅 JavaScript，所有遵循 IEEE 754 规范的语言都是如此），是会出现如下情况： <code>0.1 + 0.2 === 0.3; // false</code></p><p>最常见的方法是设置一个误差范围值，通常称为“机器精度”（machine epsilon），对 JavaScript 的数字来说，这个值通常是 2^-52 (2.220446049250313e-16)。从 ES6 开始，该值定义在 Number.EPSILON 中，我们可以直接拿来用，也可以为 ES6 之前的版本写 polyfill：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (! <span class="title class_">Number</span>.<span class="property">EPSILON</span>) &#123;</span><br><span class="line">  <span class="title class_">Number</span>.<span class="property">EPSILON</span> = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, -<span class="number">52</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能够被“安全”呈现的最大整数是<code>2^53-1</code>，即<code>9007199254740991</code>，在 ES6 中被定义为<code>Number.MAX_SAFE_INTEGER</code>。最小整数是<code>-9007199254740991</code>，在 ES6 中被定义为<code>Number.MIN_SAFE_INTEGER</code>。</p><p>null 指空值（empty value） undefined 指没有值（missing value） 或者： undefined 指从未赋值• null 指曾赋过值，但是目前没有值 null 是一个特殊关键字，不是标识符，我们不能将其当作变量来使用和赋值。然而 undefined 却是一个标识符，可以被当作变量来使用和赋值。</p><p>永远不要重新定义 undefined。</p><p>void 并不改变表达式的结果，只是让表达式不返回值：</p><p>简单值（即标量基本类型值，scalar primitive）总是通过值复制的方式来赋值/传递，包括 null、undefined、字符串、数字、布尔和 ES6 中的 symbol。</p><p>复合值（compound value）——对象（包括数组和封装对象，参见第 3 章）和函数，则总是通过引用复制的方式来赋值/传递。</p><h3 id="第-3-章-原生函数">第 3 章 原生函数</h3><p><code>String.prototype.XYZ</code>简写为<code>String#XYZ</code></p><h3 id="第-4-章-强制类型转换">第 4 章 强制类型转换</h3><ul><li>对普通对象来说，除非自行定义，否则 toString()（Object.prototype.toString()）返回内部属性<code>[[Class]]</code>的值，如<code>"[object Object]"</code>。</li><li>如果对象中定义了<code>toJSON()</code>方法，JSON 字符串化时会首先调用该方法，然后用它的返回值来进行序列化。</li><li>toJSON()返回的应该是一个适当的值，可以是任何类型，然后再由<code>JSON.stringify(..)</code>对其进行字符串化。也就是说，<code>toJSON()</code>应该“返回一个能够被字符串化的安全的 JSON 值”，而不是“返回一个 JSON 字符串”。</li><li>我们可以向 JSON.stringify(..)传递一个可选参数 replacer，它可以是数组或者函数，用来指定对象序列化过程中哪些属性应该被处理，哪些应该被排除，和 toJSON()很像。如果 replacer 是一个数组，那么它必须是一个字符串数组，其中包含序列化要处理的对象的属性名称，除此之外其他的属性则被忽略。如果 replacer 是一个函数，它会对对象本身调用一次，然后对对象中的每个属性各调用一次，每次传递两个参数，键和值。如果要忽略某个键就返回 undefined，否则返回指定的值。</li><li>JSON.stringify 还有一个可选参数 space，用来指定输出的缩进格式。space 为正整数时是指定每一级缩进的字符数，它还可以是字符串，此时最前面的十个字符被用于每一级的缩进：</li><li>ToNumber 对以 0 开头的十六进制数并不按十六进制处理，而是按十进制。</li><li>一元运算+被普遍认为是显式强制类型转换。</li><li>一元运算符+的另一个常见用途是将日期（Date）对象强制类型转换为数字，返回结果为 Unix 时间戳，以毫秒为单位（从 1970 年 1 月 1 日 00:00:00 UTC 到当前时间）：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>( <span class="string">&quot;Mon, 18 Aug 2014 08:53:06 CDT&quot;</span> );</span><br><span class="line">+d; <span class="comment">// 1408369986000</span></span><br></pre></td></tr></table></figure><ul><li>JavaScript 有一处奇特的语法，即构造函数没有参数时可以不用带()</li><li>字位运算符只适用于 32 位整数，运算符会强制操作数使用 32 位格式</li><li>~`。它首先将值强制类型转换为 32 位数字，然后执行字位操作“非”（对每一个字位进行反转）。</li><li>x<code>大致等同于</code>-(x+1)<code>。很奇怪，但相对更容易说明问题：</code>~42; // -(42+1) ==&gt; -43</li><li><code>在</code>-(x+1)<code>中唯一能够得到</code>0（或者严格说是-0）<code>的x值是-1。也就是说如果x为-1时，</code>~`和一些数字值在一起会返回假值 0，其他情况则返回真值。~</li><li>`有什么用处了！~和 indexOf()一起可以将结果强制类型转换（实际上仅仅是转换）为真/假值：</li><li><code>~~</code>中的第一个~执行 ToInt32 并反转字位，然后第二个<code>~</code>再进行一次字位反转，即将所有字位反转回原值，最后得到的仍然是 ToInt32 的结果。</li><li>~~<code>我们要多加注意。首先它只适用于32位数字，更重要的是它对负数的处理与</code>Math.floor(..)`不同。</li><li>x<code>能将值截除为一个32位整数，</code>x | 0`也可以，而且看起来还更简洁。</li><li>Infinity（1/0 的结果）</li><li><code>parseInt("Infinity", 19)</code>。第一个字符是"I"，以 19 为基数时值为 18。第二个字符"n"不是一个有效的数字字符，解析到此为止，和"42px"中的"p"一样。</li><li>如果两边的值中有 true 或者 false，千万不要使用<code>==</code>。如果两边的值中有[]、""或者 0，尽量不要使用==。</li><li>根据规范 a &lt;= b 被处理为 b &lt; a，然后将结果反转</li><li>JavaScript 中<code>&lt;=</code>是“不大于”的意思（即！<code>(a &gt; b)</code>，处理为<code>!(b &lt; a)</code>）</li></ul><h3 id="第-5-章-语法">第 5 章 语法</h3><ul><li>语句都有一个结果值</li><li>获得结果值最直接的方法是在浏览器开发控制台中输入语句，默认情况下控制台会显示所执行的最后一条语句的结果值。</li><li>规范定义 var 的结果值是 undefined</li><li><code>++a++</code>为例，它首先执行<code>a++</code>（根据运算符优先级，如下），返回 42，然后执行++42，这时会产生 ReferenceError 错误，因为++无法直接在 42 这样的值上产生副作用。</li><li>如果操作成功，delete 返回 true，否则返回 false。</li><li>foo: bar()`这样奇怪的语法为什么也合法呢？这里涉及 JavaScript 中一个不太为人知（也不建议使用）的特性，叫作“标签语句”（labeledstatement）。foo 是语句 bar()的标签（后面没有；，参见 5.3 节）。标签语句具体是做什么用的呢？如果 JavaScript 有 goto 语句，理论上我们可以使用 goto foo 跳转到 foo 处执行。goto 被公认为是一种极为糟糕的编码方式，它会让代码变得晦涩难懂（也叫作 spaghetti code），好在 JavaScript 不支持 goto。</li><li>JavaScript 通过标签跳转能够实现 goto 的部分功能。continue 和 break 语句都可以带一个标签，因此能够像 goto 那样进行跳转。例如：contine foo`并不是指“跳转到标签 foo 所在位置继续执行”，而是“执行 foo 循环的下一轮循环”。所以这里的 foo 并非 goto。标签的循环跳转一个更大的用处在于，和<strong>break 一起使用可以实现从内层循环跳转到外层循环</strong>。没有它们的话实现起来有时会非常麻烦：break foo 不是指“跳转到标签 foo 所在位置继续执行”，而是“<strong>跳出标签 foo 所在的循环/代码块，继续执行后面的代码</strong>”。因此它并非传统意义上的 goto。</li><li>SON 属性名必须使用双引号</li><li>通过<code>&lt;script src=..&gt;</code>标签加载 JavaScript 文件，其中只包含 JSON 数据（比如某个 API 返回的结果），那它就会被当作合法的事实上 JavaScript 没有<code>else if</code>，但 if 和 else 只包含单条语句的时候可以省略代码块的{ }else if<code>极为常见，能省掉一层代码缩进，所以很受青睐。但这只是我们自己发明的用法，切勿想当然地认为这些都属于JavaScript语法的范畴。</code></li><li>运算符的优先级比=低<code>。所以</code>b = a++<code>, a其实可以理解为</code>(b = a++), a</li><li>&amp;&amp;运算符的优先级高于||，而||的优先级又高于？:</li></ul><h2 id="你不知道的-javascript下卷">10.《你不知道的 JavaScript（下卷）》</h2><h3 id="第-1-章-异步现在与将来">第 1 章 异步：现在与将来</h3><ul><li>setTimeout(..)并没有把你的回调函数挂在事件循环队列中。它所做的是设定一个定时器。当定时器到时后，环境会把你的回调函数放在事件循环中，这样，在未来某个时刻的 tick 会摘下并执行这个回调。</li><li>并发是指两个或多个事件链随时间发展交替执行，以至于从更高的层次来看，就像是同时在运行（尽管在任意时刻只处理一个事件）。</li></ul><h3 id="第-5-章-程序性能">第 5 章 程序性能</h3><ul><li>Web Worker 的新增特性的探索过程中，这些都是很好的问题。这是浏览器（即宿主环境）的功能，实际上和 JavaScript 语言本身几乎没什么关系。也就是说，JavaScript 当前并没有任何支持多线程执行的功能。</li><li>Worker 可以访问几个重要的全局变量和功能的本地复本，包括 navigator、location、JSON 和 applicationCache。</li><li>你还可以通过 importScripts(..)向 Worker 加载额外的 JavaScript 脚本： // 在 Worker 内部 importScripts( "foo.js", "bar.js" );这些脚本加载是同步的。也就是说，importScripts(..)调用会阻塞余下 Worker 的执行，直到文件加载和执行完成。</li><li>Web Worker 通常应用于哪些方面呢？• 处理密集型数学计算• 大数据集排序• 数据处理（压缩、音频分析、图像处理等）• 高流量网络通信</li><li>当然，所有权传递是可以双向进行的。如果选择 Transferable 对象的话，其实不需要做什么。任何实现了 Transferable 接口（http://developer.mozilla.org/en-US/docs/Web/API/Transferable）的数据结构就自动按照这种方式传输（Firefox和Chrome都支持）。</li></ul><h2 id="九型人格">11.《九型人格》</h2><ul><li>人类的三种体验世界的方式<ul><li>思考</li><li>感觉</li><li>感官</li></ul></li><li>九型人格<ol type="1"><li>完美主义者<ul><li>希望绝对</li><li>喜欢批判自己与他人</li><li>高标准</li></ul></li><li>给予者<ul><li>主动</li><li>乐于助人</li><li>乐观</li><li>慷慨大方</li></ul></li><li>实践者<ul><li>工作狂</li></ul></li><li>浪漫主义者<ul><li>艺术气质</li><li>多情</li></ul></li><li>观察者<ul><li>审慎</li><li>高度隐私</li><li>杰出的决策者和有创意的知识分子</li></ul></li><li>质问者<ul><li>把世界看作威胁</li><li>不喜欢权威</li></ul></li><li>享乐主义者<ul><li>乐观</li><li>精力充沛</li><li>迷人</li><li>难以捉摸</li><li>未来向导者</li></ul></li><li>支配者<ul><li>独断</li><li>有时具有攻击性</li><li>一不做二不休</li><li>领导或者极端孤立者</li></ul></li><li>媒介者<ul><li>和平使者</li><li>不知道自己想要什么</li><li>喜欢和谐而舒适的生活</li></ul></li></ol></li></ul><pre class="mermaid">graph RL;
    完美主义者-->浪漫主义者;
    给予者-->支配者;
    实践者-->媒介者;
    浪漫主义者-->给予者;
    观察者-->享乐主义者;
    质问者-->实践者;
    享乐主义者-->完美主义者;
    支配者-->观察者;
    媒介者-->质问者;</pre><h2 id="编程珠玑">12. 《编程珠玑》</h2><h3 id="给程序员的-10-条建议">给程序员的 10 条建议</h3><ol type="1"><li>解决正确的问题</li><li>探索所有可能的方案</li><li>观察数据</li><li>使用粗略计算</li><li>利用对称性</li><li>利用组件做设计</li><li>建立原型</li><li>必要时进行权衡</li><li>保持简单</li><li>追求完美</li></ol><h3 id="代码调优法则">代码调优法则</h3><ul><li>时间换空间</li><li>空间换时间</li><li>循环法则</li><li>逻辑法则<ul><li>等价的代数表达式换逻辑表达式</li></ul></li><li>过程法则<ul><li>内联</li></ul></li><li>表达式法则<ul><li>if 替换取模% 运算</li></ul></li></ul><h2 id="有些路只能一个人走">13. 《有些路，只能一个人走》</h2><ul><li>态度不可以改变世界，但可以改变自己</li><li>距离高考已经过去 4 年了，4 年里自己改变了什么，自己是否还记得高中时自己想要成为的那个自己。 <strong>生哥</strong>，“我不喜欢别人叫我生哥”。我似乎也忘了我曾经为什么要这么说，不过还有一个人记得。我得想想我当时这么说的原因。</li><li>别讲着别人的故事，忘了自己的。</li><li>时间是最伟大的治疗师。是这么个道理，4 年了，当初高中毕业时那种喜欢一个的人劲现在好像也不知还在不在，不知道如果现在我们又变成同桌我还会不会有从前的感觉了。可能留下的只是美好的祝愿。我现在还记得，我当初给自己的保证，保证自己一定能够回到从前。回到从前的那个灿烂。保证在现在依旧在内心有效，不过也不可能真实的去实现这个过程了。</li><li>你认为的不一定是你想的，你想的不一定是你看到的，你看到的不一定是真实的。同上，我认为我能保证，但是不是，也无从验证。</li><li>自我忍耐与调节：遇到成绩看窗外,遇到问题看镜子。</li><li>真正的爱情：未来</li><li>规划，倒推 OKR</li><li>是谁陪我们到最后的</li></ul><h2 id="代码整洁之道">14. 《代码整洁之道》</h2><h3 id="整洁的代码">整洁的代码</h3><ul><li>优雅，高效，减少依赖，优美的散文，让你的营地比来时更干净</li></ul><hr><h3 id="有意义的命名">有意义的命名</h3><ul><li><p>下标的意义 说清楚 == -1</p></li><li><p>值的意义</p></li><li><p>要能读得出来</p></li><li><div class="sourceCode" id="cb1"><pre class="sourceCode typescript"><code class="sourceCode typescript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>  <span class="fu">getActiveAccount</span>()</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">getActiveAccounts</span>()</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">getActiveAccountInfo</span>()</span></code></pre></div></li><li><p>不必使用成员变量前缘，调用者很快会无视这个前缀</p></li><li><p>类名和对象名应当是名词或者名词短语</p></li><li><p>方法名应该是动词或者动词短语</p></li><li><p>避免同一单词不同意义，双关语</p></li><li><p>添加<strong>有意义</strong>语境</p><ul><li>firstName,lastName,street,city,state,zipcode 放在一起时很明确是一个地址信息</li><li>当单独拆开时不明其意，可以添加适当的语境。addrFirstName, addrLastName,addrCity,addrZipcode</li></ul></li></ul><hr><h3 id="函数">函数</h3><ul><li>第一规则：短小，第二规则：还要更短小。</li><li>只做一件事，做好这一件事。</li><li>自顶向下，每一个函数为一个抽象层级。看看源码</li><li>使用描述性名称，描述函数做的事</li><li>别害怕长名称，长而具有描述性的名称比短页而令人费解的名称好。<ul><li>getHomeOpenStatusByActivityId</li><li>getHomeOpenStatusByDepId</li><li>前端在 webpack 打包时也会压缩</li></ul></li><li>参数<ul><li>无参数<strong>最理想</strong></li><li>其次一个参数，两个参数</li><li>避免出现三个级以上参数<ul><li>多个参数在写 test 的时候要能写出确保各种组合运行正常的测试用例</li><li>如果需要多个参数，那说明其中一些可以封装成类了</li></ul></li></ul></li><li>函数要么做什么事，要么回答什么事。</li><li>使用异常代替错误返回码</li><li>结构化编程<ul><li>每个函数只有一个入口，一个出口（ 一个 return）</li><li>循环中不能有 break 和 continue</li></ul></li></ul><h3 id="注释">注释</h3><ul><li>注释的恰当用法是<strong>弥补</strong>我们在用代码表达意图遭遇的失败</li><li>注释是一种失败</li><li>注释应当少</li><li><strong>注释是对意图的解释</strong></li><li>注释要能提供信息</li><li>TODO 应当是程序员认为应该做的，但现在还没有做的工作</li><li>不要写无用的注释和废话注释</li><li>删掉注释的代码</li></ul><h3 id="类">类</h3><ul><li>一个类应该短小</li><li>单一权责原则</li><li>类中每个方法应当操作一个或者一种变量</li><li>开闭原则。对拓展开发，对修改封闭。jQuery.extend</li></ul><h2 id="张爱玲传">15.张爱玲传</h2><ul><li>记得别人的小恩惠</li><li>你若了解的我过去，你便会原谅现在的我。</li><li>人总是容易崇拜一个在你弱势的方面显得强势的人。</li><li>生命中总有这样的时候，对我们重要的一些人有可能就在身边我们却不知，不到那一刻完全没明白宿命的安排，像面纱一样罩着。</li><li>一个天才的女人忽然结了婚。</li><li>中国人向来不喜欢异类。</li><li>爱情中的女人，一如既往的付出，为了对得起自己的青春。</li><li>性格相似的同类适合做朋友，但不适合生活在一起，性格互补的异性更适合在一起，因为很少有冲突，---只要互补的是个性，相似的是兴趣爱好，便是绝佳的组合。</li><li>精神是想通。</li><li>最擅长写爱情，却恋爱都没谈过。</li><li>噢，你也在这里吗？</li><li>定情信物。</li><li>溃烂早已愈合，那酱紫色的难堪却还在。</li><li>见了他，她变得很低很低，低到尘埃里，但她心里是欢喜的，从尘埃里开出花来。</li><li>最幸福的事莫过于你喜欢的人，他刚好也喜欢你。</li><li>生活是一袭华美的袍， 上面爬满了虱子。</li><li>年经的女孩子不需要美貌，只青春就够了。</li><li>五六十岁的外国背包客。</li></ul><h1 id="section-3">2021</h1><hr><h2 id="重构">1. 重构</h2><ul><li>重构本来就不是一件应该特别拨出时间做的事情，重构应该随时随地进行。你不应该为重构而重构，你之所以重构，是因为你想做别的什么事，而重构可以帮助你把那些事做好。</li><li>看见不规范的、可以优化的不敢改。<ul><li>不敢改，你写什么代码嘛。</li></ul></li><li>需要重构的是你不知这段代码在干什么，不了解它的行为。对于了解其行为的说明还不是那么迫切需要重构。</li></ul><h3 id="法则">法则</h3><ul><li>事不过三，三则重构。<ul><li>第一次做某件事时只管去做;第二次做类似的事会产生反感，但无论如何还是可以去做;第三次再做类似的事，就应该重构。</li></ul></li><li>添加功能时重构</li><li>修补错误时重构 代码还不够清晰----没有清晰到让你能一眼看出 bug。</li><li>复审代码时重构 code review</li></ul><h3 id="坏代码">坏代码</h3><ul><li>重复的代码</li><li>过长的函数</li><li>过大的类</li><li>过长的参数列表</li><li>发散式变化<ul><li>由最初的功能单一在进行后期的迭代扩展后，功能不再单一，功能形成发散式的变化</li></ul></li><li>霰弹式修改<ul><li>遇到功能变化时需要在多个类中进行许多小修改</li></ul></li><li>依恋情节<ul><li>一个函数为计算某个值从某个类取了许多值，过渡依恋这个类，就可以把这个方法写入到这个类中</li><li>保证数据和操作数据的行为在一个地方</li></ul></li><li>数据泥团<ul><li>相同的几项数据，几个类拥有几个差不多的属性，几个方法的参数差不多</li></ul></li><li>switch<ul><li>使用多态替换</li></ul></li><li>过渡的消息链<ul><li>用户向一个对象请求另一个对象，再通过这个获取的对象去获取另一个对象</li><li>但不是任何函数链都是坏代码</li></ul></li><li>过多的注释<ul><li>如果需要注释来解释一块代码做了什么，试着提炼出方式</li><li>如果还需要注释来解释其行为，试试修改函数名</li><li>如果还需要注释来说明某些系统的需求规格，试试引入断言</li><li>如果不知道要做什么，这个时候才该说注释</li></ul></li></ul><p>重构的前提需要一个可靠的测试环境，但对于前端来说，单测较少，更多的是需要 QA 的 RD 的自测，这可能也是在前端不愿意修改旧代码的原因。</p><h3 id="重构列表方法">重构列表（方法）</h3><h4 id="提炼函数">1.提炼函数</h4><p>这也是我们在重构/编码过程中使用到最多的方式</p><p>让函数名表明它的意图，尽量让一个函数没有过多的注释来表明它的意图。</p><h4 id="内联函数">2.内联函数</h4><p>当函数内部的代码足够简短到表达这个函数的意图时，可以将这个函数去掉。</p><p>或者在重构一个大的函数时，将内部的小函数进行重新拆解并重新组合。</p><h4 id="内联临时变量">3.内联临时变量</h4><p>一个临时变量只被赋值过一次，且只被使用过一次时，就可以消除这个临时变量</p><h4 id="以查询代替临时变量">4.以查询代替临时变量</h4><p>临时变量是临时（计算出来）的，只有在函数内部使用，就可以通过将这变量包装成一个函数。</p><p>类似 vue 的计算属性</p><h4 id="引入注释性变量">5.引入注释性变量</h4><p>将一个复杂的表达式的结果放进一个临时变量，用变量名来解释对应的用途。</p><p>也类似 vue 的计算属性</p><h4 id="分解临时变量">6.分解临时变量</h4><p>一个临时变量被多次赋值，但不同阶段表达的意思不同时，就可以使用多个临时变量代替</p><h4 id="移出对参数的赋值">7.移出对参数的赋值</h4><p>参数的值尽量只在函数被调用时赋值，函数体内不必再对这个参数进行重新赋值，提高代码的清晰度，在函数内部任何地方使用是，参数的指向都是唯一确定的</p><h4 id="以函数对象取代函数">8.以函数对象取代函数</h4><p>当存在一个大型的函数，内部局部变量使用的情况导致不能再提炼更小的函数时，将这个函数放入一个对象中，函数的局部变量就变成为个对象的字段，这个时候再把这个大型函数提炼成多个小的函数。</p><h4 id="替换算法">9.替换算法</h4><p>换一种更清晰的算法</p><h3 id="重构列表在对象之间">重构列表（在对象之间）</h3><h4 id="搬移函数">1.搬移函数</h4><p>类 A 中的一个函数 F 与另一个类 B 进行的交流更多，F 调用类 B，B 调用 F。可以将这个 F 搬移到 B 中。</p><h4 id="搬移字段">2.搬移字段</h4><p>类 A 中的一个字段 P 与另一个类 B 进行的交流更多，P 调用类 B，B 调用 P。可以将这个 P 搬移到 B 中。</p><h4 id="提炼类">4.提炼类</h4><p>一个类做了由两个类做的事，可以新建一个类，将相应的功能拆分。</p><h4 id="内联类">5.内联类</h4><p>一个类没有做太多的事，可以将其萎缩塞进另一个类中。</p><h3 id="简化表达式">简化表达式</h3><h4 id="分解表达式">1.分解表达式</h4><p>把多个 if-else 拆分成独立的函数，让函数表达该表达式的含义</p><h4 id="合并表达式">2.合并表达式</h4><p>判断条件不同，但行为是一致的（比如:return） 奖这个抽取成一个单独函数</p><h4 id="合并重复的条件判断">3.合并重复的条件判断</h4><p>一组表达式的所有分支都执行相应的代码，就可以抽取到外部</p><h4 id="以卫语句取代嵌套条件表达式">4.以卫语句取代嵌套条件表达式</h4><p>卫语句： 单独检查的语句。代表它比较特殊，全部 if-else 会让每个条件都显得重要性一致，使用单独的判断表示这个条件的特殊性.</p><h3 id="简化函数调用">简化函数调用</h3><h4 id="给函数取个名字">1.给函数取个名字</h4><p>函数的名称应该准确表达它的用途。给函数命名有一个好办法：首先考虑应该给这个函数写上一句怎样的注释，然后想办法将注释变成函数名称。</p><h4 id="以明确函数取代参数">2.以明确函数取代参数</h4><p>有一个函数，其中完全取决于参数值而采取不同行为。针对该参数的每一个可能值，建立一个独立函数。</p><h4 id="以函数取代参数">3.以函数取代参数</h4><p>当一个函数的参数为另一个函数的返回值时，让参数接受者内部去调用这个函数</p><h4 id="隐藏函数">3.隐藏函数</h4><p>一个类的某些函数没有在其他地方使用时，将其设为 private</p><h2 id="人月神话">2.人月神话</h2><h3 id="杂">杂</h3><ul><li>编程乐趣<ul><li>一种创建事件的纯粹快乐</li><li>开发出对他人有用，自己的劳动成果能够被他人使用</li><li>系统开发过程的魅力，将各个零部件组装在一起，以精妙的方式运行着，并收到预期的效果。</li><li>凭自己的想象建造自己的城堡。</li></ul></li><li>编程的苦恼<ul><li>来自追求完美</li><li>对其他人的依赖是一件痛苦的事（在别人的项目上进行二次开发）</li><li>寻找 bug 是一个重复性的活动，枯燥。</li><li>投入大量时间当完成时，去显得陈旧过时。</li><li>这次肯定会运行，，我刚刚找出最后一个 bug</li></ul></li><li>软件任务进度安排<ul><li>1/3 计划</li><li>1/6 编码</li><li>1/4 软件测试和早期系统测试</li><li>1/4 系统测试，所有的构件已完成</li></ul></li><li>Brooks 法则<ul><li>向进度落后的项目上增加人手，只会使项目更加落后。</li></ul></li></ul><h3 id="外科手术队伍">外科手术队伍</h3><pre class="mermaid">graph TB;
外科医生 --> 管理员
管理员 --> 文秘1
外科医生 --> 编辑
编辑 --> 文秘2
外科医生 --> 副手
外科医生 --> 程序职员
外科医生 --> 工具维护人员
外科医生 --> 测试人员
外科医生 --> 语言专家</pre><ul><li>外科医生<ul><li>首席程序员，定义功能和性能技术，设计程序，编制源代码、测试，技术文档</li></ul></li><li>副手<ul><li>设计的思考者、讨论者和评估人员。主要是讨论</li></ul></li><li>管理员<ul><li>外科医生的老板</li><li>在管理人员、薪酬、办公空间有决定权，但不能花太多时候</li><li>一个文秘<ul><li>专业管理人员。</li></ul></li></ul></li><li>编辑<ul><li>外科医生负责文档的生成。编辑根据外科医生的草稿，口述，进行分析和重组，提供各种文档</li><li>一个文秘</li></ul></li><li>两个文秘<ul><li>属于管理员和编辑</li></ul></li><li>程序职员<ul><li>所有的团队技术记录，接收文秘性质的培训，所有计算机输入的汇总点。</li></ul></li><li>工具维护人员<ul><li>检查外科医生需要的工具，需要开发一些实用程序。</li></ul></li><li>测试人员<ul><li>测试</li></ul></li><li>语言专家<ul><li>掌握复杂编程语言专家。</li></ul></li></ul><h2 id="云边有个小卖部">2.云边有个小卖部</h2><p>我这一生只向世界问候过 3 次，刚好每次都遇到了你。</p><h2 id="时间的朋友2015-2017">3. 时间的朋友（2015-2017）</h2><h2 id="了不起的-node.js">4. 了不起的 Node.js</h2><h2 id="更了不起的-node.js-卷一">4. 更了不起的 Node.js 卷一</h2><ul><li>深入到源码，从源码理解 Node.js</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E4%B9%A6/" rel="tag"># 书</a></div><div class="post-nav"><div class="post-nav-item"></div><div class="post-nav-item"><a href="/202001/ubuntu%E5%8F%96%E6%B6%88sudo%E5%AF%86%E7%A0%81/" rel="next" title="ubuntu 取消 sudo 密码">ubuntu 取消 sudo 密码 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="gitalk-container"></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:t}=CONFIG.comments;if(CONFIG.comments.storage&&(t=localStorage.getItem("comments_active")||t),t){let e=document.querySelector(`a[href="#comment-${t}"]`);e&&e.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{if(!t.target.matches(".tabs-comment .tab-content .tab-pane"))return;let e=t.target.classList[1];localStorage.setItem("comments_active",e)})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#section"><span class="nav-number">1.</span> <span class="nav-text">2018</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%BA%E6%80%A7%E7%9A%84%E5%BC%B1%E7%82%B9----%E5%8D%A1%E8%80%90%E5%9F%BA"><span class="nav-number">1.1.</span> <span class="nav-text">1. 人性的弱点 ---卡耐基</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%A0%E4%B8%80%E5%B9%B4%E7%9A%84-8760-%E5%B0%8F%E6%97%B6----%E8%89%BE%E5%8A%9B"><span class="nav-number">1.2.</span> <span class="nav-text">2. 你一年的 8760 小时 ---艾力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%97%B6%E4%BB%A3%E7%94%9F%E6%B4%BB%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%80%9D%E7%BB%B4%E7%9A%84%E5%A4%A7%E5%8F%98%E9%9D%A9----%E7%BB%B4%E5%85%8B%E6%89%98%E8%BF%88%E5%B0%94%E8%88%8D%E6%81%A9%E4%BC%AF%E6%A0%BC"><span class="nav-number">1.3.</span> <span class="nav-text">3. 大数据时代：生活、工作与思维的大变革 ---维克托•迈尔•舍恩伯格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E9%9A%90%E5%8C%BF%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%83%8C%E5%90%8E%E7%9A%84%E8%AF%AD%E8%A8%80----%E6%9F%A5%E5%B0%94%E6%96%AF%E4%BD%A9%E6%8E%AA%E5%B0%94%E5%BE%B7"><span class="nav-number">1.4.</span> <span class="nav-text">4. 编码：隐匿在计算机软硬件背后的语言 ---查尔斯•佩措尔德</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#head-first-python----paul-barry"><span class="nav-number">1.5.</span> <span class="nav-text">5. Head First Python ---Paul Barry</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%83%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AE%B6%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83-python----%E8%89%BE%E4%BC%A6-b.-%E5%94%90%E5%B0%BC"><span class="nav-number">1.6.</span> <span class="nav-text">6.像计算机科学家一样思考 Python ---艾伦 B. 唐尼</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python-%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5----%E5%9F%83%E9%87%8C%E5%85%8B%E9%A9%AC%E7%91%9F%E6%96%AF"><span class="nav-number">1.7.</span> <span class="nav-text">7. Python 编程：从入门到实践 ---埃里克·马瑟斯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1----%E9%A9%AC%E4%B8%81%E7%A6%8F%E5%8B%92"><span class="nav-number">1.8.</span> <span class="nav-text">8. 重构-改善既有代码的设计 ---马丁•福勒</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%A0%E5%8F%AA%E6%98%AF%E7%9C%8B%E8%B5%B7%E6%9D%A5%E5%BE%88%E5%8A%AA%E5%8A%9B"><span class="nav-number">1.9.</span> <span class="nav-text">9. 你只是看起来很努力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6----%E8%BD%BB%E9%98%85%E8%AF%BB%E7%BC%96%E5%86%99%E7%BB%84"><span class="nav-number">1.10.</span> <span class="nav-text">10. 如何阅读一本书 ---轻阅读编写组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%8E%8B%E5%AD%90----%E5%AE%89%E6%89%98%E4%B8%87%E5%BE%B7%E5%9C%A3%E5%9F%83%E5%85%8B%E8%8B%8F%E4%BD%A9%E9%87%8C"><span class="nav-number">1.11.</span> <span class="nav-text">11. 小王子 ---安托万•德•圣埃克苏佩里</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E5%8F%AA%E7%89%B9%E7%AB%8B%E7%8B%AC%E8%A1%8C%E7%9A%84%E7%8C%AA"><span class="nav-number">1.12.</span> <span class="nav-text">12. 一只特立独行的猪</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%87%E4%B8%87%E6%B2%A1%E6%83%B3%E5%88%B0%E7%94%A8%E7%90%86%E5%B7%A5%E7%A7%91%E6%80%9D%E7%BB%B4%E7%90%86%E8%A7%A3%E4%B8%96%E7%95%8C"><span class="nav-number">1.13.</span> <span class="nav-text">13. 万万没想到：用理工科思维理解世界</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%82%B9%E8%B5%B7%E5%BA%8A%E6%9C%80%E5%85%BB%E7%94%9F%E5%92%8C%E9%AB%98%E6%95%88%E7%9A%84%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86"><span class="nav-number">1.14.</span> <span class="nav-text">14. 4 点起床：最养生和高效的时间管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%BD%E9%A3%8E%E7%AD%9D%E7%9A%84%E4%BA%BA"><span class="nav-number">1.15.</span> <span class="nav-text">15. 追风筝的人</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B4%BB%E7%9D%80"><span class="nav-number">1.16.</span> <span class="nav-text">16. 活着</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%85%E7%84%B6"><span class="nav-number">1.17.</span> <span class="nav-text">17. 必然</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AA%E6%9D%A5%E7%AE%80%E5%8F%B2"><span class="nav-number">1.18.</span> <span class="nav-text">18. 未来简史</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#section-1"><span class="nav-number">2.</span> <span class="nav-text">2019</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E8%BE%88%E5%AD%90%E5%BE%88%E9%95%BF%E8%A6%81%E5%92%8C%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%BA%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="nav-number">2.1.</span> <span class="nav-text">1.一辈子很长，要和有趣的人在一起</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#android-%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%BA%8C%E7%89%88"><span class="nav-number">2.2.</span> <span class="nav-text">2.Android 编程权威指南(第二版)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC-3-%E7%89%88-%E7%8E%8B%E7%88%BD%E8%91%97"><span class="nav-number">2.3.</span> <span class="nav-text">3.《汇编语言(第 3 版) 》王爽著</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#the-great-gatsby"><span class="nav-number">2.4.</span> <span class="nav-text">4.The Great Gatsby</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD-javascript"><span class="nav-number">2.5.</span> <span class="nav-text">5.高性能 JavaScript</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%88%B1%E4%BD%A0%E5%B0%B1%E5%83%8F%E6%9C%89%E7%94%9F%E5%91%BD"><span class="nav-number">2.6.</span> <span class="nav-text">6.爱你就像有生命</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%80%9A%E5%A4%A9%E5%B1%A0%E9%BE%99%E8%AE%B0"><span class="nav-number">2.7.</span> <span class="nav-text">7.倚天屠龙记</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#section-2"><span class="nav-number">3.</span> <span class="nav-text">2020</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A3%E5%A5%B3%E7%9A%84%E6%95%91%E6%B5%8E"><span class="nav-number">3.1.</span> <span class="nav-text">1.圣女的救济</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#javascript-dom-%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF"><span class="nav-number">3.2.</span> <span class="nav-text">2.JavaScript DOM 编程艺术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ecmascript-6-%E5%85%A5%E9%97%A8"><span class="nav-number">3.3.</span> <span class="nav-text">3.ECMAScript 6 入门</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#css-%E4%B8%96%E7%95%8C"><span class="nav-number">3.4.</span> <span class="nav-text">4.CSS 世界</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84-javascript-%E4%B8%8A%E5%8D%B7"><span class="nav-number">3.5.</span> <span class="nav-text">5.你不知道的 JavaScript 上卷</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">3.5.1.</span> <span class="nav-text">1.2 理解作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%8D%E6%B3%95%E9%98%B6%E6%AE%B5"><span class="nav-number">3.5.2.</span> <span class="nav-text">2.1 词法阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AC%BA%E9%AA%97%E8%AF%8D%E6%B3%95"><span class="nav-number">3.5.3.</span> <span class="nav-text">2.2 欺骗词法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E8%97%8F%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.5.4.</span> <span class="nav-text">3.2 隐藏内部实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AE%B9"><span class="nav-number">3.5.5.</span> <span class="nav-text">3.3 内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86"><span class="nav-number">3.5.6.</span> <span class="nav-text">3.4 遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#prototype"><span class="nav-number">3.5.7.</span> <span class="nav-text">5.1 [[Prototype]]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF"><span class="nav-number">3.5.8.</span> <span class="nav-text">5.3 （原型）继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%A7%94%E6%89%98%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">3.5.9.</span> <span class="nav-text">6.1 面向委托的设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A5%BD%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="nav-number">3.5.10.</span> <span class="nav-text">6.4 更好的语法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E4%B8%8D%E6%81%AF%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2"><span class="nav-number">3.6.</span> <span class="nav-text">6.生命不息，折腾不止</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#react-%E6%8A%80%E6%9C%AF%E6%A0%88"><span class="nav-number">3.7.</span> <span class="nav-text">7.React 技术栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF"><span class="nav-number">3.8.</span> <span class="nav-text">8.高效能人的七个习惯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#javascript-%E6%95%99%E7%A8%8B"><span class="nav-number">3.9.</span> <span class="nav-text">9.JavaScript 教程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84-javascript%E4%B8%AD%E5%8D%B7"><span class="nav-number">3.10.</span> <span class="nav-text">10.《你不知道的 JavaScript（中卷）》</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC-1-%E7%AB%A0-%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.10.1.</span> <span class="nav-text">第 1 章 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC-2-%E7%AB%A0-%E5%80%BC"><span class="nav-number">3.10.2.</span> <span class="nav-text">第 2 章 值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC-3-%E7%AB%A0-%E5%8E%9F%E7%94%9F%E5%87%BD%E6%95%B0"><span class="nav-number">3.10.3.</span> <span class="nav-text">第 3 章 原生函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC-4-%E7%AB%A0-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.10.4.</span> <span class="nav-text">第 4 章 强制类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC-5-%E7%AB%A0-%E8%AF%AD%E6%B3%95"><span class="nav-number">3.10.5.</span> <span class="nav-text">第 5 章 语法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84-javascript%E4%B8%8B%E5%8D%B7"><span class="nav-number">3.11.</span> <span class="nav-text">10.《你不知道的 JavaScript（下卷）》</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC-1-%E7%AB%A0-%E5%BC%82%E6%AD%A5%E7%8E%B0%E5%9C%A8%E4%B8%8E%E5%B0%86%E6%9D%A5"><span class="nav-number">3.11.1.</span> <span class="nav-text">第 1 章 异步：现在与将来</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC-5-%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD"><span class="nav-number">3.11.2.</span> <span class="nav-text">第 5 章 程序性能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%9D%E5%9E%8B%E4%BA%BA%E6%A0%BC"><span class="nav-number">3.12.</span> <span class="nav-text">11.《九型人格》</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91"><span class="nav-number">3.13.</span> <span class="nav-text">12. 《编程珠玑》</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%99%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84-10-%E6%9D%A1%E5%BB%BA%E8%AE%AE"><span class="nav-number">3.13.1.</span> <span class="nav-text">给程序员的 10 条建议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%B0%83%E4%BC%98%E6%B3%95%E5%88%99"><span class="nav-number">3.13.2.</span> <span class="nav-text">代码调优法则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E4%BA%9B%E8%B7%AF%E5%8F%AA%E8%83%BD%E4%B8%80%E4%B8%AA%E4%BA%BA%E8%B5%B0"><span class="nav-number">3.14.</span> <span class="nav-text">13. 《有些路，只能一个人走》</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93"><span class="nav-number">3.15.</span> <span class="nav-text">14. 《代码整洁之道》</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%B4%81%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">3.15.1.</span> <span class="nav-text">整洁的代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84%E5%91%BD%E5%90%8D"><span class="nav-number">3.15.2.</span> <span class="nav-text">有意义的命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">3.15.3.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-number">3.15.4.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">3.15.5.</span> <span class="nav-text">类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%A0%E7%88%B1%E7%8E%B2%E4%BC%A0"><span class="nav-number">3.16.</span> <span class="nav-text">15.张爱玲传</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#section-3"><span class="nav-number">4.</span> <span class="nav-text">2021</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E6%9E%84"><span class="nav-number">4.1.</span> <span class="nav-text">1. 重构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%95%E5%88%99"><span class="nav-number">4.1.1.</span> <span class="nav-text">法则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9D%8F%E4%BB%A3%E7%A0%81"><span class="nav-number">4.1.2.</span> <span class="nav-text">坏代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%9E%84%E5%88%97%E8%A1%A8%E6%96%B9%E6%B3%95"><span class="nav-number">4.1.3.</span> <span class="nav-text">重构列表（方法）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%82%BC%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">1.提炼函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.3.2.</span> <span class="nav-text">2.内联函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E8%81%94%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F"><span class="nav-number">4.1.3.3.</span> <span class="nav-text">3.内联临时变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A5%E6%9F%A5%E8%AF%A2%E4%BB%A3%E6%9B%BF%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F"><span class="nav-number">4.1.3.4.</span> <span class="nav-text">4.以查询代替临时变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E5%85%A5%E6%B3%A8%E9%87%8A%E6%80%A7%E5%8F%98%E9%87%8F"><span class="nav-number">4.1.3.5.</span> <span class="nav-text">5.引入注释性变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E8%A7%A3%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F"><span class="nav-number">4.1.3.6.</span> <span class="nav-text">6.分解临时变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E5%87%BA%E5%AF%B9%E5%8F%82%E6%95%B0%E7%9A%84%E8%B5%8B%E5%80%BC"><span class="nav-number">4.1.3.7.</span> <span class="nav-text">7.移出对参数的赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A5%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%8F%96%E4%BB%A3%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.3.8.</span> <span class="nav-text">8.以函数对象取代函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">4.1.3.9.</span> <span class="nav-text">9.替换算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%9E%84%E5%88%97%E8%A1%A8%E5%9C%A8%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4"><span class="nav-number">4.1.4.</span> <span class="nav-text">重构列表（在对象之间）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%90%AC%E7%A7%BB%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.4.1.</span> <span class="nav-text">1.搬移函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%90%AC%E7%A7%BB%E5%AD%97%E6%AE%B5"><span class="nav-number">4.1.4.2.</span> <span class="nav-text">2.搬移字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%82%BC%E7%B1%BB"><span class="nav-number">4.1.4.3.</span> <span class="nav-text">4.提炼类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E8%81%94%E7%B1%BB"><span class="nav-number">4.1.4.4.</span> <span class="nav-text">5.内联类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8C%96%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.1.5.</span> <span class="nav-text">简化表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E8%A7%A3%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.1.5.1.</span> <span class="nav-text">1.分解表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.1.5.2.</span> <span class="nav-text">2.合并表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E9%87%8D%E5%A4%8D%E7%9A%84%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="nav-number">4.1.5.3.</span> <span class="nav-text">3.合并重复的条件判断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A5%E5%8D%AB%E8%AF%AD%E5%8F%A5%E5%8F%96%E4%BB%A3%E5%B5%8C%E5%A5%97%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.1.5.4.</span> <span class="nav-text">4.以卫语句取代嵌套条件表达式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8C%96%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">4.1.6.</span> <span class="nav-text">简化函数调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%99%E5%87%BD%E6%95%B0%E5%8F%96%E4%B8%AA%E5%90%8D%E5%AD%97"><span class="nav-number">4.1.6.1.</span> <span class="nav-text">1.给函数取个名字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A5%E6%98%8E%E7%A1%AE%E5%87%BD%E6%95%B0%E5%8F%96%E4%BB%A3%E5%8F%82%E6%95%B0"><span class="nav-number">4.1.6.2.</span> <span class="nav-text">2.以明确函数取代参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A5%E5%87%BD%E6%95%B0%E5%8F%96%E4%BB%A3%E5%8F%82%E6%95%B0"><span class="nav-number">4.1.6.3.</span> <span class="nav-text">3.以函数取代参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E8%97%8F%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.6.4.</span> <span class="nav-text">3.隐藏函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D"><span class="nav-number">4.2.</span> <span class="nav-text">2.人月神话</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%82"><span class="nav-number">4.2.1.</span> <span class="nav-text">杂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E7%A7%91%E6%89%8B%E6%9C%AF%E9%98%9F%E4%BC%8D"><span class="nav-number">4.2.2.</span> <span class="nav-text">外科手术队伍</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%91%E8%BE%B9%E6%9C%89%E4%B8%AA%E5%B0%8F%E5%8D%96%E9%83%A8"><span class="nav-number">4.3.</span> <span class="nav-text">2.云边有个小卖部</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B2015-2017"><span class="nav-number">4.4.</span> <span class="nav-text">3. 时间的朋友（2015-2017）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84-node.js"><span class="nav-number">4.5.</span> <span class="nav-text">4. 了不起的 Node.js</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84-node.js-%E5%8D%B7%E4%B8%80"><span class="nav-number">4.6.</span> <span class="nav-text">4. 更了不起的 Node.js 卷一</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Xiongsheng Dai</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">68</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">25</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/daixiongsheng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;daixiongsheng" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:daixiongsheng@gmail.com" title="E-Mail → mailto:daixiongsheng@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fas fa-rss fa-fw"></i>RSS</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="/utils/" title="&#x2F;utils&#x2F;">工具方法库</a></li></ul></div><div class="widget-wrap" style="width:90%;margin-left:auto;margin-right:auto;opacity:.97"><div class="widget" id="CloudCalendar"></div></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Xiongsheng Dai</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script>!function(){var e,t,o=document.getElementsByTagName("link");if(o.length>0)for(i=0;i<o.length;i++)"canonical"==o[i].rel.toLowerCase()&&o[i].href&&(e=o[i].href);t=e?e.split(":")[0]:window.location.protocol.split(":")[0],e||(e=window.location.href),function(){var i=e,o=document.referrer;if(!/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(i)){var n="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";o?(n+="?r="+encodeURIComponent(document.referrer),i&&(n+="&l="+i)):i&&(n+="?l="+i),(new Image).src=n}}(window)}()</script><script src="/js/local-search.js"></script><script>document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js",()=>{mermaid.initialize({theme:"default",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script>NexT.utils.loadComments(document.querySelector("#gitalk-container"),()=>{NexT.utils.getScript("//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js",()=>{new Gitalk({clientID:"b35f76e73ebc6f08af3d",clientSecret:"f7e419da4fdd2c8b381a599bc7efc71f927b0072",repo:"daixiongsheng.github.io",owner:"daixiongsheng",admin:["daixiongsheng"],id:"1044c920f06a36550318db63c22db19a",language:"zh-CN",distractionFreeMode:!0}).render("gitalk-container")},window.Gitalk)})</script></body></html>