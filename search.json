[{"title":"isNaN和Number.isNaN","url":"/202108/isNaN和Number-isNaN/","content":"\n# isNaN\n\n`isNaN` 是挂在 `window` 上的一个函数，判断时会对传入的值进行类型判断，如果不是 `number` 类型会进行一次转换转换，不能正确判断出 `NaN`\n\n![1628957097548SL6lFH](https://gitee.com/daixiongsheng/pictures/raw/master/2021/08/15/1628957097548SL6lFH.png)\n\n这里传入的不是 `number` 类型，会进行类型转换，调用他的 `valueOf` 方法，该方法返回 `undefiend` 再对 `undefiend` 转换成 `number`\n\n类似这样，`undefined` 转换成 `number` 正是 `NaN` 所以返回 `true`\n\n![1628957230645WpG9Lz](https://gitee.com/daixiongsheng/pictures/raw/master/2021/08/15/1628957230645WpG9Lz.png)\n\n# Number.isNaN\n\n可以正确判断出 `NaN`, 首先会对传入的参数进行类型判断，如果不是`number` 直接返回`false`\n\n![1628957434248PTvcm5](https://gitee.com/daixiongsheng/pictures/raw/master/2021/08/15/1628957434248PTvcm5.png)\n","tags":["前端"]},{"title":"JS变量提升","url":"/202106/JS变量提升/","content":"\n## 总结\n\n学好编译原理。\n\n## 动态类型语言与类型静态语言\n\n`JavaScript` 和 `Java` 区别是啥？\n\n老婆与老婆饼的区别。😬😬 说笑了~\n\n动态类型语言给人的感觉好像是按行执行，执行到哪就干哪行的代码，静态类型语言先编译再执行。其实我觉得不全对，动态类型语言应该也有他对应的字节码。\n\n## 变量提升\n\n指的就是在 `JS` 里面用 `var ` 关键字定义变量时会提升到最前面，这个过程在词法分析语法分析的时候已经做了，而不是在运行时\n\n比如\n\n```js\nconsole.log(age) // undefined\nvar age = 26\n\n// 可以理解为\nvar age\nconsole.log(age)\nage = 26\n```\n\n```JS\nif(!('a' in window)) {\n  var a = 1;\n}\nconsole.log(a); // undefined\n\n// 可以理解为\nvar age\nif(!('a' in window)) {\n  a = 1;\n}\nconsole.log(a); // undefined\n\n```\n\n---\n\n## 暂时性死区\n\n与 `var` 的不同的是 `let/const` 声明的变量不会在作用域中被提升。所以在声明前访问会报错，这点和其他语言效果一样\n\n```js\nconsole.log(name) // undefined\nvar name = 'Matt'\n// age 不会被提升\nconsole.log(gender) // ReferenceError：gender 没有定义\nconsole.log(age) // ReferenceError：age 没有定义\nlet age = 26\n```\n","tags":["前端","面试"]},{"title":"简易 Koa 洋葱模型","url":"/202106/手写Koa-洋葱模型/","content":"\n# 手写 Koa 洋葱模型\n\n效果如下\n\n```JS\nconst app = new Koa()\napp.use(async (next) => {\n  console.log(1)\n  await next()\n  console.log(2)\n})\napp.use(async (next) => {\n  console.log(3)\n  await next()\n  console.log(4)\n})\napp.compose()\n// 打印1,3,2,4\n\n```\n\n```JS\nfunction compose(...funcs) {\n  return function (v) {\n    return funcs.reduce((p, cb) => {\n      return p.then(() => cb)\n    }, v)\n  }\n}\n\nclass Koa {\n  constructor() {\n    this.midwares = []\n  }\n  compose() {\n    const resolve = () => {}\n    const reject = () => {}\n    const dispatch = (i) => {\n      const fn = this.midwares[i]\n      if (!fn) return Promise.resolve()\n      return Promise.resolve(\n        fn(() => {\n          return dispatch(i + 1)\n        })\n      )\n    }\n    return dispatch(0)\n  }\n  use(cb) {\n    this.midwares.push(cb)\n  }\n}\n\n```\n","tags":["前端","面试"]},{"title":"手写一个事件中心","url":"/202105/手写一个事件中心/","content":"\n```JS\nclass EventEmitter {\n  constructor() {\n    this.events = Object.create(null)\n  }\n  emit(name, ...args) {\n    const cbs = this.events[name]\n    if (cbs) {\n      for (const cb of cbs) {\n        cb(...args)\n      }\n    }\n  }\n  on(name, fn) {\n    if (Array.isArray(name)) {\n      for (const n of name) {\n        this.on(n, fn)\n      }\n    } else {\n      ;(this.events[name] || (this.events[name] = [])).push(fn)\n    }\n  }\n  once(name, fn) {\n    const that = this\n    function on(...args) {\n      that.off(name, on)\n      fn(...args)\n    }\n    on.fn = fn\n    this.on(name, on)\n  }\n  off(name, fn) {\n    if (name === void 0) {\n      this.events = Object.create(null)\n    }\n    if (Array.isArray(name)) {\n      for (const n of name) {\n        this.off(n, fn)\n      }\n      return\n    }\n    const cbs = this.events[name] || []\n    if (!fn) {\n      this.events[name] = null\n      return\n    }\n    for (const i in cbs) {\n      const cb = cbs[i]\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1)\n        return\n      }\n    }\n  }\n}\n```\n","tags":["前端","面试"]},{"title":"如何让对象支持 for of 遍历","url":"/202105/如何让for-of-在对象中遍历/","content":"\n`for of` 是 ES6 出的一个遍历数组元素的方法，和`for in` 的区别在对于前面遍历数组的值；后者遍历数组(对象)的键（包括从父级继承的键），遍历对象是且会按照添加的顺序遍历。\n\n```JS\nObject.prototype.name = 'Lili'\n\nconst o = {\n  __proto__: {\n    e: 12,\n  },\n  b: 12,\n  c: 10,\n  a: 8,\n}\nfor (const i in o) {\n  console.log(i)\n  // b c a e name\n}\nconst arr = [1, 2, 3]\nfor (const i in arr) {\n  console.log(i)\n  // 0 1 2 3 name\n}\n```\n\n当我们尝试用 `for of` 遍历一个对象时，会报错 `TypeError: o is not iterable`，这里因为 `for of` 其实会调用对象的 `Symbol.iterator` 方法,这个属性是一个迭代器\n所以我们可以尝试实现一个对象的 `Symbol.iterator` 迭代器\n\n```JS\nObject.prototype.name = 'Lili'\nconst o = {\n  __proto__: {\n    e: 12,\n  },\n  b: 12,\n  c: 10,\n  a: 8,\n}\nObject.prototype[Symbol.iterator] = function () {\n  const keys = Object.keys(this)\n  let i = -1\n  return {\n    next: () => {\n      return {\n        value: this[keys[++i]],\n        done: i >= keys.length,\n      }\n    },\n  }\n}\nfor (const i of o) {\n  console.log(i)\n  // 12 10 8\n}\n```\n\n并且也只会遍历该对象上自己拥有的属性。\n"},{"title":"call 和 apply 性能对比","url":"/202104/call-和-apply-性能对比/","content":"\n## 总结\n\n`call` 确实比 `aplly` 快一个数量级\n\n## 起因\n\n`lodash` 对 `apply`的封装源码。\n\n```JS\n /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n  function apply(func, thisArg, args) {\n    switch (args.length) {\n      case 0: return func.call(thisArg);\n      case 1: return func.call(thisArg, args[0]);\n      case 2: return func.call(thisArg, args[0], args[1]);\n      case 3: return func.call(thisArg, args[0], args[1], args[2]);\n    }\n    return func.apply(thisArg, args);\n  }\n```\n\n今天在回看 `lodash` 源码中的 `apply` 方法时产生一个疑惑，`call` 是不是比 `apply` 快一些，可以看到，对于参数个数小于等于 `3` 个时内部其实就是调用的原来的 `call` 方法。\n\n## 验证\n\n这里通过进行一百次的百万次调用取平均值\n\n```JS\nconst foo = {\n  count: 1,\n}\nfunction func(name, a, b, c, d) {\n  return name + this.count\n}\n\nfunction call(args) {\n  const t = Date.now()\n  for (let i = 0; i < 1000000; i++) {\n    switch (args.length) {\n      case 0:\n        func.call(foo)\n        break\n      case 1:\n        func.call(foo, args[0])\n        break\n      case 2:\n        func.call(foo, args[0], args[1])\n        break\n      case 3:\n        func.call(foo, args[0], args[1], args[2])\n        break\n\n      case 4:\n        func.call(foo, args[0], args[1], args[2], args[3])\n        break\n      case 5:\n        func.call(foo, args[0], args[1], args[2], args[3], args[4])\n        break\n    }\n  }\n  const r = Date.now() - t\n  // console.log(`${args.length}个参数 call 耗时${r}ms`)\n  return r\n}\nfunction apply(args) {\n  const t = Date.now()\n  for (let i = 0; i < 1000000; i++) {\n    switch (args.length) {\n      case 0:\n        func.apply(foo)\n        break\n      case 1:\n        func.apply(foo, args)\n        break\n      case 2:\n        func.apply(foo, args)\n        break\n      case 3:\n        func.apply(foo, args)\n        break\n      case 4:\n        func.apply(foo, args)\n        break\n      case 5:\n        func.apply(foo, args)\n        break\n    }\n  }\n  const r = Date.now() - t\n  // console.log(`${args.length}个参数 apply 耗时${r}ms`)\n  return r\n}\nconst arr1 = [0, 0, 0, 0, 0, 0]\nconst arr2 = [0, 0, 0, 0, 0, 0]\nfor (let i = 0; i < 100; i++) {\n  arr1[0] += call([1])\n  arr1[1] += call([1, 2])\n  arr1[2] += call([1, 2, 3])\n  arr1[3] += call([1, 2, 3, 4])\n  arr1[4] += call([1, 2, 3, 4, 5])\n\n  arr2[0] += apply([1])\n  arr2[1] += apply([1, 2])\n  arr2[2] += apply([1, 2, 3])\n  arr2[3] += apply([1, 2, 3, 4])\n  arr2[4] += apply([1, 2, 3, 4, 5])\n}\narr1[0] /= 100\narr1[1] /= 100\narr1[2] /= 100\narr1[3] /= 100\narr1[4] /= 100\n\narr2[0] /= 100\narr2[1] /= 100\narr2[2] /= 100\narr2[3] /= 100\narr2[4] /= 100\n\nfor (let i = 0; i < 5; i++) {\n  console.log(`${i + 1}个参数调用call 循环一百万 * 100 次平均消耗${arr1[i]}ms`)\n  console.log(`${i + 1}个参数调用apply 循环一百万 * 100 次平均消耗${arr2[i]}ms`)\n}\n\n```\n\n## 结果\n\n### 浏览器\n\n![image-20210425233316409](https://gitee.com/daixiongsheng/pictures/raw/master/2021/04/25/23-33-17-8iJcQp8iJcQp.png)\n\n### Node V14\n\n![image-20210425233410036](https://gitee.com/daixiongsheng/pictures/raw/master/2021/04/25/23-34-10-DD85l6DD85l6.png)\n\n## 结论\n\n`call` 确实比 `aplly` 快一个数量级\n","tags":["前端"]},{"title":"webpack优化踩坑记","url":"/202104/webpack优化踩坑记/","content":"\n## 项目背景\n\n- vue 2.6\n- vue-class-component 7.2\n- vuex 3.4\n- vuex-class 3.4\n- vue-router 3.2\n- element-ui 2.14\n- vue-property-decorator 8.4\n- vue-cli 4\n- webpack 4\n\n> 今天抽空做一下 webpack 的打包优化，然后网上看看各种方式，一种是多进程打包 `HappyPack` ，项目使用 `TypeScript` 尝试了下，由于 `vue-cli` 配置有限，尝试几次失败后，选择简单的**动态库**的形式。\n\n---\n\n### 按照教程慢慢来\n\n#### 先写个 `dll` 的配置\n\n`webpack.dll.config.js`\n\n```js\n// 标准的配置，没有什么异常\n/* eslint-disable */\nconst path = require('path')\nconst { execSync } = require('child_process')\nconst webpack = require('webpack')\n\nconst dllPath = path.join(__dirname, 'dll')\n\nexecSync(`rm -rf ${dllPath}`)\n\nmodule.exports = {\n  mode: 'production',\n  entry: {\n    // vue全家桶加上\n    vue: [\n      'vue',\n      'vue-property-decorator',\n      'vue-class-component',\n      'vue-router',\n      'vuex',\n      'vuex-class',\n    ],\n    axios: ['axios'],\n    // element 加上\n    element: ['element-ui'],\n  },\n  output: {\n    // 打包后文件输出的位置\n    path: path.join(__dirname, 'dll'),\n    filename: '[name].dll.js',\n    // 打包出的是一个库，暴漏到全局,名叫vendors\n    library: '[name]',\n  },\n  plugins: [\n    new webpack.DllPlugin({\n      name: '[name]',\n      path: path.resolve(__dirname, 'dll/[name].manifest.json'),\n    }),\n  ],\n}\n```\n\n#### 然后 添加 `npm scripts`： \"dll\": \"webpack --config ./webpack.dll.config.js\"`\n\n#### 再修改 `vue.config.js`\n\n**这里需要安装一些依赖**\n\n`npm i -d webpack-cli add-asset-html-webpack-plugin `\n\n随带添加了个 代码包分析插件 `webpack-bundle-analyzer`, 打包速度分析插件 `speed-measure-webpack-plugin`\n\n```JS\n// vue.config.js 部分内容\nconst TerserPlugin = require(\"terser-webpack-plugin\");\nconst webpack = require('webpack');\nconst SpeedMeasurePlugin = require(\"speed-measure-webpack-plugin\");\nconst AddAssetHtmlWebpackPlugin = require('add-asset-html-webpack-plugin');\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\nconst smp = new SpeedMeasurePlugin();\nconst workers = os.cpus().length;\n\nfunction getPlugins() {\n  if (__DEV__) {\n    return [];\n  }\n  const plugins = [\n    // 代码包分析插件\n    new BundleAnalyzerPlugin()\n  ];\n  const files = fs.readdirSync(path.resolve(__dirname, 'dll'));\n  files.forEach(file => {\n    if (/.*.dll.js/.test(file)) {\n      plugins.push(new AddAssetHtmlWebpackPlugin({\n        filepath: path.resolve(__dirname, 'dll', file), // 将打包后的dll文件注入html中\n        outputPath: 'static/dll',\n        publicPath: publicPath + 'static/dll',\n      }));\n    }\n    else if (/.*.manifest.json/.test(file)) {\n      plugins.push(new webpack.DllReferencePlugin({\n        manifest: path.resolve(__dirname, 'dll', file),\n      })); // 分析json文件，里面有的模块就不会引用node_modules里的文件，因为dll.js中已存在\n    }\n  });\n  return plugins;\n}\n\nmodule.exports = {\n  // ...\n  configureWebpack: config => {\n    config.devtool = \"module-source-map\";\n    return smp.wrap({\n      mode: __DEV__ ? 'development' : 'production',\n      // 保持类名不被压缩\n      optimization: {\n        usedExports: true,\n        concatenateModules: false,\n        minimizer: [\n          new TerserPlugin({\n            parallel: workers,\n            terserOptions: {\n              ecma: undefined,\n              warnings: false,\n              keep_fnames: true,\n              parse: {},\n              compress: {\n                drop_console: process.env.VUE_APP_MODE === 'production',\n                drop_debugger: process.env.VUE_APP_MODE === 'production',\n                pure_funcs: ['console.log'], // 移除console\n              },\n            },\n            sourceMap: true,\n          })\n        ]\n      },\n      // 添加插件\n      plugins: getPlugins()\n    });\n  },\n  // ...\n}\n```\n\n**然后打包发布**\n\n![image-20210422214626693](https://gitee.com/daixiongsheng/pictures/raw/master/uPic/2021/04/22/21-46/image-20210422214626693.png)\n\n#### **pa** 哦豁，报错了，然后看到是在 `vue.**.dll.js` 报的错。\n\n---\n\n#### 改下配置，将 vue 全家桶拆分\n\n```JS\nentry: {\n // vue全家桶加上\n vue: ['vue', 'vue-router', 'vuex'],\n vuePropertyDecorator: ['vue-property-decorator'],\n vueClassComponent: ['vue-class-component'],\n vueClass: ['vuex-class'],\n axios: ['axios'],\n // element 加上\n element: ['element-ui'],\n}\n```\n\n![image-20210422221210130](https://gitee.com/daixiongsheng/pictures/raw/master/uPic/2021/04/22/22-12/image-20210422221210130.png)\n\n还是有问题，不过这次定位到了在 `vue-property-decorator` 里面，\n\n#### 修改配置，去掉 vue-property-decorator\n\n```JS\n// 修改配置，去掉vue-property-decorator\nentry: {\n  // vue全家桶加上\n  vue: ['vue', 'vue-router', 'vuex'],\n  vueClassComponent: ['vue-class-component'],\n  vueClass: ['vuex-class'],\n  axios: ['axios'],\n  // element 加上\n  element: ['element-ui'],\n}\n```\n\n![image-20210422221914099](https://gitee.com/daixiongsheng/pictures/raw/master/uPic/2021/04/22/22-19/image-20210422221914099.png)\n\n#### shit 再去掉 vue-class-component\n\n```JS\n// 修改配置，再去掉vue-class-component\nentry: {\n  // vue全家桶加上\n  vue: ['vue', 'vue-router', 'vuex'],\n  vueClass: ['vuex-class'],\n  axios: ['axios'],\n  // element 加上\n  element: ['element-ui'],\n}\n```\n\n![image-20210422222154612](https://gitee.com/daixiongsheng/pictures/raw/master/uPic/2021/04/22/22-21/image-20210422222154612.png)\n\n#### fuck 再去\n\n```js\n// 修改配置，再去掉vue-class-component\nentry: {\n  // vue全家桶加上\n  vue: ['vue', 'vue-router', 'vuex'],\n  axios: ['axios'],\n  // element 加上\n  element: ['element-ui'],\n}\n```\n\n#### nice 一切（看越来）正常\n\n<img src=\"https://gitee.com/daixiongsheng/pictures/raw/master/uPic/2021/04/22/22-27/image-20210422222659890.png\" alt=\"image-20210422222659890\" style=\"zoom: 33%;\" />\n\n#### OMG， vue 怎么还在\n\n`vue` 明明是已经抽取 `dll` 了，为什么打包的时候还有。。。\n\n## 等我排查排查\n\n此处省略 1W+字 😩😩😩\n\n## 最后的配置\n\n```JS\nentry: {\n  // element-ui 依赖 vue/dist/vue.runtime.esm\n  vue: ['vue/dist/vue.esm', 'vue-router', 'vuex/dist/vuex.esm'],\n  axios: ['axios'],\n  element: ['element-ui'],\n}\n```\n\n<img src=\"https://gitee.com/daixiongsheng/pictures/raw/master/uPic/2021/04/22/22-52/image-20210422225221286.png\" alt=\"image-20210422225221286\" style=\"zoom:33%;\" />\n\n**perfect**\n\n---\n\n## 你以为这就结束了？no no no\n\n看一下打包的 `dll`\n\n`element.dll.js`\n\n![image-20210422230903664](https://gitee.com/daixiongsheng/pictures/raw/master/uPic/2021/04/22/23-09/image-20210422230903664.png)\n\n瞎搞，你`element`怎么打`vue`也打包了\n\n再看看`vue.dll.jd`\n\n![image-20210422231054380](https://gitee.com/daixiongsheng/pictures/raw/master/uPic/2021/04/22/23-10/image-20210422231054380.png)\n\n正常的，我自己打包自己没毛病吧\n\n```js\n继续修改配置，\nvue: ['vue/dist/vue.esm', 'vue-router', 'vuex/dist/vuex.esm', 'element-ui'],\n```\n\n把`element-ui` 和`vue`一起打包，但是还是会打包多个，这里就不贴图了\n\n继续翻翻翻翻\n全局搜索的时候发现了这个\n\n![image-20210422235525740](https://gitee.com/daixiongsheng/pictures/raw/master/uPic/2021/04/22/23-55/image-20210422235525740.png)\n\n然后再看看 `vue.config.js`\n\n```JS\nruntimeCompiler: true\n```\n\n原来在这，改成`false` 就行了\n\n## OK 一切正常，这次是真 OK 了\n\n附上最后的配置\n\n```JS\n// 切记vue.config.js 配置\nruntimeCompiler: true\n\n// entry 配置\nentry: {\n  vendors: [\n    'vue',\n    'vue-property-decorator',\n    'vue-class-component',\n    'vue-router',\n    'vuex',\n    'vuex-class',\n    'element-ui',\n    'vuedraggable',\n    'dayjs',\n    'core-js',\n    'axios'\n  ],\n}\n```\n\n## 总结\n\n一切的一切全来源于`runtimeCompiler: true`\n\n## 成果\n\n这是优化前的编译时间\n\n![12](https://gitee.com/daixiongsheng/pictures/raw/master/uPic/2021/04/23/01-04/12.png)\n\n这是优化后的编译时间\n\n![10-29-57-sNGSP2sNGSP2](https://gitee.com/daixiongsheng/pictures/raw/master/2021/04/23/10-29-57-sNGSP2sNGSP2.png)\n\n卧槽卧槽卧槽。。提速 95%...\n","tags":["webpack","性能优化"]},{"title":"ES6-ES12","url":"/202104/es6-es12/","content":"\n## ES6/ES2015\n\n**1.class**\n\n```js\nclass Person {\n  constructor() {}\n}\n\nnew Person()\n// Person() 报错\n```\n\n**2.模块化**\n\n```JS\nexport const isProd = 'production' === process.env.NODE_ENV\nexport {\n\tisProd\n}\nexport default {\n  isProd\n}\nexport * from './demo'\nexport * as U from './demo'\nexport {isPord as Prod} from './demo'\n\nimport {isProd} from './demo'\nimport {isProd as Prod} from './demo'\nimport * as U from './demo'\n\n```\n\n**3.箭头函数**\n\n```JS\n// 类似其他语言的Lambda表达式\nconst add = (a, b) => a + b\nconst add2 = v => add(2, v)\n\nconst fun = () => {\n  // 不能使用arguments\n  // console.log(arguments)\n\n  // this 为上一级的this\n  console.log(this)\n}\n\n// new fun() 不能new\n\n\n```\n\n**4.函数参数默认值**\n\n```js\nfunction add(a = 2, b = 4) {\n  return a + b\n}\n\nfunction add(a = 2, b) {\n  return a + b\n}\n// 6\nadd(void 0, 4)\n```\n\n**5.模板字符串**\n\n```JS\nconst word = '你好'\n// hello 你好\nconst str = `hello ${word}`\n```\n\n**6.解构赋值**\n\n```JS\nconst p = {age: 12}\n// 12\nconst {age} = p;\n```\n\n**7.延展操作符**\n\n```JS\nfunction sum(...nums) {\n  return nums.reduce((a, b) => a + b)\n}\n```\n\n**8.对象属性简写**\n\n```JS\nconst id = 1\nconst age = 18\nconst name = 'Yiyi'\nconst p = {\n  id, age, name\n}\n```\n\n**9.Promise**\n\n```JS\nnew Promise(resolve => {\n  resolve(18)\n})\n```\n\n**10.let const**\n\n```js\nlet i = 0\ni++\nconst j = 0\n// 报错\nj++\n```\n\n**11.for of**\n\n```JS\nconst arr = ['a', 'b', 'c']\nfor(const f of arr) {\n  // a b c\n  console.log(f)\n}\n```\n\n**12.Generator**\n\n```JS\nfunction* gen() {\n  yield 1\n  yield 2\n  return 3\n}\nconst g = gen()\ng.next() // {value: 1, done: false}\ng.next() // {value: 2, done: false}\ng.next() // {value: 3, done: true}\n```\n\n**13.Symbol**\n\n**14.Map/Set**\n\n**15.WeakMap/WeakSet**\n\n**16.Symbol.iterator** 可迭代对象\n\n**17.Proxy/Reflect**\n\n...\n\n---\n\n## ES7/ES2016\n\n**1.Array.prototype.includes()**\n\n```JS\n[1, 2].includes(1) // true\n```\n\n**2.指数操作符**\n\n```JS\nconst a = 2**3 // 8\n```\n\n---\n\n## ES8/ES2017\n\n**1.Object.values()**\n\n```JS\nconst p = {\n  id: 1,\n  age: 18,\n  name: 'Yiyi',\n}\n\n// [ 1, 18, 'Yiyi' ]\nObject.values(p)\n```\n\n**2.Object.entries()**\n\n```JS\nconst p = {\n  id: 1,\n  age: 18,\n  name: 'Yiyi',\n}\n\n// [ [ 'id', 1 ], [ 'age', 18 ], [ 'name', 'Yiyi' ] ]\nObject.values(p)\n```\n\n**3.padStart**\n\n```JS\n'hello'.padStart(10, '2')\n// '22222hello'\n'hello'.padStart(10)\n// '     hello'\n```\n\n**3.padEnd**\n\n```JS\n'hello'.padEnd(10, 2)\n// 'hello22222'\n\n'hello'.padEnd(10)\n// 'hello     '\n```\n\n**4.尾后逗号**\n\n```JS\nfunction fun(var1, var2, var3, ) {\n  return arguments.length\n}\nfun(10, 20, 30)\n// 3\n```\n\n**5. async/await**\n\n```JS\nconsole.log(1)\nasync function fetch() {\n  console.log(2)\n  await void 0\n  console.log(4)\n}\nfetch()\nconsole.log(3)\n\n// 打印 1 2 3 4\n```\n\n**6.SharedArrayBuffer**\n\n平时没怎么用过...\n\n**7.Atomics**\n\n平时没怎么用过...\n\n**9.Object.getOwnPropertyDescriptors**\n\n```JS\nconst p = {\n  age: 18,\n  name: 'Yiyi',\n}\nObject.getOwnPropertyDescriptors(p)\n\n`\n{\n  age: { value: 18, writable: true, enumerable: true, configurable: true },\n  name: {\n    value: 'Yiyi',\n    writable: true,\n    enumerable: true,\n    configurable: true\n  }\n}\n`\n```\n\n---\n\n## ES9/ES2018\n\n**1. Promise.finally**\n\n```JS\nPromise.resolve(1)\n  .then((r) => console.log(r))\n  .finally(() => {\n    console.log('finally')\n  })\n\n// 1 'finally'\n```\n\n**2.异步迭代**\n\n```JS\nconst arr = new Array(3).fill(0).map((_, i) => Promise.resolve(i))\nconsole.log(1)\n;(async () => {\n  for await (const a of arr) {\n    console.log(a)\n  }\n})()\nconsole.log(2)\n\n// 1 2 0 1 2\n```\n\n**3.Rest/Spread 属性**\n\n```js\n// rest\nconst { x, y, ...othors } = { x: 1, y: 2, a: 3, b: 4 }\nx // 1\ny // 2\nothors // { a: 3, b: 4 }\n\n// spread\nconst n = { x, y, ...othors }\nn // { x: 1, y: 2, a: 3, b: 4 }\n```\n\n**4.正则表达式命名捕获组**\n\n```JS\nconst str = 'age=18,name=Lili,salary=3000'\n\nconst match = /age=(?<age>\\d+),name=(?<name>\\w+),salary=(?<salary>\\d+)/.exec(\n  str\n)\nconst { groups } = match\n// '18' 'Lili' '3000'\nconsole.log(groups.age, groups.name, groups.salary)\n\n```\n\n**5.正则表达式反向断言**\n\n```JS\n// 正向断言\n//\nconst str = 'createdwas_was_wascreated'\n/was(?=created)/.exec(str) // 匹配最后一个was\n\n/was(?!created)/.exec(str) // 最后一个was不匹配，只匹配前面两个was\n\n// 反向断言\n\n/(?<=created)was/.exec(str) // 只匹配最前面一个was\n\n/(?<!created)was/.exec(str) // 最前面一个was不匹配，只匹配后面的两个was\n```\n\n**6.正则 s 标记，dotAll 模式**\n\n`.`无法匹配`\\r \\n \\u{2048} \\u{2049}`等换行符。 在 ES2018 中为正则表达式增加了一个新的标志`s` 用来表示属性 dotAll。以使 `.`可以匹配任意字符, 包括换行符。\n\n**7.正则 Unicode 属性转义符**\n\n...\n\n---\n\n## ES10/ES2019\n\n**1.Array.flat()和 Array.flatMap()**\n\n`flat` 扁平化数组\n\n`flatMap` 相当于先执行 `map` 再执行 `flat`\n\n**2.trimStart()和 String.trimEnd()**\n\n清楚字符串前面/后面的空格\n\n**3.matchAll**\n\n**4.Symbol.prototype.description**\n\n**5. Object.fromEntries**\n\n```JS\nconst map = new Map([\n  ['age', 18],\n  ['name', 'Lili'],\n])\nconst obj = Object.fromEntries(map)\nconsole.log(obj) // { age: 18, name: 'Lili' }\n\n```\n\n**6.Function.prototype.toString**\n\n**7.可选 Catch**\n\n```JS\ntry {} catch {}\n```\n\n---\n\n## ES11/ES2020\n\n**1.Nullish coalescing Operator(空值处理)**\n\n```JS\nconst user = {\n  u1: 0,\n  u2: false,\n  u3: null,\n  u4: void 0,\n  u5: '',\n}\nconst u2 = user.u2 ?? '用户2' // false\nconst u3 = user.u3 ?? '用户3' // 用户3\nconst u4 = user.u4 ?? '用户4' // 用户4\nconst u5 = user.u5 ?? '用户5' // ''\n\n```\n\n**2.Optional chaining（可选链）**\n\n```JS\nconst user = {}\nconst u2 = user.childer?.name // undefined\n```\n\n**3. Promise.allSettled**\n\n该**`Promise.allSettled()`**方法返回一个 promise，该 promise 在所有给定的 promise 都已实现或被拒绝后解析，并带有一个对象数组，每个对象描述每个 promise 的结果。\n\n**`Promise.all()`** 如果任务相互依赖/如果您希望在其中任何一个拒绝时立即拒绝，则返回的 Promise 可能会更合适。\n\n**4.import()**\n\n动态 import\n\n**5.私有变量**\n\n```JS\nclass Message {\n #message = \"Hello\"\n greet() { console.log(this.#message) }\n}\n\nconst greeting = new Message()\n\ngreeting.greet() // Howdy\nconsole.log(greeting.#message) // Private name #message is not defined\n```\n\n**6.BigInt**\n\n---\n\n## ES12/ES2021\n\n**1. replaceAll**\n\n**2.Promise.any**\n\n**3.WeakRef**\n\n**4.逻辑运算符与赋值表达式**\n\n```JS\na ||= b\n// 等价于\n// a || (a = b)\n```\n\n**5.数值分隔符**\n\n```JS\n123_456\n```\n","tags":["前端"]},{"title":"new.target是个啥","url":"/202104/new-target是个啥/","content":"\n## 总结\n\n`new.target` 可以用来判断是不是通过 `new` 调用的该方法\n\n今天在看 `Node.JS` 源码的时候，发现一个没见过的写法 `new.target`\n\n```js\nfunction Console(options /* or: stdout, stderr, ignoreErrors = true */) {\n  // We have to test new.target here to see if this function is called\n  // with new, because we need to define a custom instanceof to accommodate\n  // the global console.\n  if (!new.target) {\n    return ReflectConstruct(Console, arguments)\n  }\n  // ...\n}\n```\n\n当通过 `new` 关键词调用一个方法的时候 `new.target` 指向当前这个方法，可以用来判断是不是通过 `new` 操作调用的。\n\n![image-20210415174011971](https://gitee.com/daixiongsheng/pictures/raw/master/uPic/2021/04/15/17-40/image-20210415174011971.png)\n\n以前通过 `this instanceof F` 来判断，但是 `instanceof` 是可以通过外力改变他的表现形式的。\n\n![image-20210415174043023](https://gitee.com/daixiongsheng/pictures/raw/master/uPic/2021/04/15/17-40/image-20210415174043023.png)\n","tags":["前端"]},{"title":"浏览器缓存","url":"/202104/浏览器缓存/","content":"\n# 浏览器缓存的分类\n\n## 强缓存\n\n不会向服务器发送请求，直接从缓存中读取资源，强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。\n\n### cache-control\n\n`max-age` 是 `HTTP/1.0` 中,标识一个请求的存活时间。采用相对时间，相应对文件的请求时间\n\n`max-age:60000 ` 表示改请求的最大存活时间为 60s, 在这 60s 进行再次请求就会走浏览器的缓存，而不会发起网络请求，60 后，再请求就会发起网络请求。\n\n### Expires\n\n`expires`一个绝对时间的 `UTCString` 串，和`cookie`中的 `expires` 类似，当`cache-control`和 `expires` 都存在 `HTTP Header` 时，`cache-control`的优先级更高。\n\n## 协商缓存\n\n当**强缓存失效**后，浏览器携带缓存标识向服务器发起请求，由**服务器**根据缓存标识**决定**是否使用缓存的过程。\n\n协商缓存可以通过设置两种 `HTTP Header` ，（http1.0）`Last-Modified / If-Modified-Since` 或者(http1.1) `Etag / If-None-Match`实现。\n\n`Etag / If-None-Match` 优先级又比 `Last-Modified / If-Modified-Since` 高。\n\n`Last-Modified` 指的是该**资源文件最后一次更改**时间，会在响应中返回，浏览器在下一次发送请求时，会放到**请求头**里的 `If-Modified-Since` 里，服务器在接收到后也会做比对，如果相同则命中协商缓存，返回 `304` 。\n\n`Etag` 是服务器响应请求时，返回当前**资源文件的一个唯一标识**，只要资源有变化，`Etag` 就会重新生成。浏览器在下次请求时，会将上一次返回的 `Etag` 值放到请求头里的 `If-None-Match` 里，服务器比较客户端传来的 `If-None-Match` 跟自己服务器上该资源的 `ETag` 是否一致，如果一致就返回 `304`。\n\n**整个流程如下**\n\n![浏览器缓存](https://gitee.com/daixiongsheng/pictures/raw/master/uPic/2021/04/13/13-45/浏览器缓存.png)\n","tags":["前端","面试"]},{"title":"Vue的$nextTick","url":"/202104/Vue$nextTick/","content":"\n## 先说结论\n\n`$nextTick` 会尽最大可能较快的在下一次异步任务中执行。\n\n## 源码追溯\n\n`Vue` 的 `$nextTick` 和定义在源码目录的`src/core/util/next-tick.js` 里面\n\n```JS\n// src/core/instance/index.js\n// line: 21\nrenderMixin(Vue)\n\n// renderMixin定义在\n// src/core/instance/render.js 里面\n\nexport function renderMixin (Vue: Class<Component>) {\n  ...\n  Vue.prototype.$nextTick = function (fn: Function) {\n    return nextTick(fn, this)\n  }\n\t...\n}\n\n```\n\n```js\nexport function nextTick(cb?: Function, ctx?: Object) {\n  let _resolve\n  callbacks.push(() => {\n    if (cb) {\n      try {\n        cb.call(ctx)\n      } catch (e) {\n        handleError(e, ctx, 'nextTick')\n      }\n    } else if (_resolve) {\n      _resolve(ctx)\n    }\n  })\n  if (!pending) {\n    pending = true\n    timerFunc()\n  }\n  // $flow-disable-line\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise((resolve) => {\n      _resolve = resolve\n    })\n  }\n}\n```\n\n`callbacks` 为定义的一个全局数组，用来存放下一次 tick 需要执行的方法，每次执行完成后 `callbacks` 会清空。\n\n当执行环境支持 `promise` 时 `$nextTick` 也支持 `promise` 化的调用方式。\n\n```js\nthis.$nextTick().then(() => {\n  // do something\n})\n```\n\n**关键的代码在这 4 行**\n\n```JS\nif (!pending) {\n  pending = true\n  timerFunc()\n}\n```\n\n主要功能实现依托于 `timerFunc` 这是一个根据不同平台有不同的实现。\n\n```JS\nfunction flushCallbacks () {\n  pending = false\n  const copies = callbacks.slice(0)\n  callbacks.length = 0\n  for (let i = 0; i < copies.length; i++) {\n    copies[i]()\n  }\n}\n\nlet timerFunc\n// 如果支持promise就用promise\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  const p = Promise.resolve()\n  timerFunc = () => {\n    p.then(flushCallbacks)\n    // In problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n    if (isIOS) setTimeout(noop)\n  }\n\n// 如果不支持promise看看支不支持 MutationObserver\n// 关于 MutationObserver, 可以参考https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver\n} else if (!isIE && typeof MutationObserver !== 'undefined' && (\n  isNative(MutationObserver) ||\n  // PhantomJS and iOS 7.x\n  MutationObserver.toString() === '[object MutationObserverConstructor]'\n)) {\n  // Use MutationObserver where native Promise is not available,\n  // e.g. PhantomJS, iOS7, Android 4.4\n  // (#6466 MutationObserver is unreliable in IE11)\n  let counter = 1\n  const observer = new MutationObserver(flushCallbacks)\n  const textNode = document.createTextNode(String(counter))\n  observer.observe(textNode, {\n    characterData: true\n  })\n  timerFunc = () => {\n    counter = (counter + 1) % 2\n    textNode.data = String(counter)\n  }\n\n// 如果也不支持MutationObserver看看支不支持setImmediate\n} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  // Fallback to setImmediate.\n  // Techinically it leverages the (macro) task queue,\n  // but it is still a better choice than setTimeout.\n  timerFunc = () => {\n    setImmediate(flushCallbacks)\n  }\n// 如果都不支持至少保证$nextTick为异步的\n} else {\n  // Fallback to setTimeout.\n  timerFunc = () => {\n    setTimeout(flushCallbacks, 0)\n  }\n}\n```\n\n`timerFunc` 会依次从 `Promise > MutationObserver > setImmediate > setTimeout` 这几个中选择一个平台支持的异步来实现。\n\n做这么多，其实就是想让 `$nextTick` 在下一个异步阶段尽可能的考前执行。\n\n## 总结\n\n`$nextTick` 会尽最大可能较快的在下一次异步任务中执行。\n","tags":["vue","vue源码"]},{"title":"Node.js控制台如何打印带颜色的字符","url":"/202104/NodeJs控制台如何打印带颜色的字符/","content":"\n```JS\nconst Color = {\n    None: '\\033[0m',\n    Black: '\\033[30m',\n    Red: '\\033[31m',\n    Green: '\\033[32m',\n    Yellow: '\\033[33m',\n    Blue: '\\033[34m',\n    Purple: '\\033[35m',\n    DarkGreen: '\\033[36m',\n    White: '\\033[37m',\n};\nconsole.log(Color.Red + 'hello',Color.Blue + 'world')\n\n```\n\n**效果如下**\n\n![tyEgnQ](https://gitee.com/daixiongsheng/pictures/raw/master/uPic/2021/04/01/17-35/tyEgnQ.png)\n","tags":["tools"]},{"title":"React源码之Component和PureComponent区别","url":"/react/React源码之Component和PureComponent区别/","content":"\n## 先说结论\n\n`PureComponent` 会比较前后 `props` 对象的第一层是否相等，如果不相等就会更新，面 `Compoent` 是只有要变化就会更新。\n\n## 源码追溯\n\n`React` 的 `Component` 和 `PureComponent` 定义在源码目录的`packages/react/src/ReactBaseClasses.js` 里面\n\n```JS\nfunction ComponentDummy() {}\nComponentDummy.prototype = Component.prototype;\n\n/**\n * Convenience component with default shallow equality check for sCU.\n */\nfunction PureComponent(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  // If a component has string refs, we will assign a different object later.\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nconst pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());\npureComponentPrototype.constructor = PureComponent;\n// Avoid an extra prototype jump for these methods.\nObject.assign(pureComponentPrototype, Component.prototype);\npureComponentPrototype.isPureReactComponent = true;\n```\n\n源码定义里面 `Component` 和 `PureComponent` 只有一个区别，就是 `PureComponent` 的原型上有一个 `isPureReactComponent` 为 `true` 的属性。\n\n通过全局查找，发现只有在 `packages/react-reconciler/src/ReactFiberClassComponent.js` 中有使用到\n\n> `react-reconciler` 这个目录是 `React` 内部进行调度的过程。\n\n```js\nfunction checkShouldComponentUpdate(\n  workInProgress,\n  ctor,\n  oldProps,\n  newProps,\n  oldState,\n  newState,\n  nextContext,\n) {\n  const instance = workInProgress.stateNode;\n  if (typeof instance.shouldComponentUpdate === 'function') {...\n  }\n\n  if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n    return (\n      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)\n    );\n  }\n\n  return true;\n}\n```\n\n再看看 `shallowEqual` 方法的内部， 定义在 `packages/shared/shallowEqual.js` 中。\n\n```JS\nfunction shallowEqual(objA: mixed, objB: mixed): boolean {\n  // is 在packages/shared/objectIs.js中，这里就直接贴过来了\n  // function is(x: any, y: any) {\n  //   return (\n  //     (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y) // eslint-disable-line no-self-compare\n  //   );\n  // }\n  // 这里其实就是Object.is的polyfill\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false;\n  }\n\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  for (let i = 0; i < keysA.length; i++) {\n    if (\n      !hasOwnProperty.call(objB, keysA[i]) ||\n      !is(objA[keysA[i]], objB[keysA[i]])\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n```\n\n`shallowEqual` 其实就是只对对象的第一导进行比较, `shallowEqual({count: 1}, {count: 1}) === true`\n\n## 总结\n\n`PureComponent` 会比较前后 `props` 对象的第一层是否相等，如果不相等就会更新，面 `Compoent` 是只有要变化就会更新。\n","tags":["前端","react","React源码"]},{"title":"手撸面试常问的几个底层算法","url":"/202103/手撸面试常问的几个底层算法/","content":"\n# 继承\n\n## 寄生组合式继承\n\n```JS\nfunction Parent() {\n    this.name = 'Liliya'\n}\nParent.prototype.getName = function () {\n    return this.name\n}\n\nfunction Child() {\n    Parent.call(this)\n}\n\nfunction extend(sup, sub) {\n    function F() {}\n    F.prototype = Parent.prototype\n    sub.prototype = new F()\n    sub.prototype.constructor = sub\n    return sub\n}\n\nconst Class = extend(Parent, Child)\n\nconst child = new Class()\nchild.getName()\n```\n\n# instanceof\n\n```JS\nfunction instanceOf(instance, Constructor) {\n    let proto = instance.__proto__\n    while (proto) {\n        if (proto === Constructor.prototype) {\n            return true\n        }\n        proto = proto.__proto__\n    }\n    return false\n}\n```\n\n# bind\n\n```JS\nFunction.prototype.bind = function (ctx, ...args1) {\n    const f = this\n    return function (...args2) {\n        return f.call(ctx, ...args1, ...args2)\n    }\n}\n```\n\n# call\n\n```JS\nFunction.prototype.call = function (ctx, ...args) {\n    return this.bind(ctx, ...args)()\n}\n```\n\n# apply\n\n```JS\nFunction.prototype.apply = function (ctx, args) {\n    return this.bind(ctx, ...args)()\n}\n```\n\n# map\n\n```JS\nArray.prototype.map = function (callback) {\n    const result = []\n    for (let i = 0, len = this.length; i < len; i++) {\n        result.push(callback(this[i], i, this))\n    }\n    return result\n}\n```\n\n# forEach\n\n```JS\nArray.prototype.forEach = function (callback) {\n    for (let i = 0, len = this.length; i < len; i++) {\n        callback(this[i], i, this)\n    }\n}\n```\n\n# reduce\n\n```JS\nArray.prototype.reduce = function (callback, defaultValue) {\n    const useDefault = defaultValue !== void 0\n    let result = useDefault ? defaultValue : this[0],\n        next,\n        len = this.length,\n        i = useDefault ? 0 : 1\n    for (; i < len; i++) {\n        next = this[i]\n        result = callback(result, next, i, this)\n    }\n    return result\n}\n```\n\n# Promise\n\n```JS\nclass Promise {\n  static PENDING = 'pending'\n  static FULFILLED = 'fulfilled'\n  static REJECTED = 'rejected'\n\n  constructor(executor) {\n    this.state = Promise.PENDING\n    this.value = void 0\n    this.resean = void 0\n    this.onFulfilledCallbak = []\n    this.onRejectedCallbak = []\n    const resolve = (value) => {\n      if (this.state === Promise.PENDING) {\n        this.state = Promise.FULFILLED\n        this.value = value\n        this.onFulfilledCallbak.forEach((fn) => fn())\n      }\n    }\n    const reject = (resean) => {\n      if (this.state === Promise.PENDING) {\n        this.state = Promise.REJECTED\n        this.resean = resean\n        this.onRejectedCallbak.forEach((fn) => fn())\n      }\n    }\n    try {\n      executor(resolve, reject)\n    } catch (e) {\n      reject(e)\n    }\n  }\n\n  static resolve(value) {\n    return new Promise((resolve) => {\n      resolve(value)\n    })\n  }\n\n  static reject(reason) {\n    return new Promise((_, reject) => {\n      reject(reason)\n    })\n  }\n\n  resolvePromise(p1, p2, resolve, reject) {\n    if (p1 === p2) {\n      reject(new TypeError('circular reference'))\n    }\n    let called = false\n    if (p2 !== null && (typeof p2 === 'function' || typeof p2 === 'object')) {\n      try {\n        const then = p2.then\n        if (typeof then === 'function') {\n          then.call(\n            p2,\n            (value) => {\n              if (called) return\n              called = true\n              this.resolvePromise(p1, value, resolve, reject)\n            },\n            (err) => {\n              if (called) return\n              called = true\n              reject(err)\n            }\n          )\n        } else {\n          if (called) return\n          called = true\n          resolve(p2)\n        }\n      } catch (e) {\n        if (called) return\n        called = true\n        reject(e)\n      }\n    } else {\n      if (called) return\n      called = true\n      resolve(p2)\n    }\n  }\n\n  then(onFulfilled, onRejected) {\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : (_) => _\n    onRejected =\n      typeof onRejected === 'function'\n        ? onRejected\n        : (_) => {\n            throw _\n          }\n    const promise = new Promise((resolve, reject) => {\n      if (this.state === Promise.FULFILLED) {\n        setTimeout(() => {\n          try {\n            this.resolvePromise(\n              promise,\n              onFulfilled(this.value),\n              resolve,\n              reject\n            )\n          } catch (e) {\n            reject(e)\n          }\n        })\n      } else if (this.state === Promise.REJECTED) {\n        setTimeout(() => {\n          this.resolvePromise(promise, onRejected(this.resean), resolve, reject)\n        })\n      } else {\n        this.onFulfilledCallbak.push(() => {\n          setTimeout(() => {\n            this.resolvePromise(\n              promise,\n              onFulfilled(this.value),\n              resolve,\n              reject\n            )\n          })\n        })\n        this.onRejectedCallbak.push(() => {\n          setTimeout(() => {\n            this.resolvePromise(\n              promise,\n              onRejected(this.resean),\n              resolve,\n              reject\n            )\n          })\n        })\n      }\n    })\n    return promise\n  }\n\n  catch(onRejected) {\n    return this.then(null, onRejected)\n  }\n  finally(onFinished) {\n    onFinished = typeof onFinished === 'function' ? onFinished : (_) => _\n    return this.then((val) => {\n      onFinished()\n      return val\n    }).catch((err) => {})\n  }\n}\n```\n","tags":["前端","面试"]},{"title":"TypeScript分享","url":"/202102/TypeScript分享/","content":"\n在分享之前我先回答一下为什么要使用 TypeScript（以下简称：TS）？前端的 TS 是什么？我们如何在项目中更好的使用 TS？\n\n---\n\n# 概念\n\n**TS 是什么？**\n\n首先 TS 是 JavaScript（以下简称：JS）的一个超集。我这里先回顾一下高中的**超集**概念：\n\n> 如果一个集合 S2 中的每一个元素都在集合 S1 中，且集合 S1 中可能包含 S2 中没有的元素，则集合 S1 就是 S2 的一个超集，反过来，S2 是 S1 的子集。 S1 是 S2 的超集，若 S1 中一定有 S2 中没有的元素，则 S1 是 S2 的真超集，反过来 S2 是 S1 的真子集。\n\n这里的意思就是 TS 包含了所有的 JS 特性，并且拥有一些 JS 里面没有的特性，能够**编译成 JavaScript** 代码。其中最大的特性就是在**JS**中**变量是没有类型的，只有值是有类型的**，**TS**中**变量也具有类型**，其核心能力是在代码编写过程中提供了类型支持，以及在编译过程中进行类型校验。\n\n**前端的 TS 是什么？**\n\n在前端业务中使用 TS 更多的在于对类型的规定，某些高级的 TS 特性（比如抽象类、命名空间）使用场景较少。即使是**泛型**这块使用的最多场景也就在前后端接口请求这块。\n\n**为什么要使用 TS？**\n\n可能有些人觉得写 TS 要写很多类型上面的代码，加大了前端的开发量，其实不然，在我看来动态语言的最大的弊端就是**调试困难**，因为动态语言的**变量是无类型**的，变量指向的内容就不确定，变量的引用只有在**运行时**才知道它具体指向哪里，才知道这个变量包含哪些内容。如果变量有类型，不用等到运行期间，在编码的时候就知道某个对象是不是我们期待的那个对象；其次，在后期迭代的时候回顾先前的代码也比较方便，当项目有新人到来的时候也更方便新人了解项目。前期的小投入可以换来后期大回报。最后 TS 的是 JS 的一个超集，对于前端工程师来说学习成本很低。\n\n**我们如何在项目中更好的使用 TS？**\n\n怎么叫用的好？其实很简单，当我们拿到一个变量时，我可以很清楚的知道这个变量是什么，它指向哪，如果他是高级类型，我们在``vs code`或者其他`IDE`的时候能智能提示他有什么属性或者方法。\n\n---\n\n## 在编译 `TS` 时，即使报错，默认也不会中断编译\n\n## 基本类型\n\n基本类型和 JS 类似，多了几个特有的`enum,unknown,void,never,tuple,any`\n\n- boolean\n\n- number\n\n- string\n\n- object\n\n- `number[] / Array<number>` 数组\n\n  - tuple 元组：已知元素**数量**和**类型**的数组，\n\n- enum\n\n  - 枚举，可以通过键名找到对应键值，也可以通过键值对到相应的键名。\n\n  - 枚举的值只能是 `number` 或者 `string` 类型\n\n  - ```typescript\n    // ts\n    enum Color {\n      // 默认起始值为0\n      // Red = 0,\n      Red,\n      // 也可以显示的指定对应的值，\n      Green = 100,\n      // 后面的值为前面的值+1 101\n      Yellow,\n      // 当指定为非number类型时，此时不能再通过值找到对应的键\n      White = 'White',\n      // 且后面的属性的值不会依次增加，如果不显示的指定值，编译会报错\n      Black,\n    }\n\n    // Color.Red === 0\n    // Color.Green === 100\n    // Color.Yellow === 101\n\n    // 编译后的结果\n    var Color\n    ;(function (Color) {\n      // 默认起始值为0\n      // Red = 0,\n      Color[(Color['Red'] = 0)] = 'Red'\n      // 也可以显示的指定对应的值，\n      Color[(Color['Green'] = 100)] = 'Green'\n      // 后面的值为前面的值+1 101\n      Color[(Color['Yellow'] = 101)] = 'Yellow'\n      // 当指定为非number类型时，此时不能再通过值找到对应的键\n      // 且后面的属性的值不会依次增加\n      Color['White'] = 'White'\n      Color[(Color['Black'] = void 0)] = 'Black'\n    })(Color || (Color = {}))\n    ```\n\n- void\n\n- undefined\n\n- null\n\n- never\n\n  - 永远不会返回。很少用到\n\n  - ```typescript\n    function func(): never {\n      while (true) {}\n    }\n    ```\n\n- unknown\n\n- any\n\n对于`any`和`unknown`，两者最大的区别是，`unknown`为任何类型的父类型，`any`既是任何类型的父类型，也是任何类型的子类型\n\n即任意类型可以转换为 `unknown` 。\n\n---\n\n## 鸭子类型\n\n> 在程序设计中，**鸭子类型**（英语：duck typing）是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由\"当前方法和属性的集合\"决定。\n\n> “当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。\n\nTypeScript 采用了所谓的 “鸭子类型”策略。当两个类型具有相同的属性以及方法时，它们就可以看作是同一类型。\n\n### 如何定义一个变量\n\n```C\n// c 语言\ntypedef struct _Point {\n    int x;\n    int y;\n} Point;\n\nint main() {\n    Point p;\n    p.x = 1;\n    p.y = 2;\n}\n```\n\n```c++\n// c++\nstruct Point {\n    int x;\n    int y;\n};\n\nstruct Person {\n    int age;\n};\n\nstruct Student : public Person {\n    Student() {\n        this->age = 18;\n    }\n    char name[20];\n};\n\nint main() {\n    Point p;\n    p.x = 1;\n    p.y = 2;\n    // 多态\n    Person *person = new Student();\n}\n```\n\n```java\n// java\nclass Point {\n    int x;\n    int y;\n}\n\ninterface Person {\n    String: name;\n}\n\nclass Student implements Person {\n    private String name;\n\n    Student() {\n        this.name = \"\"\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        // 多态\n        Point p = new Point();\n        p.x = 1;\n        p.y = 2;\n        Person person = new Student();\n    }\n}\n```\n\n```typescript\n// typescript\ninterface Point {\n  x: number\n  y: number\n}\n\ninterface XPoint {\n  x: number\n  y: number\n}\n\nfunction fn(p: Point) {\n  console.log(p.x, p.y)\n}\nconst p: XPoint = {\n  x: 100,\n  y: 100,\n}\n// p是XPoint 类型，但fn接收 Point 类型，由于TS的鸭子类型策略，所以会当他们为一种类型\nfn(p)\n```\n\n# 接口 interface\n\n用来声明类型和接口的\n\n`TS` 在前端的接口可能又拥有另外一重意思，在其他静态类型语言里面，接口是一种抽象类型，它用来制定一些规范，你要实现我的接口，就必须遵循我的规定。\n\n在其它静态语言中（比如 Java,C#)的接口的特性，TS 里面也有，但在前端（浏览器层）的 TS 里面，接口`interface` 更多的是用来表示某一个变量它具体有哪些内容。多态的这一特性很少有使用到。\n\n## `type` 和`interface`\n\n- type 类型别名\n  - 可以用来给已有的类型取一个别名\n  - 只能声明一次，多次声明同一种类型报错\n- interface 接口/类型定义\n  - 多次声明同一个接口会进行接口合并\n\n`type` 和`interface` 的区别在于，能用`interface`表示的地方，一定能用`type`表示\n\n```typescript\n// 定义类型\ninterface BaseUser {\n  // 一个只读的id属性，为number类型\n  readonly id: number\n}\n// 现次定义 会进行声明合并，此时的 BaseUser 包含两个属性，id 和name\ninterface BaseUser {\n  // 一个只读的id属性，为number类型\n  name: string\n}\n\n/* 可以理解为给\n      {\n        readonly id: number\n      }\n      这种类型，取个别名，叫BaseUser\n*/\n\ntype BaseUser = {\n  // 一个只读的id属性，为number类型\n  readonly id: number\n}\n```\n\n### 属性修饰\n\n- readonly 只读\n- ? 可为空\n\n```typescript\ninterface Point {\n  x: number\n  y?: number\n  // y: undefined | number\n}\n// y?: number;\n// y: undefined | number\n// 这两种语义不一样\n// 第一个表示，y属性可以有，可以没有\n// 第二个表示y一定有，他的值为 undefined 或者 number\n```\n\n**类型断言/强制类型转换**\n\n类型断言，这里我习惯称之为强制类型转换。\n\n- ```typescript\n  interface Point {\n    x: number\n    y: number\n  }\n  // 报错，因为ts认为{}是一个对象，他没有x,y这两属性，就不能赋值给p\n  const p: Point = {}\n  // 即使{}没x,y 这里通过断言的形式告诉编译器{}它的值就是一个Point类型的值\n  const p1: Point = {} as Point\n  const p2: Point = <Point>{}\n  ```\n\n**可以索引类型**\n\n```typescript\n// 索引类型\n// 类型限定\ninterface Person {\n  // 属性扩充,表示Person类型的属性只能是number 或者 string类型的,并且可以添加未在内部声明的字段\n  [propName: string]: number | string\n  age: number\n  name: string\n  address: string\n}\nconst p: Person = {\n  age: 18,\n  name: 'Pic',\n  address: '',\n  // 原定义中没有，但[propName: string]: number | string  表示可以进行属性动态添加，只要满足属性为number或者string\n  zipCode: '111',\n}\np.gender = 0\n```\n\n**函数类型**\n\n```typescript\n// 函数类型, 函数代有特定属性（cancel)\ninterface ScrollDebounceFunction {\n  (event: Event): void\n  cancel: () => void\n}\n\n// 函数类型, 函数接受一个Event,无返回值\ntype ScrollDebounceFunction = (event: Event) => void\n```\n\n**继承**\n\n```typescript\n// 定义类型\ninterface BaseUser {\n  // 一个只读的id属性，为number类型\n  readonly id: number\n}\n\n// 继承自BaseUser，会相应的继承对应的属性\ninterface User extends BaseUser {\n  // 这里存在一个继承自BaseUser的id属性并且是可读的\n  // readonly id: number\n\n  // 可以取消父属性的只读限制\n  // id: number\n\n  // 不能修改同名的父属性的类型\n  // id: string   // 报错\n\n  // 不能修改同名的父属性必选限制, 但可以将父属性的可选改成必选\n  // id?: number   // 报错\n\n  // username 为string类型或者undefined\n  username: string | undefined\n  // 表示address是可选的，它要么值为string类型的，要么不存在\n  address?: string\n}\n\n// 多继承\ninterface Base1 {\n  // id: number;\n  age: number\n}\ninterface Base2 {\n  id: string\n  address: string\n}\n\ninterface Person extends Base1, Base2 {\n  name: string\n}\n```\n\n在多继承时，会继承所有父级的属性，当多个父级有相同的属性，但属性的只读、可选限定不同时，会继承失败，报错。当父子都有相同的属性时，子属性与父属性的类型不同时，类型相同时，以子属性的只读限定为准。但当属性为必选限制，子属性就不能改成可选限定。\n\n---\n\n# 泛型\n\n我理解的泛型是为了增强类型的可复用性，在定义某一类型时，某个属性的具体类型不确定，但这个类型的基本结构可预估。\n\n### 内置基础泛型\n\n```typescript\ninterface Admin {\n  name: string\n  age: number\n  address: string\n  role: string\n}\n/**\n * 让该类型的所有属性为可选的\n */\ntype Partial<T> = {\n  [P in keyof T]?: T[P]\n}\ntype A = Partial<Admin>\n// 等同于\n// interface A {\n//     name?: string\n//     age?: number\n//     address?: string\n//     role?: string\n// }\n/**\n * 让该类型的所有属性为必选的\n */\ntype Required<T> = {\n  [P in keyof T]-?: T[P]\n}\ntype Readonly<T> = {\n  readonly [P in keyof T]: T[P]\n}\ntype Pick<T, K extends keyof T> = {\n  [P in K]: T[P]\n}\ntype Parameters<T extends (...args: any) => any> = T extends (\n  ...args: infer P\n) => any\n  ? P\n  : never\ntype ConstructorParameters<T extends new (...args: any) => any> =\n  T extends new (...args: infer P) => any ? P : never\ntype ReturnType<T extends (...args: any) => any> = T extends (\n  ...args: any\n) => infer R\n  ? R\n  : any\ntype InstanceType<T extends new (...args: any) => any> = T extends new (\n  ...args: any\n) => infer R\n  ? R\n  : any\ninterface ThisType<T> {}\n```\n\n**几个解释**\n\n上面的`T` 称之为 _类型变量_，它是一种特殊的变量，只用于表示类型而不是值。\n\n`extends` 当`extends`在形参列表里面时，表示的对传入的类型 T 的泛型约束。`T extends (...args: any) => any` 这里对 T 的限制就是`T`只能是函数类型，\n\n`infer` 代表推理。并且只能的 extends 一起用\n\n**这里详细说明一下 infer 的作用**\n\n```typescript\n// 这里可以先对这个表达式进行拆分\n// 我们先定义一个函数类型, 用来比较两个的数的大小，如果第一个参数大于第二个参数就返回true\ntype AMoreThanB = (a: number, b: number) => boolean\n// 我们再定义一个比较简单的ReturnType\ntype ReturnType<T extends AMoreThanB> = T extends AMoreThanB ? boolean : any\n// T extends AMoreThanB ? boolean : any;\n// 这个表达式肯定会返回一个类型，\n// 这里的? : 有点类似三元运算符，\n// 不防这样理解，当满足 T extends AMoreThanB时返回boolean，否则返回any\n\n// 再使用这个ReturnType, 因为对T的限定只能是AMoreThanB，我们就传入一个AMoreThanB，然后就得到了Rt\ntype Rt = ReturnType<AMoreThanB>\n// 这里肯定满足 T extends AMoreThanB，因为我们传入的T就是AMoreThanB，所以得到的Rt一定就是boolean,\n\n// 如果我们传入一个其他的类型\ntype Rt2 = ReturnType<boolean>\n// 这个时候就报错了，因为我们对T的限制他只能是AMoreThanB类型，或者这么说限制传入的这个函数必须要两个number类型的参数，并且返回一个boolean类型值\n// 现在我们放宽点\ntype ReturnType<T extends (...arg: any) => any> = T extends AMoreThanB\n  ? boolean\n  : any\n// 现在T可能是任何一个函数\n\n// 我们再定义一个新的函数类型\ntype TimeoutFuc = (callback: AMoreThanB, delay: number) => number\n\n// 这个时候我们再次使用这个ReturnType\ntype Rt3 = ReturnType<TimeoutFuc>\n// 由于TimeoutFuc 不满足  T extends AMoreThanB ，所有返回any,这里的Rt3就是any;\n\n// 还没讲到infer，不着急，\n// 我们再把ReturnType改进一下\ntype ReturnType<T extends (...arg: any) => any> = T extends (...arg: any) => any\n  ? boolean\n  : any\n// 这个时候不管传入什么样的函数返回都是boolean, 因为T extends (...arg: any) => any也一定满足。\n\n// 我们想返回一些动态的类型怎么办，或者我们想返回一些和T相关的类型\n// 这个时候 infer就出来了\ntype ReturnType<T extends (...arg: any) => any> = T extends (\n  ...arg: any\n) => infer R\n  ? R\n  : any\n// 这里我们将any 换成了infer R, 并当满足这个条件时把R返回\n\ntype Rt4 = ReturnType<TimeoutFuc>\n// 当我们再次使用时，这里的TimeoutFuc，满足 T extends (...arg: any) => infer R 。\n// 并且我们还拿到了TimeoutFuc这个函数的返回类型并赋给了R,然后返回R，所以，这里的Rt4就是TimeoutFuc这个函数的返回类型：num ber\n\ntype ReturnType<T extends (...arg: any) => any> = T extends (\n  arg1: infer T,\n  ...arg: any\n) => infer R\n  ? T | R\n  : any\n\n// 我们加大难度，这个时候的ReturnType返回的是传入函数类型的第一个参数类型和函数的返回类型的 并\n// 这里就等同于\ntype Rt5 = ReturnType<TimeoutFuc>\n// type Rt5 = number | AMoreThanB;\n\n// infer 的作用就是推断相应的类型.\n```\n\n---\n\n# 类\n\n继承，接口，多态就不讲了。\n\n讲一下类的装饰器，装饰器可以对原有的类，或者属性，方法，在**编译的时候**进行加强。\n\n**执行顺序** 属性装饰器、参数装饰器、方法装饰器、类装饰器\n\n类装饰器是作用于当前这个类，属性装饰器、方法装饰器、参数装饰器\n\n作用于这个类的 prototype\n\n**执行时机** 编译时\n\n## 属性装饰器\n\n```typescript\nfunction fieldDescriptor(target: any, fieldName: string): void {\n  console.log('fieldDescriptor', typeof prototype, prototype)\n}\n```\n\n## 参数装饰器\n\n```typescript\nfunction paramsDescriptor(\n  target: any,\n  propertyKey: string,\n  parameterIndex: number\n): any {\n  console.log('paramsDescriptor', propertyKey, parameterIndex)\n}\n```\n\n## 方法装饰器\n\n```typescript\nfunction methodDescriptor(prototype: Demo, methodName: string): void {\n  console.log('methodDescriptor', typeof prototype, prototype)\n}\n```\n\n## 类装饰器\n\n```typescript\nfunction classDescriptor(constructor: any): void {\n  console.log('classDescriptor', typeof constructor, constructor)\n}\n```\n\n```typescript\nfunction fieldDescriptor(target: any, fieldName: string): void {\n  console.log('fieldDescriptor', typeof target, target)\n}\nfunction paramsDescriptor(\n  target: any,\n  propertyKey: string,\n  parameterIndex: number\n): any {\n  console.log('paramsDescriptor', propertyKey, parameterIndex)\n}\n\nfunction methodDescriptor(prototype: Demo, methodName: string): void {\n  console.log('methodDescriptor', typeof prototype, prototype)\n}\n\nfunction classDescriptor(constructor: any): void {\n  console.log('classDescriptor', typeof constructor, constructor)\n}\n\n@classDescriptor\nclass Person {\n  @fieldDescriptor\n  name: string\n\n  @methodDescriptor\n  log(@paramsDescriptor p: string) {\n    console.log(this.name)\n  }\n}\n```\n\n## 编译后\n\n```javascript\nvar __decorate =\n  (this && this.__decorate) ||\n  function (decorators, target, key, desc) {\n    var c = arguments.length,\n      r =\n        c < 3\n          ? target\n          : desc === null\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\n          : desc,\n      d\n    if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function')\n      r = Reflect.decorate(decorators, target, key, desc)\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if ((d = decorators[i]))\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r\n    return c > 3 && r && Object.defineProperty(target, key, r), r\n  }\nvar __param =\n  (this && this.__param) ||\n  function (paramIndex, decorator) {\n    return function (target, key) {\n      decorator(target, key, paramIndex)\n    }\n  }\nfunction fieldDescriptor(target, fieldName) {\n  console.log('fieldDescriptor', typeof target, target)\n}\nfunction paramsDescriptor(target, propertyKey, parameterIndex) {\n  console.log('paramsDescriptor', propertyKey, parameterIndex)\n}\nfunction methodDescriptor(prototype, methodName) {\n  console.log('methodDescriptor', typeof prototype, prototype)\n}\nfunction classDescriptor(constructor) {\n  console.log('classDescriptor', typeof constructor, constructor)\n}\nvar Person = /** @class */ (function () {\n  function Person() {}\n  Person.prototype.log = function (p) {\n    console.log(this.name)\n  }\n  __decorate([fieldDescriptor], Person.prototype, 'name')\n  __decorate(\n    [methodDescriptor, __param(0, paramsDescriptor)],\n    Person.prototype,\n    'log'\n  )\n  Person = __decorate([classDescriptor], Person)\n  return Person\n})()\n```\n","tags":["前端"]},{"title":"2020年度总结","url":"/202012/2020年度总结/","content":"\n# 2020 总结\n\n- 满分 100 的话，总体来说给自己打个 79 分\n  - 顺利毕业\n  - 顺利工作（工作环境和周围的人不错），成功进入自己理想的行业\n  - 考研失利\n  - 读了几本书，预计的计划没看完\n  - 开始旅游了，去了山东山西，秦皇岛，哈尔滨。看了草原，看了海，滑了雪\n\n# 2021 flag\n\n- [ ] 多吃菜\n- [ ] 驾照\n- [x] 练字\n- [x] 每三个月一次源码阅读 1-3 月 react\n- [ ] 开灶\n- [ ] 编译原理\n","tags":["日志"]},{"title":"bash脚本","url":"/202012/bash脚本/","content":"\n- `foo=bar`\n\n  - `foo = bar` （使用括号隔开）是不能正确工作的，因为解释器会调用程序`foo` 并将 `=` 和 `bar`作为参数。\n\n- `$0` - 脚本名\n\n- `$1` 到 `$9` - 脚本到参数。 `$1` 是第一个参数，依此类推。\n\n- `$@` - 所有参数\n\n- `$#` - 参数个数\n\n- `$?` - 前一个命令到返回值\n\n- `$$` - 当前脚本到进程识别码\n\n- `!!` - 完整到上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 `sudo !!`再尝试一次。\n\n- `$_` - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 `Esc` 之后键入 . 来获取这个值。\n\n- `diff <(ls foo) <(ls bar)` 会显示文件夹 `foo` 和 `bar` 中文件的区别。\n\n- ```bash\n  convert image.{png,jpg}\n  # 会展开为\n  convert image.png image.jpg\n  mv *{.py,.sh} folder\n  # 会移动所有 *.py 和 *.sh 文件\n  ```\n","tags":["Linux"]},{"title":"CSS小技巧","url":"/202012/CSS小技巧/","content":"\n### font-size: 0; 解决图片不能完全占满父级\n\n- 当一个父级里面放多个并列的图片时，我们在编辑器上喜欢一行一个 `img `标签，浏览器在解析时会将空行解析为一个空格，这个时候两个图片中间就会有一个字的间隙，可以在父级设置 `font-size: 0;`\n  - ![Q5agSE](https://gitee.com/daixiongsheng/pictures/raw/master/uPic/2020/12/23/17-15/Q5agSE.png)\n  - [demo](https://codepen.io/daixiongsheng/pen/bGwoogg?editors=1100)\n\n### flex:1; width:0;\n\n- 解决 flex 布局子元素的文本溢出不能正常显示省略号的问题。\n  - ![SSsKGc](https://gitee.com/daixiongsheng/pictures/raw/master/uPic/2020/12/23/16-58/SSsKGc.png)\n  - [demo](https://codepen.io/daixiongsheng/pen/zYqWzxy?editors=1100)\n- 预防 iframe 滚动条。(待补充)\n","tags":["前端","CSS"]},{"title":"面向对象设计原则","url":"/设计模式/面向对象设计原则/","content":"\n# 面向对象设计原则\n\n## 总原则：开闭原则\n\n- **软件实体应当对扩展开放，对修改关闭**\n- 进行拓展的时候，不能去修改原有的代码\n\n## 单一职责原则\n\n- 单一职责原则规定一个类应该有且仅有一个引起它变化的原因\n- 对象不应该承担太多职责\n- 一个类，就干他该干的事，不参合其他的功能\n\n## 里氏替换原则\n\n- 任何基类可以出现的地方，子类一定可以出现\n- 任何在使用基类的地方，可以完全的替换成其子类而对应的功能不会发生变化。\n\n## 依赖倒转原则\n\n- 开闭原则的基础\n- 面向接口编程，依赖于抽象而不依赖于具体。\n- 变量的声明类型尽量是接口或者是抽象类\n- 任何类都不应该从具体类派生。\n- 每个类尽量提供接口或抽象类，或者两者都具备。\n- 写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。不关于类内部的功能，只关心他的上层接口提供有什么功能。\n\n## 接口隔离原则\n\n- 要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。\n- 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。\n- 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。\n\n## 迪米特法则（最少知道原则）\n\n- 如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。\n- “朋友”：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等\n- 过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。\n\n## 合成复用原则\n\n- 尽量首先使用合成/聚合的方式，而不是使用继承。\n","tags":["设计模式"]},{"title":"浏览器--渲染引擎&JavaScript引擎","url":"/202009/浏览器-渲染引擎-JavaScript-引擎/","content":"\n# 渲染引擎\n\n1. 渲染引擎的主要作用是，将网页代码渲染为用户视觉可以感知的平面文档。\n   1. Firefox：Gecko 引擎\n   2. Safari：WebKit 引擎\n   3. Chrome：Blink 引擎\n   4. IE: Trident 引擎\n   5. Edge: EdgeHTML 引擎\n2. 渲染引擎处理网页，通常分成四个阶段。\n   1. 解析代码：HTML 代码解析为 DOM，CSS 代码解析为 CSSOM（CSS Object Model）。\n   2. 对象合成：将 DOM 和 CSSOM 合成一棵渲染树（render tree）。\n   3. 布局：计算出渲染树的布局（layout）。\n   4. 绘制：将渲染树绘制到屏幕。\n3. **重绘回流 优化技巧**\n   1. 读取 DOM 或者写入 DOM，尽量写在一起，不要混杂。不要读取一个 DOM 节点，然后立刻写入，接着再读取一个 DOM 节点。\n   2. 缓存 DOM 信息。\n   3. 不要一项一项地改变样式，而是使用 CSS class 一次性改变样式。\n   4. 使用`documentFragment`操作 DOM\n   5. 动画使用`absolute`定位或`fixed`定位，这样可以减少对其他元素的影响。\n   6. 使用`window.requestAnimationFrame()`，因为它可以把代码推迟到下一次重绘之前执行，而不是立即要求页面重绘。\n\n# JavaScript 解释器（又称 JavaScript 引擎）\n\n1. 常见的一些 JavaScript 虚拟机\n   1. [Chakra](<https://en.wikipedia.org/wiki/Chakra_(JScript_engine)>) (Microsoft Internet Explorer)\n   2. [Nitro/JavaScript Core](https://en.wikipedia.org/wiki/WebKit#JavaScriptCore) (Safari)\n   3. [Carakan](https://dev.opera.com/articles/view/labs-carakan/) (Opera)\n   4. [SpiderMonkey](https://developer.mozilla.org/en-US/docs/SpiderMonkey) (Firefox)\n   5. [V8](https://en.wikipedia.org/wiki/Chrome_V8) (Chrome, Chromium)\n","tags":["前端","浏览器"]},{"title":"浏览器--script标签","url":"/202009/浏览器-script标签/","content":"\n# 浏览器 script 原理\n\n1. 浏览器 `script` 原理\n\n   1. 浏览器加载 `JavaScript` 脚本，主要通过`<script>`元素完成。正常的网页加载流程是这样的。\n\n      1. 浏览器一边下载 `HTML` 网页，一边开始解析。也就是说，不等到下载完，就开始解析。\n      2. 解析过程中，浏览器发现`<script>`元素，就暂停解析，把网页渲染的控制权转交给 `JavaScript` 引擎。\n      3. 如果`<script>`元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。\n      4. `JavaScript` 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页。\n\n      加载外部脚本时，浏览器会暂停页面渲染，等待脚本下载并执行完成后，再继续渲染。原因是 `JavaScript` 代码可以修改 DOM，所以必须把控制权让给它，否则会导致复杂的线程竞赛的问题。\n\n      如果外部脚本加载时间很长（一直无法完成下载），那么浏览器就会一直等待脚本下载完成，造成网页长时间失去响应，浏览器就会呈现“假死”状态，这被称为“阻塞效应”。\n\n      为了避免这种情况，较好的做法是将`<script>`标签都放在页面底部，而不是头部。这样即使遇到脚本失去响应，网页主体的渲染也已经完成了，用户至少可以看到内容，而不是面对一张空白的页面。如果某些脚本代码非常重要，一定要放在页面头部的话，最好直接将代码写入页面，而不是连接外部脚本文件，这样能缩短加载时间。\n\n      脚本文件都放在网页尾部加载，还有一个好处。因为在 DOM 结构生成之前就调用 DOM 节点，JavaScript 会报错，如果脚本都在网页尾部加载，就不存在这个问题，因为这时 DOM 肯定已经生成了。\n\n2. `defer` 属性\n\n   1. 为了解决脚本文件下载阻塞网页渲染的问题，一个方法是对`<script>`元素加入`defer`属性。它的作用是**延迟脚本的执行，等到 DOM 加载生成后，再执行脚本。**\n   2. 运行流程\n      1. 浏览器开始解析 `HTML` 网页。\n      2. 解析过程中，发现带有`defer`属性的`<script>`元素。\n      3. 浏览器继续往下解析 `HTML` 网页，同时并行下载`<script>`元素加载的外部脚本。\n      4. 浏览器完成解析 `HTML` 网页，此时再回过头执行已经下载完成的脚本。\n\n3. `async` 属性\n\n   1. **`async`属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染**。\n   2. 流程\n      1. 浏览器开始解析 `HTML` 网页。\n      2. 解析过程中，发现带有`async`属性的`script`标签。\n      3. 浏览器继续往下解析 `HTML` 网页，同时并行下载`<script>`标签中的外部脚本。\n      4. 脚本下载完成，浏览器暂停解析 `HTML` 网页，开始执行下载的脚本。\n      5. 脚本执行完毕，浏览器恢复解析 `HTML` 网页。\n   3. `async`属性可以保证脚本下载的同时，浏览器继续渲染。需要注意的是，一旦采用这个属性，就无法保证脚本的执行顺序。哪个脚本先下载结束，就先执行那个脚本。另外，使用`async`属性的脚本文件里面的代码。\n\n4. `defer / async`\n\n   1. 一般来说，如果**脚本之间没有依赖关系，就使用`async`属性**，如果脚本之间有依赖关系，就使用`defer`属性。如果同时使用`async`和`defer`属性，后者不起作用，浏览器行为由`async`属性决定。\n","tags":["前端","浏览器"]},{"title":"JS--进度事件","url":"/202009/JS-进度事件/","content":"\n# 进度事件\n\n- 进度事件用来描述资源加载的进度，主要由 AJAX 请求、`<img>`、`<audio>`、`<video>`、`<style>`、`<link>`等外部资源的加载触发，继承了`ProgressEvent`接口。它主要包含以下几种事件。\n\n1. `abort`：外部资源中止加载时（比如用户取消）触发。如果发生错误导致中止，不会触发该事件。\n2. `error`：由于错误导致外部资源无法加载时触发。\n3. `load`：外部资源加载成功时触发。\n4. `loadstart`：外部资源开始加载时触发。\n5. `loadend`：外部资源停止加载时触发，发生顺序排在`error`、`abort`、`load`等事件的后面。\n6. `progress`：外部资源加载过程中不断触发。\n7. `timeout`：加载超时时触发。\n","tags":["前端"]},{"title":"JS--MutationObserver","url":"/202009/JS-MutationObserver/","content":"\n# MutationObserver\n\n1. Mutation Observer API 用来监视 DOM 变动。DOM 的任何变动，比如节点的增减、属性的变动、文本内容的变动，这个 API 都可以得到通知。\n\n2. Vue 内部 nextTick 就使用到了这个 API\n\n3. ```JS\n   var observer = new MutationObserver(function (mutations, observer) {\n     mutations.forEach(function(mutation) {\n       console.log(mutation);\n     });\n   });\n\n   var article = document.querySelector('article');\n\n   var  options = {\n     'childList': true,\n     'attributes':true\n   } ;\n\n   observer.observe(article, options);\n\n   // observe()方法接受两个参数，第一个是所要观察的DOM元素是article，第二个是所要观察的变动类型（子节点变动和属性变动）。\n   /* subtree：布尔值，表示是否将该观察器应用于该节点的所有后代节点。\n   attributeOldValue：布尔值，表示观察attributes变动时，是否需要记录变动前的属性值。\n   characterDataOldValue：布尔值，表示观察characterData变动时，是否需要记录变动前的值。\n   attributeFilter：数组，表示需要观察的特定属性（比如['class','src']）。\n   /*\n   ```\n\n4. `disconnect()`方法用来停止观察。调用该方法后，DOM 再发生变动，也不会触发观察器。\n\n5. `takeRecords()`方法用来清除变动记录，即不再处理未处理的变动。该方法返回变动记录的数组。\n\n6. DOM 每次发生变化，就会生成一条变动记录（MutationRecord 实例）。该实例包含了与变动相关的所有信息。Mutation Observer 处理的就是一个个`MutationRecord`实例所组成的数组。\n\n```JS\n// src/core/util/next-tick.js\n...\n else if (!isIE && typeof MutationObserver !== 'undefined' && (\n  isNative(MutationObserver) ||\n  // PhantomJS and iOS 7.x\n  MutationObserver.toString() === '[object MutationObserverConstructor]'\n)) {\n  // Use MutationObserver where native Promise is not available,\n  // e.g. PhantomJS, iOS7, Android 4.4\n  // (#6466 MutationObserver is unreliable in IE11)\n  let counter = 1\n  const observer = new MutationObserver(flushCallbacks)\n  const textNode = document.createTextNode(String(counter))\n  observer.observe(textNode, {\n    characterData: true\n  })\n  timerFunc = () => {\n    counter = (counter + 1) % 2\n    textNode.data = String(counter)\n  }\n}\n...\n\n```\n","tags":["前端"]},{"title":"HTML--Element的各种位置信息","url":"/202009/HTML-Element的各种位置信息/","content":"\n# Element\n\n1. `outerHTML` 包含本元素自身\n\n   - `e.outerHTML = 'template'` 时会把 `e` 自己进行替换，`vue` 的 `v-html` 默认使用的是 `innerHTML`\n\n2. `clientHeight` **整数** 表示元素节点的 CSS 高度,行内元素返回`0`,**包括自身+padding**, **不包含 border+ margin + 滚动条**\n\n3. `clientWidth` 同理\n\n4. `clientLeft` **整数** 等于元素节点**左边框（ border）的宽度**（单位像素），**不包括 padding`和`margin**。\n\n5. `clientTop`\n\n6. `scrollHeight` **整数** 表示当前元素的**总高度**（单位像素），**包括溢出容器、当前不可见的部分。它包括`padding`**，但是不包括`border`、`margin`以及水平滚动条的高度，还**包括伪元素（`::before`或`::after`）的高度**。\n\n7. `scrollWidth`\n\n8. `scrollTop` **水平滚动条向右侧滚动的像素数量**，\n\n9. `scrollLeft`\n\n10. `offsetParent` 第一个 `position`属性不等于`static` 的上层元素。\n\n11. `offsetHeight` **整数**，表示元素的 **CSS 垂直高度**（单位像素），**元素+padding+border+滚动条**\n\n12. `offsetWidth`\n\n13. `offsetLeft` 返回当前元素左上角相对于`Element.offsetParent`节点的水平位移，\n\n14. `offsetTop`\n\n15. **`scrollIntoView(bool)`** 当 bool 为 true，滚动元素到当前视口的最上面，false，滚动到最下面\n\n16. **`getBoundingClientRect()`** 方法返回一个对象，提供当前元素节点的大小、位置等信息，基本上就是 CSS 盒状模型的所有信息。\n\n17. **`getClientRects()`**\n\n18. **`insertAdjacentElement(position,node)`** 在相对于当前元素的指定位置，插入一个新的节点。返回被插入的节点\n\n    - `position` 值为以下 4 个之一，\n\n    1. `beforebegin`：当前元素之前\n    2. `afterbegin`：当前元素内部的第一个子节点前面\n    3. `beforeend`：当前元素内部的最后一个子节点后面\n    4. `afterend`：当前元素之后\n\n19. `insertAdjacentHTML()` 插入 html\n\n20. `insertAdjacentText()` 插入 text\n\n# DocumentFragment\n\n- 节点代表一个**文档的片段**，本身就是一个完整的 DOM 树形结构。它没有父节点，`parentNode`返回`null`，但是可以插入任意数量的子节点。它不属于当前文档，操作`DocumentFragment`节点，要**比直接操作 DOM 树快得多**。\n","tags":["前端","HTML"]},{"title":"JS--new 原理","url":"/202009/JS-new-原理/","content":"\n使用`new`命令时，它后面的函数依次执行下面的步骤。\n\n1. 创建一个空对象，作为将要返回的对象实例。\n2. 将这个空对象的原型，指向构造函数的`prototype`属性。\n3. 将这个空对象赋值给函数内部的`this`关键字。\n4. 开始执行构造函数内部的代码。\n\n```JS\nconst newInstacne(Constructor, ...args) {\n  const o = Object.create(Constructor.prototype)\n  Constructor.apply(o, args)\n  return o\n}\n```\n","tags":["前端"]},{"title":"浏览器--console","url":"/202009/浏览器console/","content":"\n# 控制台命令行 API\n\n## console\n\n1. `console.assert` 断言一个表达式，如果返回 false 则抛出异常\n2. `console.trace` 显示当前执行的代码在**堆栈**中的调用路径。\n3. `console.dir`\n4. `console.dirxml`\n5. `console.clear`\n6. `console.time`\n7. `console.timeEnd`\n\n## $\n\n- $\\_ 返回上一个表达式的值。\n- `$0` - `$4` 控制台保存了最近 5 个在 Elements 面板选中的 DOM 元素，`$0`代表倒数第一个（最近一个），`$1`代表倒数第二个，以此类推直到`$4`。\n- `$(selector)` `$(selector)`**返回第一个匹配的元素**，等同于`document.querySelector()`。注意，如果页面脚本对`$`有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行`$(selector)`就会采用 jQuery 的实现，返回一个数组。\n- `$$(selector)` `$$(selector)`返回选中的 DOM 对象，等同于`document.querySelectorAll`。\n- `$x(path)` 方法返回一个**数组**，包含匹配特定 XPath 表达式的所有 DOM 元素。\n","tags":["前端"]},{"title":"JS--数值","url":"/202009/JS-数值/","content":"\n## 精度\n\n- 绝对值小于 2 的 53 次方的整数，即`-2^53`到`2^53`，都可以精确表示。\n\n- `JavaScript` 能够表示的数值范围为`2^1024`到`2^-1023`\n\n- 自动将数值转为科学计数法表示\n\n  1.  **小数点前的数字多于 21 位。**\n  2.  **小数点后的零多于 5 个。**\n\n## +0 -0\n\n- `JavaScript` 内部实际上存在 2 个`0`：一个是`+0`，一个是`-0`，区别就是 64 位浮点数表示法的符号位不同。它们是等价的。\n\n## NaN\n\n- `NaN`不等于任何值，包括它本身。 `NaN === NaN //false`\n\n## Infinity\n\n1.  “无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非 0 数值除以 0，得到`Infinity`。\n\n2.  ```js\n    0 / 0 // NaN\n    1 / 0 // Infinity\n    ```\n\n3.  0 乘以`Infinity`，返回`NaN`；0 除以`Infinity`，返回`0`；`Infinity`除以 0，返回`Infinity`。\n\n4.  ```js\n    0 * Infinity // NaN\n    0 / Infinity // 0\n    Infinity / 0 // Infinity\n    ```\n\n## Base64 转码\n\n1.  `btoa()`：任意值转为 Base64 编码\n2.  `atob()`：Base64 编码转为原来的值\n\n## 保留小数点后多少位\n\n    1. Number.prototype.toFixed(n) 保留n位小数\n\n## 保留有效位\n\n    1. Number.prototype.toPrecision(n)  保留n位有效数字\n\n## 转成科学计数法\n\n    1.  Number.prototype.toExponential() 转成科学计数法\n\n    ```JS\n    (12.34).toPrecision(1) // \"1e+1\"\n    (12.34).toPrecision(2) // \"12\"\n    (12.34).toPrecision(3) // \"12.3\"\n    (12.34).toPrecision(4) // \"12.34\"\n    (12.34).toPrecision(5) // \"12.340\"\n    ```\n\n## String\n\n1.  `charCodeAt()`方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于`String.fromCharCode()`的逆操作。\n\n2.  String.prototype.localeCompare()\n\n3.  `localeCompare`方法用于比较两个字符串。它返回一个整数，如果小于 0，表示第一个字符串小于第二个字符串；如果等于 0，表示两者相等；如果大于 0，表示第一个字符串大于第二个字符串。\n\n4.  ```JS\n    'apple'.localeCompare('banana') // -1\n    'apple'.localeCompare('apple') // 0\n    ```\n\n## Date\n\n1.  `Date.parse`方法用来解析日期字符串，返回该时间距离时间零点（1970 年 1 月 1 日 00:00:00）的毫秒数。\n\n2.  ```JS\n    Date.parse('2011-10-10')\n    ```\n\n3.  `Date.UTC`方法接受年、月、日等变量作为参数，返回该时间距离时间零点（1970 年 1 月 1 日 00:00:00 UTC）的毫秒数。\n\n4.  ```js\n    Date.UTC(2011, 0, 1, 2, 3, 4, 567)\n    // 1293847384567\n    ```\n\n## JSON\n\n1.  JSON.stringify()\n\n2.  `JSON.stringify`方法用于将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被`JSON.parse`方法还原。\n\n3.  `JSON.stringify`方法还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。\n\n4.  `JSON.stringify`还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过 10 个）；如果是字符串（不超过 10 个字符），则该字符串会添加在每行前面。\n\n5.  ```JS\n    JSON.stringify({ p1: 1, p2: 2 }, null, 2);\n    /*\n    \"{\n    \"p1\": 1,\n    \"p2\": 2\n    }\"\n    */\n    ```\n","tags":["前端"]},{"title":"JS--null/undefined","url":"/202009/JS-null-undefined/","content":"\n### null / undefined\n\n1. `null`是一个表示“空”的对象，转为数值时为`0`；`undefined`是一个表示\"此处无定义\"的原始值，转为数值时为`NaN`。\n\n2. `null`表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入`null`，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入`null`，表示未发生错误。\n\n   `undefined`表示“未定义”\n\n3. `void` 后面接任何都是返回 `undefined`\n","tags":["前端"]},{"title":"HTML--实体字符","url":"/202009/HTML实体字符/","content":"\n## HTML 中常用的字符实体\n\n| 显示结果 | 描述              | 实体名称             | 实体编号  |\n| :------- | :---------------- | :------------------- | :-------- |\n|          | 空格              | `&nbsp;`             | `&#160;`  |\n| <        | 小于号            | `&lt;`               | `&#60;`   |\n| >        | 大于号            | `&gt;`               | `&#62;`   |\n| &        | 和号              | `&amp;`              | `&#38;`   |\n| \"        | 引号              | `&quot;`             | `&#34;`   |\n| '        | 撇号              | `&apos;` (IE 不支持) | `&#39;`   |\n| ￠       | 分（cent）        | `&cent;`             | `&#162;`  |\n| £        | 镑（pound）       | `&pound;`            | `&#163;`  |\n| ¥        | 元（yen）         | `&yen;`              | `&#165;`  |\n| €        | 欧元（euro）      | `&euro;`             | `&#8364;` |\n| §        | 小节              | `&sect;`             | `&#167;`  |\n| ©        | 版权（copyright） | `&copy;`             | `&#169;`  |\n| ®        | 注册商标          | `&reg;`              | `&#174;`  |\n| ™        | 商标              | `&trade;`            | `&#8482;` |\n| ×        | 乘号              | `&times;`            | `&#215;`  |\n| ÷        | 除号              | `&divide;`           | `&#247;`  |\n\n## HTML 支持的数学符号\n\n| 字符 | 实体编号  | 实体名称   | 描述              |\n| :--- | :-------- | :--------- | :---------------- |\n| ∀    | `&#8704;` | `&forall;` | for all           |\n| ∂    | `&#8706;` | `&part;`   | part              |\n| ∃    | `&#8707;` | `&exist;`  | exists            |\n| ∅    | `&#8709;` | `&empty;`  | empty             |\n| ∇    | `&#8711;` | `&nabla;`  | nabla             |\n| ∈    | `&#8712;` | `&isin;`   | isin              |\n| ∉    | `&#8713;` | `&notin;`  | notin             |\n| ∋    | `&#8715;` | `&ni;`     | ni                |\n| ∏    | `&#8719;` | `&prod;`   | prod              |\n| ∑    | `&#8721;` | `&sum;`    | sum               |\n| −    | `&#8722;` | `&minus;`  | minus             |\n| ∗    | `&#8727;` | `&lowast;` | lowast            |\n| √    | `&#8730;` | `&radic;`  | square root       |\n| ∝    | `&#8733;` | `&prop;`   | proportional to   |\n| ∞    | `&#8734;` | `&infin;`  | infinity          |\n| ∠    | `&#8736;` | `&ang;`    | angle             |\n| ∧    | `&#8743;` | `&and;`    | and               |\n| ∨    | `&#8744;` | `&or;`     | or                |\n| ∩    | `&#8745;` | `&cap;`    | cap               |\n| ∪    | `&#8746;` | `&cup;`    | cup               |\n| ∫    | `&#8747;` | `&int;`    | integral          |\n| ∴    | `&#8756;` | `&there4;` | therefore         |\n| ∼    | `&#8764;` | `&sim;`    | similar to        |\n| ≅    | `&#8773;` | `&cong;`   | congruent to      |\n| ≈    | `&#8776;` | `&asymp;`  | almost equal      |\n| ≠    | `&#8800;` | `&ne;`     | not equal         |\n| ≡    | `&#8801;` | `&equiv;`  | equivalent        |\n| ≤    | `&#8804;` | `&le;`     | less or equal     |\n| ≥    | `&#8805;` | `&ge;`     | greater or equal  |\n| ⊂    | `&#8834;` | `&sub;`    | subset of         |\n| ⊃    | `&#8835;` | `&sup;`    | superset of       |\n| ⊄    | `&#8836;` | `&nsub;`   | not subset of     |\n| ⊆    | `&#8838;` | `&sube;`   | subset or equal   |\n| ⊇    | `&#8839;` | `&supe;`   | superset or equal |\n| ⊕    | `&#8853;` | `&oplus;`  | circled plus      |\n| ⊗    | `&#8855;` | `&otimes;` | circled times     |\n| ⊥    | `&#8869;` | `&perp;`   | perpendicular     |\n| ⋅    | `&#8901;` | `&sdot;`   | dot operator      |\n\n## HTML 支持的希腊字母\n\n| 字符 | 实体编号 | 实体名称     | 描述           |\n| :--- | :------- | :----------- | :------------- |\n| Α    | `&#913;` | `&Alpha;`    | Alpha          |\n| Β    | `&#914;` | `&Beta;`     | Beta           |\n| Γ    | `&#915;` | `&Gamma;`    | Gamma          |\n| Δ    | `&#916;` | `&Delta;`    | Delta          |\n| Ε    | `&#917;` | `&Epsilon;`  | Epsilon        |\n| Ζ    | `&#918;` | `&Zeta;`     | Zeta           |\n| Η    | `&#919;` | `&Eta;`      | Eta            |\n| Θ    | `&#920;` | `&Theta;`    | Theta          |\n| Ι    | `&#921;` | `&Iota;`     | Iota           |\n| Κ    | `&#922;` | `&Kappa;`    | Kappa          |\n| Λ    | `&#923;` | `&Lambda;`   | Lambda         |\n| Μ    | `&#924;` | `&Mu;`       | Mu             |\n| Ν    | `&#925;` | `&Nu;`       | Nu             |\n| Ξ    | `&#926;` | `&Xi;`       | Xi             |\n| Ο    | `&#927;` | `&Omicron;`  | Omicron        |\n| Π    | `&#928;` | `&Pi;`       | Pi             |\n| Ρ    | `&#929;` | `&Rho;`      | Rho            |\n| Σ    | `&#931;` | `&Sigma;`    | Sigma          |\n| Τ    | `&#932;` | `&Tau;`      | Tau            |\n| Υ    | `&#933;` | `&Upsilon;`  | Upsilon        |\n| Φ    | `&#934;` | `&Phi;`      | Phi            |\n| Χ    | `&#935;` | `&Chi;`      | Chi            |\n| Ψ    | `&#936;` | `&Psi;`      | Psi            |\n| Ω    | `&#937;` | `&Omega;`    | Omega          |\n| α    | `&#945;` | `&alpha;`    | alpha          |\n| β    | `&#946;` | `&beta;`     | beta           |\n| γ    | `&#947;` | `&gamma;`    | gamma          |\n| δ    | `&#948;` | `&delta;`    | delta          |\n| ε    | `&#949;` | `&epsilon;`  | epsilon        |\n| ζ    | `&#950;` | `&zeta;`     | zeta           |\n| η    | `&#951;` | `&eta;`      | eta            |\n| θ    | `&#952;` | `&theta;`    | theta          |\n| ι    | `&#953;` | `&iota;`     | iota           |\n| κ    | `&#954;` | `&kappa;`    | kappa          |\n| λ    | `&#955;` | `&lambda;`   | lambda         |\n| μ    | `&#956;` | `&mu;`       | mu             |\n| ν    | `&#957;` | `&nu;`       | nu             |\n| ξ    | `&#958;` | `&xi;`       | xi             |\n| ο    | `&#959;` | `&omicron;`  | omicron        |\n| π    | `&#960;` | `&pi;`       | pi             |\n| ρ    | `&#961;` | `&rho;`      | rho            |\n| ς    | `&#962;` | `&sigmaf;`   | sigmaf         |\n| σ    | `&#963;` | `&sigma;`    | sigma          |\n| τ    | `&#964;` | `&tau;`      | tau            |\n| υ    | `&#965;` | `&upsilon;`  | upsilon        |\n| φ    | `&#966;` | `&phi;`      | phi            |\n| χ    | `&#967;` | `&chi;`      | chi            |\n| ψ    | `&#968;` | `&psi;`      | psi            |\n| ω    | `&#969;` | `&omega;`    | omega          |\n| ϑ    | `&#977;` | `&thetasym;` | theta symbol   |\n| ϒ    | `&#978;` | `&upsih;`    | upsilon symbol |\n| ϖ    | `&#982;` | `&piv;`      | pi symbol      |\n","tags":["前端"]},{"title":"JS--label 代码块","url":"/202009/JS-label-代码块/","content":"\n### label\n\n- 代码块前面可以添加标识符，可以与 break，continue 配置\n\n```JS\nfoo: {\n    console.log(1);\n    break foo;\n    console.log('本行不会输出');\n  }\n  console.log(2);\n```\n","tags":["前端"]},{"title":"JS--你不知道的注释","url":"/202009/JS-你不知道的注释/","content":"\n- 由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以`<!--`和`-->`也被视为合法的单行注释。\n\n```JS\n--> 这是注释 ，但这种注释只有在第一行有效\n<!-- 这也是注释 -->\n<!-- 这还是是注释\nconsole.log(\"Hello world\")\n<!-- 我们又见面了\n\n// 下面是输出\n$ node index.js\nHello world\n```\n","tags":["前端"]},{"title":"常用正则","url":"/202008/常用正则/","content":"\n### email\n\n```JS\nconst emailPattern = /^([A-Za-z0-9_\\-\\.])+\\@([A-Za-z0-9_\\-\\.])+\\.([A-Za-z]{2,4})$/\n```\n\n### 手机号\n\n```JS\nconst telPattern = /^1[34578]\\d{9}$/\n```\n\n### URL\n\n```JS\nconst urlPattern = /^((https?|ftp|file):\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$/\n```\n\n### 微信号\n\n```JS\nconst wxPattern = /^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/\n```\n\n### 中文\n\n```JS\nconst cnPattern = /[\\u4E00-\\u9FA5]/;\n```\n","tags":["tools"]},{"title":"事件冒泡与事件捕获&addEventListener","url":"/202004/事件冒泡与事件捕获addEventListener/","content":"\n# 事件冒泡与事件捕获\n\n## 事件冒泡\n\n- 指的是一个事件（这里假设为 click）由子元素触发时，会先调用子元素的 click 事件处理程序（如果有设置并且没有手动取消冒泡`stopPropagation()`），然后再调用父元素的事件处理程序（如果有设置并且没有手动取消冒泡`stopPropagation()`）..再继续向上传播给其直接父元素，直至根元素\n- 这个从内部向外的过程就叫事件冒泡\n\n## 事件捕获\n\n- 事件捕获与事件冒泡的过程完全相反，是一种自顶向下的方式。\n- IE8 及以前只支持事件捕获\n- IE9+支持事件冒泡\n\n## addEventListener\n\n- `addEventListener`用来绑定事件的函数，可以传递 3 个参数\n- IE8 及以前使用 attachEvent\n- `element.addEventListener(event, function, useCapture);`\n- 第一个参数 event: 事件名称\n- 第二个参数 function:对应事件的处理程序\n- 第三个参数\n  - 可以是一个对象，也可以是一个 Boolean\n  - Boolean\n    - 默认 false 表示在**冒泡阶段**调用事件处理程序\n    - true 表示在**捕获阶段**调用事件处理程序\n  - 对象（IE 只支持 Boolean 值，传递一个对象会隐示转换为 Boolean）\n    - capture 一个 Boolean 值，默认 false,表示在**冒泡阶段**调用事件处理程序\n    - once 一个 Boolean 值，默认 false,表示是否只执行一次\n    - passive 一个 Boolean 值，默认 false,表示是否永远不会调用 preventDefault()\n\n## 事件处理函数\n\n- 执行对应事件处理函数时，会传入一个 event 对象。event 对象其中两个属性`target`,`currentTarge`t 分别表示事件的触发元素，和当前事件处理函数的正在处理事件的那个元素。\n- 例：父子元素都监听了 click 事件，当点击子元素时，当由子元素在执行相应的 click 处理函数时，此时的`target` 和`currentTarget` 都为子元素，当由父元素在执行相应的 click 处理函数时，此时的`target` 为子元素和`currentTarget` 都为父元素\n\n## 一个例子\n\n```html\n<style>\n  .box {\n    width: 500px;\n    height: 500px;\n    background-color: #000;\n  }\n  .r {\n    width: 400px;\n    height: 400px;\n    background-color: red;\n  }\n  .g {\n    width: 300px;\n    height: 300px;\n    background-color: green;\n  }\n  .b {\n    width: 200px;\n    height: 200px;\n    background-color: blue;\n  }\n</style>\n<div class=\"box\">\n  <div class=\"r\">\n    <div class=\"g\">\n      <div class=\"b\"></div>\n    </div>\n  </div>\n</div>\n<script>\n  const qs = (e) => document.querySelector(e)\n  const box = qs('.box')\n  const r = qs('.r')\n  const g = qs('.g')\n  const b = qs('.b')\n\n  const op = {\n    capture: false,\n    once: false,\n    passive: false,\n  }\n  function bindClick(e) {\n    const _this = e\n    e.addEventListener(\n      'click',\n      function (event) {\n        console.log(_this.getAttribute('class'))\n      },\n      op\n    )\n  }\n\n  bindClick(box)\n  bindClick(r)\n  bindClick(g)\n  bindClick(b)\n\n  /*\n当capture为false时（默认）点击最内部的div时\n控制台输出\nb\ng\nr\nbox\n\n\n当capture为true时（默认）点击最内部的div时\n控制台输出\nbox\nr\ng\nb\n\n*/\n</script>\n```\n","tags":["前端"]},{"title":"ES6 的 Map Set WeakMap WeakSet 最大的特性与区别","url":"/202004/ES6的MapSetWeakMapWeakSet最大的特性与区别/","content":"\n## Set\n\n- ES6 新增数据结构，类似数组，成员是唯一的，可以**存放各种数据类型**\n- 可以**遍历**\n\n```js\nlet a = {}\nlet b = a\nlet c = []\nlet d = c\nlet s = new Set([\n  1,\n  1,\n  '2',\n  '2',\n  Symbol(1),\n  1n,\n  a,\n  b, //a,b为同一个对象，只保留一个\n  c,\n  d, //a,b为同一个数组，只保留一个\n  [],\n  {},\n  NaN,\n  NaN, //即使两个NaN也只保留一个\n  function () {},\n  null,\n  undefined,\n])\nconsole.log(s.size) //12\n```\n\n## WeakSet\n\n- 与 Set 类似，不重复的值的集合\n- **只能储存对象**，WeakSet 中的对象是被 弱引用的，当其他地方没有引用到该对象时，**垃圾回收机制不考虑 WeakSet 对该对象的引用**，会回收掉该对象。\n- WeakSet 不能遍历，他里面的对象随时可能会消失\n- 没有 size 属性，不能获取到 WeakSet 的长度，**不可遍历**\n- 可以用来储存 DOM 节点，而不用担心这些节点从文档移除时，引发内存泄漏。\n\n```js\nlet a = { 1: 1 }\nlet b = a\nlet c = [1, 2]\nlet d = c\nlet s = new WeakSet([\n  a,\n  b,\n  c,\n  d,\n  [],\n  {}, //由于没有其他的引用s 中不会保留这两个对象\n])\nconsole.log(s)\n/*\nWeakSet {Array(0), {…}, {…}, Array(2)}\n    [[Entries]]\n        0: Object\n        1: Array(2)\n    __proto__: WeakSet\n*/\n```\n\n## Map\n\n- 键值对的集合，键唯一，可以是任何数据类型，**可遍历**\n- **JS 对象**的键只能是**字符串**，\n\n```js\nlet a = {}\nlet b = a\nlet c = []\nlet d = c\nlet m = new Map()\nm.set(1, 1)\n  .set('1', '1')\n  .set(a, a)\n  .set(b, b)\n  .set(c, c)\n  .set(d, d)\n  .set(NaN, NaN)\n  .set(null, null)\n  .set(undefined, undefined)\n  .set(\n    function () {},\n    function () {}\n  )\n  .set({}, {})\n  .set(new Map(), {})\nconsole.log(m.size) //12\nconsole.log(m) //12\n/*\nMap(10) {1 => 1, \"1\" => \"1\", {…} => {…}, Array(0) => Array(0), NaN => NaN, …}\n    [[Entries]]\n        0: {1 => 1}\n        1: {\"1\" => \"1\"}\n        2: {Object => Object}\n        3: {Array(0) => Array(0)}\n        4: {NaN => NaN}\n        5: {null => null}\n        6: {undefined => undefined}\n        7: {function(){} => function(){}}\n        8: {Object => Object}\n        9: {Map(0) => Object}\n    size: (...)\n    __proto__: Map\n\n*/\n```\n\n## WeakMap\n\n- 键值对的集合，键唯一，**只能是对象**（ `null` 除外）\n- 值可以是任何数据\n- 和 WeakSet 类似，**当其中的键没有其他地方引用时会被回收**。\n- 可以用来对 DOM 节点的事件绑定。\n- **不可遍历**\n\n```js\nlet a = {}\nlet b = a\nlet c = []\nlet d = c\nlet m = new WeakMap()\nm.set(a, a)\n  .set(b, b)\n  .set(c, c)\n  .set(d, d)\n  .set(\n    function () {},\n    function () {}\n  ) //没有其他地方的引用，被回收\n  .set({}, {}) //没有其他地方的引用，被回收\n  .set(new Map(), {}) //没有其他地方的引用，被回收\nconsole.log(m)\n/*\nWeakMap {{…} => {…}, Map(0) => {…}, {…} => {…}, Array(0) => Array(0), ƒ => ƒ}\n    [[Entries]]\n        0: {Object => Object}\n        1: {Array(0) => Array(0)}\n    __proto__: WeakMap\n*/\n```\n","tags":["前端","JS"]},{"title":"JavaScript 之请求跨域","url":"/202003/JS-请求跨域/","content":"\n# 跨域\n\n#### 跨域的产生\n\n##### 浏览器同源策略\n\n同源策略是浏览器最基本的最核心的安全功能，`A` 网页的 `cookie` B 网页不能使用，除非这两个网页同源。同源即\"协议 + 域名 + 端口\"三者相同（两个不同的域名指向同一个 ip 地址也非同源）\n\n在进行异步网络请求的时候，如果请求的地址与当前地址的**域名(ip)**、 **协议**、 **端口** 中有任何一个不同就会产生跨域。\n\n## 解决跨域方案\n\n### JSONP (JSON with Padding)\n\n- 利用浏览器允许 `<script>` 下载不同网站的 JS 脚本\n- 通过手动创建一个 script 标签\n- 相当于在客户端提供一个接口供服务器调用。不过一般服务器对客户端是 1 对多的模式，所以通常由客户端将本地提供的接口（函数）通过传递参数的形式传递给服务器。\n\n```HTML\n//index.html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n\n</head>\n<body>\n    <script src=\"./demo.js\"></script>\n</body>\n</html>\n```\n\n```js\n//demo.js\nvar script = document.createElement('script')\nscript.src = 'http://127.0.0.1:8880?callback=sayHello'\ndocument.head.appendChild(script)\n\n// 传递给后台的接口函数,这个函数的参数可以由后台提花\nfunction sayHello(msg) {\n  console.log(msg)\n}\n\n// 本地的测试函数，没有显示传递给后台\nfunction demo() {\n  console.log('这是前台的函数')\n}\n```\n\n```JS\n//server.js\n//服务器端\nvar qs = require('querystring')\nvar http = require('http');\nvar server = http.createServer(function (req, res) {\n  var params = qs.parse(req.url.split('?')[1]);\n  var fn = params.callback;\n  const msg = '后台已经收到'\n\n  const ret = fn + '(\"' + msg + '\")'; // sayHello(\"后台已经收到\")\n  fn && res.write(ret) //调用前端提供的函数接口，并传递数据给前端\n  res.write(';demo()') //调用前台的其他函数\n  res.write(';document.title=\"通过后台修改前台的网页标题\"') //\n  res.end();\n});\n\nserver.listen(8880, function () {\n  console.log('Server is running at port 8880...');\n});\n```\n\n- 当访问 index.html 时 浏览器控制输出\n\n```\n后台已经收到\n这是前台的函数\n```\n\n#### 缺点\n\n- 只能实现 `get` 一种请求\n- 前端的数据可能遭受到服务器的恶意修改（上面的后台修改掉前台的网站标题）虽然我们信任服务器，但对前后台分离开发模式下，我前端不想被你后台横插一脚。\n\n### document.domain + iframe\n\n- 只适用于顶级域名相同的情况\n- 例： demo1.example.com 想获取 demo2.example.com 的数据 1. 在 demo1.example.com 下设置当前的 domain `document.domain = 'xxx'` 2. 在 demo1.example.com 下通过 iframe 加载 demo2.example.com 3. 修改 demo2.example.com 的 domain 和 setp 1 的 domain 一致。 4. 这个时候就可以在 demo1.example.com 下通过 iframe 获取 demo2.example.com 的 window 对象\n\n### location.hash + iframe 跨域\n\n- 和 **document.domain + iframe** 类似\n- 使用 window.onhashchange 进行双向交流，父窗口可以对 iframe 的 url 进行读写，iframe 也可以对父窗口的 url 进行读写\n\n### 跨域资源共享（CORS）\n\n- 服务器设置 Access-Control-Allow-Origin\n- 也是常用的方法\n\n### Nginx 反向代理\n\n- 通过 Nginx 设置反向代理访问我们需要请求的资源\n- 跨域受浏览器（同源策略）影响，但**服务器上的 Nginx 是不受跨域限制（没有浏览器的同源策略）**\n- 通过 Nginx 设置代理，当 A 访问 B 跨域时，我们可以设置一个 Nginx（C）帮我们转发请求，就变成了 A->C->B\n\n### postMessage + iframe onload\n\n- postMessage 允许用户在两个窗口或 iframe 之间传递数据，无论这个 window 对象是不是同源都能发送。\n","tags":["前端"]},{"title":"JS--变量声明","url":"/202003/JS-变量声明/","content":"\n### JS 中变量名全名规则\n\nJS 中变量名中可以使用$,\\_,数字以及大小写字母，但是数字不能作为开头，大小写敏感\n\n```js\n//正确\nvar a\nvar b1\nvar c$\nvar $\nvar _\nvar $_a\nvar $123\nvar a = 123\n\nconsole.log(A) //ReferenceError  大小写敏感\n\n//错误的变量名\nvar 1\n// 关键字\nvar break\nvar new\nvar a+b\n// 保留字\nvar private\n```\n\n### 什么是变量提升\n\n- JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。\n\n### 三种变量声明方式\n\n#### var\n\n存在变量提升（在声明前使用其值为 undefined）\n\n```js\nconsole.log(foo) //undefined\nvar foo = 123\nvar bar = {}\n//隐式全局变量\nwindow.bar === bar //true\n```\n\n#### const\n\n必须先声明时定义值\n定义后值不可变（类似 C 语言指令，指针的指向不可以变，但指向地址的内容可以变）\n\n```JS\nconst foo = {}\n//foo = {} //错误，定义后指向不可变\nfoo.a = '123' //可以这么做，改变的是foo指向的内存地址对应的内容\n```\n\n#### let\n\n可以先声明后定义,声明后值可变\n可以多次改变值\n\n```js\nlet bar\nbar = 123\nbar = '123'\nbar = {}\n```\n\n#### let/const\n\n都存在块级作用域，不可多次声明，不存在变量提升，在声明前使用会报 ReferenceError（**暂时性死区**）,不会出现隐式全局变量.\n\n- 不存在变量提升\n\n```js\nconsole.log(bar) //错误\nconsole.log(foo) //错误\nlet bar = 123\nconst foo = {}\n```\n\n- 都存在块级作用域\n\n```js\n{\n  let foo = {}\n  const bar = 123\n}\nconsole.log(foo) //错误 存在块级作用域\nconsole.log(bar) //错误 存在块级作用域\n```\n\n- 不可多次声明\n\n```JS\nconst bar = 789 //错误 var存在变量提升\nvar bar = 456\nvar foo = {}\nlet foo = 123 //错误\n\n```\n\n- 不会出现隐式全局变量\n\n```js\n{\n  let bar = 123\n  var foo = {}\n}\nwindow.foo // {}\nwindow.bar //undefined\n```\n\n### 动态变量类型\n\n- 变量的类型没有限制，可以随时变，但值有类型\n\n```JS\nvar a\na = \"123\"\ntypeof a //string\na = 123\ntypeof a //number\n```\n\n### 不声明直接使用\n\n```JS\na = 123//会在全局作用域中查找有没有a声明，如果没有就添加\nwindow.a === a //true\n\n//严格模式下报ReferenceError\n(function(){\n    \"use strict\"\n    bar = 3 //ReferenceError\n})()\n```\n","tags":["前端"]},{"title":"SPA(single-page application)优缺点分析","url":"/202003/SPAsinglepageapplication优缺点分析/","content":"\n# SPA\n\n将所有的页面局限于一个页面中，仅需要在第一次加载的时候加载相应 HTML,JS,CSS。\n通过 JavaScript 于用户交互来改变页面的内容。\n\n### 优点\n\n1. 用户体验良好，在进行用户交互时不需要刷新页面。\n2. 良好的前后端分离开发模式。前后台使用 Ajax 异步获取数据。\n3. 减轻服务器请求压力。服务器只需要按照相应的 API 给出相应的数据。\n4. 当网站需要适配多终端时，后台不需要做任何修改。\n5. 防爬虫效果更好，由于是动态加载的页面，一般的爬虫只能获取到对应的静态 HTML 结构。\n\n### 缺点\n\n1. SEO（搜索引擎优化）难度高，不便于搜索。\n2. 前进后退管理，SPA 只有一个页面，不便使用浏览器的前进后退功能。\n3. 初次加载数据过大，由于只有一个页面，第一次加载时会加载全部 JS,CSS 文件，容易造成下载缓慢。\n","tags":["前端"]},{"title":"JS工具箱","url":"/202012/JS工具箱/","content":"\n> 该文章不会再更新\n> 目前已迁移至 https://daixiongsheng.github.io/utils/\n\n## url 相关\n\n### 将对象转成 query 串\n\n```JS\n\n/**\n * 将对象转成query串\n * @example object2QueryString({age:123}) => age=123\n * @param o\n */\nfunction object2QueryString(o) {\n    let s = '';\n    Object.keys(o)\n        .forEach(key => {\n            const value = o[key];\n            const type = typeof value;\n            switch (type) {\n                case 'number':\n                    // no NaN\n                    if (value === value) {\n                        s += `${key}=${value}&`;\n                    }\n                    break;\n                case 'object':\n                    if (value !== null) {\n                        s += `${key}=${encodeURIComponent(object2QueryString(value))}&`;\n                    }\n                    break;\n                case 'boolean':\n                    s += `${key}=${value}&`;\n                    break;\n                case 'string':\n                    s += `${key}=${encodeURIComponent(value)}&`;\n                    break;\n                default:\n                    break;\n            }\n        });\n    return s.substr(0, s.length && s.length - 1);\n}\n```\n\n### url 拼接\n\n```JS\n/**\n * 用于处理url参数传递需要手动拼接字符串的问题\n *\n * @param {string} path pathname\n * @param {object} pramsObj 传给url的参数对象\n * @return {string} 返回拼接后的url串\n */\nfunction dealPath(path, pramsObject = {}) {\n    if (!path || path.length === 1 || Object.keys(pramsObject).length === 0) {\n        return path;\n    }\n    if (path[0] !== '/' && !path.includes('//')) {\n        path = `/${path}`;\n    }\n    // 是否已经经过处理\n    const isDealt = path.indexOf('?') !== -1;\n    if (path[path.length - 1] !== '/' && !isDealt) {\n        path = `${path}/`;\n    }\n    path = isDealt ? `${path}&` : `${path}?`;\n    const queryString = object2QueryString(pramsObject);\n    path += queryString ? queryString + '&' : '';\n    return path.substr(0, path.length - 1);\n}\n\n```\n\n### 解析 query 串\n\n```JS\n/**\n *\n * @param queryString {string} 需要解析的url query 串\n * @param decode {boolean} 是否使用encodeURIComponent 进行解码\n * @return {Object}\n */\nfunction query2Obj(queryString = '', decode = false) {\n    if (queryString[0] === '?') {\n        queryString = queryString.slice(1);\n    }\n    const o = Object.create(null);\n    const qArr = queryString.split('&');\n    qArr.forEach(item => {\n        const [k, v] = item.split('=');\n        o[k] = v === void 0 ? '' : decode ? decodeURIComponent(v) : v;\n    });\n    return o;\n}\n```\n\n### 处理参数对象的类型，默认的 url 里面的参数解析后是字符串类型，改方法将进行一些可能类型的转换\n\n```JS\n\n/**\n * 处理参数对象的类型，默认的url里面的参数解析后是字符串类型，改方法将进行一些可能类型的转换\n * @param object\n * @example dealQueryObject({a:'3',b:'4',c:'null'}) => {a:3,b:4,c:null}\n * @return {any}\n */\nfunction dealQueryObject(object) {\n    const o = makeHash();\n    Object.keys(object)\n        .forEach(key => {\n            const value = object[key];\n            switch (value) {\n                case 'null':\n                    o[key] = null;\n                    return;\n                case 'false':\n                    o[key] = false;\n                    return;\n                case 'true':\n                    o[key] = true;\n                    return;\n                case 'undefined':\n                    o[key] = void 0;\n                    return;\n                default:\n                    break;\n            }\n            // value是number\n            if (parseInt(value, 10)\n                .toString() === value) {\n                o[key] = Number(value);\n                return;\n            }\n            try {\n                const result = JSON.parse(value);\n                o[key] = dealQueryObject(result);\n            }\n            catch (e) {\n                o[key] = value;\n            }\n        });\n    return o;\n}\n```\n\n### 解析 URL\n\n```JS\n\n/**\n *\n * @param url {string} url 需要解析的url\n * @param decode {boolean} 是否使用encodeURIComponent 进行解码\n * @example parseUrl('https://a.b.com?a=123&b=456') => {a:'123',b:'456'}\n * @return {Object}\n */\nfunction parseUrl(url = '', decode = false) {\n    const queryString = url.split('?')[1];\n    return query2Obj(queryString, decode);\n}\n```\n\n### 将对象转成 query 串\n\n```JS\n\n/**\n * 将对象转成query串\n * @example object2QueryString({age:123}) => age=123\n * @param o\n */\nfunction object2QueryString(o) {\n    let s = '';\n    Object.keys(o)\n        .forEach(key => {\n            const value = o[key];\n            const type = typeof value;\n            switch (type) {\n                case 'number':\n                    // no NaN\n                    if (value === value) {\n                        s += `${key}=${value}&`;\n                    }\n                    break;\n                case 'object':\n                    if (value !== null) {\n                        s += `${key}=${encodeURIComponent(object2QueryString(value))}&`;\n                    }\n                    break;\n                case 'boolean':\n                    s += `${key}=${value}&`;\n                    break;\n                case 'string':\n                    s += `${key}=${encodeURIComponent(value)}&`;\n                    break;\n                default:\n                    break;\n            }\n        });\n    return s.substr(0, s.length && s.length - 1);\n}\n```\n\n## 类型转换\n\n### 将数字转换成二进制串\n\n```JS\nfunction num2Bin(num) {\n  if (typeof num !== 'number') throw Error(\"param must be a number\")\n  let s = ''\n  while (num > 0) {\n    s = num % 2 + s\n    num = Math.floor(num / 2)\n  }\n  return s\n}\n```\n\n## 对象相关\n\n### 将对象的值为 空串,null,undefined, NaN 进行踢出\n\n```JS\n/**\n * 将对象的值为 空串,null,undefined, NaN 进行踢出\n * @example pureObject({name:'',age:null, a:123,d:undefined,e:NaN}) => {a:123}\n * @param object\n */\nfunction pureObject(object) {\n    const o = makeHash();\n    if (toString(object) === '[object Array]' || typeof object !== 'object' || object === null) {\n        return object;\n    }\n    Object.keys(object)\n        .forEach(key => {\n            const value = object[key];\n            const type = typeof value;\n            switch (type) {\n                case 'boolean':\n                case 'number':\n                    o[key] = value;\n                    break;\n                case 'object':\n                    if (value !== null) {\n                        const v = pureObject(value);\n                        if (Object.keys(v).length) {\n                            o[key] = pureObject(value);\n                        }\n                    }\n                    break;\n                case 'string':\n                    if (value) {\n                        o[key] = value;\n                    }\n                    break;\n                default:\n                    break;\n            }\n        });\n    return o;\n}\n```\n\n### 深拷贝, 解决循环引用\n\n```JS\nfunction deepCopy(obj, map = new Map()) {\n  let copy\n  switch (typeof obj) {\n      case 'undefined':\n        break;\n      case 'number':\n      case 'boolean':\n        copy = obj\n        break;\n      case 'string':\n        copy = obj + ''\n        break;\n      case 'bigint':\n        copy = BigInt(obj)\n        break;\n      case 'object':\n        if (obj === null)\n          copy = null\n        else {\n          const clone = map.get(obj)\n          if (clone) {\n              return clone\n          }\n          // new Boolean,Number 不处理\n          if (Object.prototype.toString.call(obj) === '[object Array]') {\n            const len = obj.length;\n            copy = new Array(len)\n            map.set(obj, copy)\n            for (let i = 0; i < len; i++) {\n              copy[i] = deepCopy(obj[i], map)\n            }\n          }\n          else {\n            copy = {}\n            map.set(obj, copy)\n            for(const k in obj) {\n              obj.hasOwnProperty(k) && (copy[k] = deepCopy(obj[k], map))\n            }\n          }\n        }\n        break;\n      case 'symbol':\n        copy = Symbol(obj.description)\n        break;\n      case 'function':\n        const str = obj.toString()\n        if (!str.includes('native code')) {\n          copy = Function(str)\n        }\n        break\n  }\n  return copy\n}\n```\n\n### 自定义 typeOf\n\n```typescript\n/**\n * 自定义判断类型函数\n *\n * @export\n * @param {*} value\n * @return {*}  {string}\n */\nexport function typeOf(value: any): string {\n  const type = typeof value\n  switch (type) {\n    case 'string':\n    case 'boolean':\n    case 'bigint':\n    case 'number':\n    case 'symbol':\n    case 'function':\n    case 'undefined':\n      /* eslint-disable no-self-compare */\n      if (value !== value) {\n        return 'NaN'\n      }\n      return type\n    case 'object':\n      if (value === null) {\n        return 'null'\n      }\n      if (isObject(value)) {\n        return 'object'\n      }\n      if (Array.isArray(value)) {\n        return 'Array'\n      }\n  }\n  return ''\n}\n```\n\n### 深度比较\n\n```typescript\n/**\n * 深度比较函数，不能比较有循环引用的对象\n *\n * @export\n * @param {*} value\n * @param {*} other\n * @return {*}  {boolean}\n */\nexport function deepEqual(value: any, other: any): boolean {\n  if (value === other) {\n    return true\n  }\n  const typeA = typeOf(value)\n  const typeB = typeOf(other)\n  if (typeA !== typeB) {\n    return false\n  }\n  switch (typeA) {\n    case 'Array':\n      if (value.length !== other.length) {\n        return false\n      }\n      for (let i = 0, len = value.length; i < len; i++) {\n        if (!deepEqual(value[i], other[i])) {\n          return false\n        }\n      }\n      return true\n    case 'object':\n      for (const key of Object.keys(value)) {\n        if (!deepEqual(value[key], other[key])) {\n          return false\n        }\n      }\n      return true\n  }\n  return value === other\n}\n```\n\n### 判断是不是不个有数据的对象\n\n```typescript\n/**\n * 判断是不是一个有内容的对象\n *\n * @export\n * @param {object} value\n * @return {*}  {boolean}\n */\nexport function isValidObject(value: object): boolean {\n  return Object.keys(value).length !== 0\n}\n```\n\n### 洗牌算法（数组乱序算法）\n\n```typescript\n/**\n * 洗牌算法（数组乱序算法）\n * @param {Array} shuffleArray\n * @returns\n */\nexport function shuffle<T = any>(shuffleArray: T[]): T[] {\n  for (let i = shuffleArray.length - 1; i >= 0; i--) {\n    let ri = Math.floor(Math.random() * (i + 1))\n    let temp = shuffleArray[ri]\n    shuffleArray[ri] = shuffleArray[i]\n    shuffleArray[i] = temp\n  }\n  return shuffleArray\n}\n```\n\n### 产生随机数\n\n```typescript\n/**\n * 获取指定范围的随机整数\n * @param lowerValue 最小值\n * @param upperValue 最大值\n */\nexport function getRandomValue(\n  lowerValue: number = 0,\n  upperValue: number = 100\n) {\n  return Math.ceil(Math.random() * (upperValue - lowerValue) + lowerValue)\n}\n```\n\n## DOM，浏览器相关\n\n### 获取 XPath\n\n```JS\nfunction getXPath(element) {\n  if (element === document.body) return '/html/' + element.tagName.toLowerCase();\n  let idx = 1,\n    silibings = element.parentNode.childNodes;\n  for (const e of silibings) {\n    if (e === element)\n      return `${arguments.callee(element.parentNode)}/${element.tagName.toLowerCase()}[${idx}]`\n    else if (e.nodeType === 1 && e.tagName === element.tagName) {\n      idx++\n    }\n  }\n};\n```\n\n### 使元素可以拖动\n\n```JS\nfunction dragAble(obj) {\n  obj.onmousedown = function(event) {\n    obj.setCapture && obj.setCapture();\n    let ol = event.clientX - obj.offsetLeft;\n    let ot = event.clientY - obj.offsetTop;\n\n    event = event || window.event;\n    document.onmousemove = function(event) {\n      event = event || window.event;\n      let left = event.clientX - ol;\n      let top = event.clientY - ot;\n\n      obj.style.position = \"absolute\";\n      obj.style.top = top + \"px\";\n      obj.style.left = left + \"px\";\n    };\n    document.onmouseup = function() {\n      document.onmousemove = null;\n      document.onmouseup = null;\n      obj.releaseCapture && obj.releaseCapture();\n    };\n    return false;\n  };\n}\n```\n\n### 获取鼠标\n\n```JS\nfunction getMose(ele) {\n    let mouse = { x: 0, y: 0 }\n    addEventListener('mousemove', function (event) {\n        let x, y\n        let e = event || window.event\n        if (e.pageX || e.pageY) {\n            x = e.pageX\n            y = e.pageY\n        } else {\n            x = e.clientX + document.body.scrollLeft ||\n                document.documentElement.scrollLeft\n            y = e.clientY + document.body.scrollTop ||\n                document.documentElement.scrollTop\n        }\n        x -= ele.offsetLeft\n        y -= ele.offsetTop\n        mouse.x = x\n        mouse.y = y\n    })\n    return mouse\n}\n```\n\n### 原生 ajax\n\n```JS\nfunction ajax(url, options = {}) {\n    return new Promise((resolve, reject) => {\n        if (typeof url === 'object') {\n            options = null\n            options = url\n            url = options.url + '?t=' + (new Date().getTime())\n        }\n        let xmlHttp\n        if (window.XMLHttpRequest) {\n            xmlHttp = new XMLHttpRequest()\n        }\n        else {\n            xmlHttp = new ActiveXObject(\"Microsoft.XMLHTTP\")\n        }\n        const\n            method = options.method || 'GET',\n            async = true,\n            data = options.data || {},\n            headers = options.headers || {\n                \"Contnet-type\": \"application/x-www-form-urlencoded\"\n            }\n\n        xmlHttp.open(method, url, async)\n        Object.keys(headers).forEach(key => {\n            xmlHttp.setRequestHeader(\n                key,headers[key]\n            )\n        })\n\n        xmlHttp.send(data)\n        xmlHttp.onreadystatechange = function (event) {\n            if (xmlHttp.readyState === 4) {\n                if (xmlHttp.status >= 200 && xmlHttp.status < 300 || xmlHttp.status === 304) {\n                    resolve(xmlHttp)\n                }\n                else {\n                    reject(xmlHttp)\n                }\n            }\n        }\n    })\n}\n\n```\n\n## 剪贴板相关\n\n### 读取剪贴板(需要 API 支持)\n\n```JS\nasync function readClipboard(event) {\n   event.preventDefault();\n   try {\n       const text = await navigator.clipboard.readText();\n       console.log('Pasted content: ', text);\n   } catch (err) {\n      console.error('Failed to read clipboard contents: ', err);\n   }\n}\n```\n\n### 复制到剪贴板\n\n```JS\n// 需要dom调用\nasync function copy2clipboard(e, copyText) {\n   try {\n      await navigator.clipboard.writeText(copyText);\n      console.log(`${copyText} copied to clipboard`);\n   } catch (err) {\n      console.error('Failed to copy: ', err);\n   }\n}\n```\n\n### 复制内容到剪贴板\n\n```JS\nconst copy2clipboard = (text) => {\n    const container = document.body\n    const fakeElem = document.createElement('textarea')\n    fakeElem.style.fontSize = '12px'\n    fakeElem.style.border = '0'\n    fakeElem.style.padding = '0'\n    fakeElem.style.margin = '0'\n    fakeElem.style.position = 'absolute'\n    fakeElem.style.top = '-1000px'\n    fakeElem.style.left = '-1000px'\n    fakeElem.value = text\n    container.appendChild(fakeElem)\n    fakeElem.select()\n    fakeElem.setSelectionRange(0, fakeElem.value.length)\n    document.execCommand('copy')\n    container.removeChild(fakeElem)\n}\n\n```\n\n## 其他\n\n### 返回这一天是周几\n\n```JS\nconst dayOfTheWeek =  (day, month, year) => {\n    // 基姆拉尔森计算公式\n    const arr = [\n        'Monday',\n        'Tuesday',\n        'Wednesday',\n        'Thursday',\n        'Friday',\n        'Saturday',\n        'Sunday',\n    ]\n    if (month < 3) {\n        month += 12\n        --year\n    }\n    // w 为 0-6\n    const w =\n        ((day +\n            2 * month +\n            (3 * (month + 1)) / 5 +\n            year +\n            ((year / 4) >>> 0) -\n            ((year / 100) >>> 0) +\n            ((year / 400) >>> 0) +\n            1) >>>\n            0) %\n        7\n    return arr[w]\n}\n```\n\n### 求根号\n\n```js\nfunction sqrt(m) {\n  if (m === 1) return 1\n  let low = 0,\n    high = m\n  let mid = low + (high - low) / 2\n  while (Math.abs(mid * mid - m) > 1e-9) {\n    let mid2 = mid * mid\n    if (mid2 > m) {\n      high = mid\n    }\n    if (mid2 < m) {\n      low = mid\n    }\n    mid = low + (high - low) / 2\n  }\n  return mid\n}\n```\n\n### 加锁\n\n```JS\nconst Lock = {\n    isLocked(key) {\n        return Boolean(this[`$$${key}`]);\n    },\n    unlock(key) {\n        if (`$$${key}` in this) {\n            delete this[`$$${key}`];\n        }\n    },\n    lock(key) {\n        this[`$$${key}`] = true;\n    }\n};\n```\n\n### 深比较\n\n```TS\nfunction deepEqual(value: any, other: any): boolean {\n    if (value === other) {\n        return true;\n    }\n    const typeA = typeOf(value);\n    const typeB = typeOf(other);\n    if (typeA !== typeB) {\n        return false;\n    }\n    switch (typeA) {\n        case 'array':\n            if (value.length !== other.length) {\n                return false;\n            }\n            for (let i = 0, len = value.length; i < len; i++) {\n                if (!deepEqual(value[i], other[i])) {\n                    return false;\n                }\n            }\n            return true;\n        case 'object':\n            for (const key of Object.keys(value)) {\n                if (!deepEqual(value[key], other[key])) {\n                    return false;\n                }\n            }\n            return true;\n    }\n    return value === other;\n}\n```\n\n### 字节单位转换\n\n```TS\n\n/**\n * 将字节数转成文本形式 1024 --> 1KB\n *\n * @export\n * @param {number} bytes\n * @return {*}  {string}\n */\nfunction byteConvert(bytes: number): string {\n    let ret = '';\n    const symbols = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n    let exp = Math.floor(Math.log(bytes) / Math.log(2));\n    if (exp < 1) {\n        exp = 0;\n    }\n    const i = Math.floor(exp / 10);\n    ret = `${bytes / Math.pow(2, 10 * i)}`;\n\n    if (bytes.toString().length > bytes.toFixed(2).toString().length) {\n        ret = bytes.toFixed(2);\n    }\n    return ret + symbols[i];\n}\n\n/**\n * 1KB -> 1024\n *\n * @export\n * @param {string} size\n * @return {*}  {(number | string)}\n */\nfunction unitConversion(size: string): number {\n    const symbols = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n    const length = parseInt(size as string, 10);\n    const unit = (size as string).substring(length.toString().length).toUpperCase();\n    const index = symbols.findIndex(i => i === unit);\n    return length * Math.pow(2, 10 * index);\n}\n```\n","tags":["前端","tools"]},{"title":"我的常用书签集","url":"/202003/我的常用书签集/","content":"\n# 图片类\n\n## 图片资源\n\n### 图库/灵感\n\n- [Pinterest • The world’s catalog of ideas](https://www.pinterest.com/)\n- [1x - Curated photography](https://1x.com/)\n- [别样网](https://www.ssyer.com/creativity)\n- [UI Space Free PSD, AI, Fonts and more](https://uispace.net/) **UI 类**\n- [Dribbble - 展示和告诉设计师](https://dribbble.com/) **UI 类**\n- [Free stock videos & photos](https://www.pexels.com/)\n- [Free stock videos · Pexels Videos](https://www.pexels.com/videos/) **Videos**\n- [Vimeo](https://vimeo.com/) **Videos MG**\n- [Free Stock Photos - Free Textures and Illustrations Stockvault.net -](http://www.stockvault.net/)\n- [Free Stock Photos & Images - Royalty-Free & CC0 Public Domain Images by Dreamstime](https://www.dreamstime.com/free-photos)\n- [Stock Photos free for commercial use by StockPhotos.io](https://stockphotos.io/)\n- [Free Stock Photos · Search 40+ sites with LibreStock](http://librestock.com/)\n- [Behance](https://www.behance.net/)\n- [花瓣网\\_陪你做生活的设计师](https://huaban.com/)\n- [Unsplash Free High-Resolution Photos](https://unsplash.com/)\n- [Scene360](https://scene360.com/)\n- [Foodiesfeed – Free Food Photos](https://www.foodiesfeed.com/)\n- [首页 - CNU 视觉联盟](http://www.cnu.cc/selectedPage)\n- [Visual Hunt](https://visualhunt.com/)\n- [Getty Images](https://www.gettyimages.com/)\n- [Wallions](https://wallions.com/)\n\n### 图标/ICON\n\n- [Iconfont-阿里巴巴矢量图标库](https://www.iconfont.cn/plus)\n- [IconPng.com 爱看图标网，免费中文图标搜索引擎！](http://www.icontuku.com/)\n- [Preloaders](https://icons8.com/preloaders/)\n- [EASYICON](https://www.easyicon.net/)\n- [加载类图标制作](https://loading.io)\n- [全球 iOS 图标分类展示](http://www.iconsfeed.com/)\n- [Free vector icons - SVG](https://www.flaticon.com/)\n\n### 设计类素材\n\n- [叮当设计 - 分享优秀设计资源 ](http://www.dingdangsheji.com/) **提供 PPT,PSD,XD,Sketch 等**\n- [别样网](https://www.ssyer.com/creativity)\n- [红动中国 - 找设计！上红动](http://www.redocn.com/)\n- [觅元素*设计元素的免费下载网站*免抠素材](http://www.51yuansu.com/)\n- [图鱼 - 100%完美平铺的底纹素材网](http://www.hituyu.com/) **底纹素材**\n- [千图网](http://www.58pic.com/)\n- [千库网](http://588ku.com/)\n- [People dwg CAD blocks free download PIMPMYDRAWING](https://pimpmydrawing.com/) **人物动态**\n- [站酷海洛](https://www.hellorf.com/)\n- [Illustrations unDraw](https://undraw.co/illustrations)\n\n## 图片工具\n\n### 以图搜图\n\n- [百度识图, \"鉴\"你所见](http://image.baidu.com/?fr=shitu)\n- [搜狗图片-上网从搜狗开始](https://pic.sogou.com/)\n- [360 识图](http://st.so.com/)\n- [TinEye Reverse Image Search](https://www.tineye.com/)\n\n### 免费图床\n\n- [Simple Free Image Hosting - SM.MS - Simple Free Image Hosting](https://sm.ms/)\n- [免费多图床\\_share1223](https://share1223.com/free.html)\n- [ImgURL 图床](https://imgurl.org/)\n- [路过图床 - 免费图片上传, 专业图片外链, 免费公共图床](https://imgchr.com/)\n\n### 在线压缩\n\n- [智图*图片压缩在线工具*在线制作 webp](https://zhitu.isux.us/)\n- [TinyPNG](https://tinypng.com/)\n- [在线视频转 GIF](https://convertio.co/zh/video-converter/)\n\n# 工具类\n\n## 临时工具\n\n- 短信验证码\\* [免费接码-免费短信验证码接收平台](https://www.becmd.com/)\n  - [在线短信平台](http://www.z-sms.com/)\n  - [云短信](https://www.pdflibr.com/)\n  - [Receive SMS online for Free - without a Phone or Registration](https://sms-online.co/receive-free-sms)\n- 邮箱验证码\\* [10 分钟邮箱 - BccTo.ME](https://bccto.me/)\n  - [Temp Mail - 临时性 - 匿名电子邮件](https://temp-mail.org/zh/)\n  - [临时邮箱 - 十秒钟内收到邮件](https://www.linshiyouxiang.net/)\n  - [Moakt Email 临时邮箱专业服务](https://www.moakt.com/zh/mail)\n\n## 其他工具\n\n- [MikuTools - 工具集合](https://miku.tools/) **网页版本瑞士军刀**\n- [微信公众号格式化编辑器](https://lab.lyric.im/wxformat/)\n- [Markdown 转微信公众号工具](http://blog.didispace.com/tools/online-markdown/)\n- [Javascript 在线美化，格式化](http://www.css88.com/tool/js_beautify/)\n- [在线前端编程 JS Bin](http://jsbin.com/)\n- [你注册过哪些网站？一搜便知 ](https://reg007.com/)\n- [iShadow](http://ss.ishadowx.com/)\n- [The W3C Markup Validation Service](http://validator.w3.org/)\n- [Netcraft Internet Research, Anti-Phishing and PCI Security Services](https://www.netcraft.com/) **网站后台分析**\n- [永硕 E 盘](http://dnlt.ys168.com/) **小的网盘**\n- [Greasy Fork - 安全、有用的用户脚本大全](https://greasyfork.org/zh-CN/)\n- [在线编码转换](http://tool.oschina.net/encode?type=4)\n- [在线工具 - 程序员的工具箱](https://tool.lu/)\n- [西刺免费代理 IP](https://www.xicidaili.com/)\n- [动物声音](http://www.yisell.com/search.htm?c=7)\n- [免费在线作图](https://www.processon.com/)\n- [MaHua 在线 markdown 编辑器](https://mahua.jser.me/)\n- [DB-Engines Ranking](https://db-engines.com/en/ranking)\n- [My Brand New Logo](https://mybrandnewlogo.com/)\n- [在线 markdown 图表设计](https://mermaidjs.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoiZ3JhcGggVERcbkFbQ2hyaXN0bWFzXSAtLT58R2V0IG1vbmV5fCBCKEdvIHNob3BwaW5nKVxuQiAtLT4gQ3tMZXQgbWUgdGhpbmt9XG5DIC0tPnxPbmV8IERbTGFwdG9wXVxuQyAtLT58VHdvfCBFW2lQaG9uZV1cbkMgLS0-fFRocmVlfCBGW2ZhOmZhLWNhciBDYXJdXG4iLCJtZXJtYWlkIjp7InRoZW1lIjoiZGVmYXVsdCJ9fQ)\n- [在线中文转拼音、注音工具\\_蛙蛙在线工具](https://www.iamwawa.cn/pinyin.html)\n- [巧笔在线 - 书同文汉字网](https://hanzi.unihan.com.cn/Qpen)\n- [五笔怎么打\\_五笔拆分图解-五笔查询系统](https://www.52wubi.com/wbbmcx/search.php)\n- [convert anything to anything - CloudConvert](https://cloudconvert.com/)\n- [在线数学题目解答](https://www.mathway.com/zh/Calculus)\n- [Blobmaker](https://www.blobmaker.app/)\n- [大数据导航](http://hao.199it.com/)\n- [专业的移动开发者数据分析平台](https://aso114.com/)\n- [中国 App Store 排行榜](https://www.qimai.cn/rank/index)\n\n# 教程资源\n\n## 设计类\n\n- [飞特网-设计，从飞特开始 - 飞特(FEVTE)](https://www.fevte.com/)\n- [优设-UISDC: 优秀设计联盟-SDC-优设网-设计师交流学习平台-听讲座，聊设计，找素材，尽在优设网](https://www.uisdc.com/)\n- [设计订阅 - 腾讯设计导航](http://idesign.qq.com/#!index/feed)\n- [设计本](http://www.shejiben.com/)\n- [学 UI 网—UI 设计师学习教程平台](http://www.xueui.cn/)\n- [UIKit－uikit 下载](http://www.uikit.me/)\n- [UI Movement ](https://www.uimovement.com/)\n\n## 计算机类\n\n- [莫烦 Python](https://morvanzhou.github.io) python+ 机器学习 + 各种框架\n- [QSCTech/zju-icicles: 浙江大学课程攻略共享计划](https://github.com/QSCTech/zju-icicles)\n- [GitHub - justjavac/free-programming-books-zh_CN: 免费的计算机编程类中文书籍，欢迎投稿](https://github.com/justjavac/free-programming-books-zh_CN#cc)\n- [CoolPhilChen/SJTU-Courses: 上海交通大学课程资料分享](https://github.com/CoolPhilChen/SJTU-Courses)\n- [lib-pku/libpku: 贵校课程资料民间整理](https://github.com/lib-pku/libpku)\n- [USTC-Resource/USTC-Course: 中国科学技术大学课程资源](https://github.com/USTC-Resource/USTC-Course)\n- [toddmotto/public-apis: A collective list of free APIs for use in software and web development.](https://github.com/toddmotto/public-apis)\n- [menhuan/awesome-java-cn: Java 资源大全中文版，包括开发库、开发工具、网站、博客、微信、微博等，由伯乐在线持续更新。](https://github.com/menhuan/awesome-java-cn)\n- [weiaicunzai/awesome-image-classification: A curated list of deep learning image classification papers and codes](https://github.com/weiaicunzai/awesome-image-classification)\n- [mrgloom/awesome-semantic-segmentation: awesome-semantic-segmentation 图像分割](https://github.com/mrgloom/awesome-semantic-segmentation)\n- [amusi/TensorFlow-From-Zero-To-One: 记录自己学习 TensorFlow 的笔记和代码](https://github.com/amusi/TensorFlow-From-Zero-To-One)\n- [stephentian/33-js-concepts: 每个 JavaScript 工程师都应懂的 33 个概念 @leonardomso](https://github.com/stephentian/33-js-concepts)\n- [3dgen/cppwasm-book: 《C/C++面向 WebAssembly 编程》——Emscripten 工程实践](https://github.com/3dgen/cppwasm-book)\n- [satwikkansal/wtfpython: A collection of surprising Python snippets and lesser-known features.](https://github.com/satwikkansal/wtfpython)\n- [libpku - 贵校课程资料民间整理](https://lib-pku.github.io/)\n- [Free Programming Books – GoalKicker.com](https://goalkicker.com/)\n\n# 社区\n\n- [原创源码库\\_专注个人开源程序软件开发](http://www.chtml.cn/)\n- [文俊 IT 社区 zuowenjun.cn](http://www.zuowenjun.cn/?from=cnblogs.com)\n- [发现 · 语雀](https://yuque.com/explore/headlines)\n- [Hacker News](https://news.ycombinator.com/)\n- [文章 - 伯乐在线](http://blog.jobbole.com/)\n- [印记中文 - 深入挖掘国外前端新领域](https://docschina.org/)\n- [看雪安全论坛](https://bbs.pediy.com/)\n- [红黑联盟读书频道\\_IT 技术图书在线阅读](https://book.2cto.com/)\n- [吾爱破解](https://www.52pojie.cn/)\n- [首页 - 中国红客联盟](http://www.cnhonkerarmy.com/portal.php)\n\n# OJ 平台\n\n- [LeetCode](https://leetcode.com/)\n- [51Nod](https://www.51nod.com/focus.html)\n- [Codeforces](http://codeforces.com/problemset)\n- [ Virtual Judge](https://vjudge.net/problem)\n- [PAT](https://www.patest.cn/contests/pat-a-practise/)\n- [ PKU OJ](http://poj.org/)\n","tags":["tools"]},{"title":"C 和 C++中的 const","url":"/202003/C和C中的const/","content":"\n### const 必须初始化\n\n### const 作用\n\n1.修饰变量，说明该变量值不可以被改变 2.修饰指针，分为指向常量的指针和指针常量；3.常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改（严格来说并不存在常量引用，因为引用不是一个对象）4.修饰成员函数，说明该成员函数内不能修改成员变量。\n\n## C 中 const\n\n### 严格来说 C 中的 const 是假的 const\n\n```\n//常量 a 不能改变\nconst int a = 12;\na=18;    //错误\nint *p1 = &a;//c中普通指针可以指向常量\n\nprintf(\"a:%d\\n\", a);  //12\n//间接修改a的值\n*p1 = 13;\nprintf(\"a:%d\\n\", a);  //13\n\n// c中的const 是伪const\n\nint b = 16;\n\n\n//指向常量的指针 p3指向地址的内容不能变\nconst int * p2 = &b;\n*p2 = &b;    //错误，编译不通过，指向地址的内容不能变\np2 = &a;    //可以，改变指向的地址\n//类似。可以使用2级指针改变p2的指向地址的内容\n//so c中的const 是伪const\n\nint * const p3 = &b;     //指针常量 p2 不能改变指向的地址\n*p3 = 18;    //可以，改变指向地址的内容\np3 = &b;    //错误，编译不通过，不能改变指向的地址\n\n//类似。可以使用2级指针改变p3的指向的地址\n//SO  c中的const 是伪const\n```\n\n### SO c 中的 const 是伪 const\n\n## C++ 中 const\n\n```\n//初始化\nconst int a =12;\nconst int b = a;\nint c =13;\nconst int d = c;\nconst int e = sizeof(a);\nconst int f = get_size();\n\na = 18;    //错误,常量不可变\n\n//错误,a是常量，只能使用常量指针指向和C不用\nint *p2 = &a;\n\n//OK 使用常量指针指向\nconst int * p3 = &a;\n\n//错误,这是一个常量指针\nint * const p4 = &a;\n\n//ok  指向常量的常量指针，指针本身和指向地址的内容都不可变\nconst int * const p5 = &a;\n\n```\n\n### 常量引用\n\n- 经常用于形参类型\n\n```\n//常量引用，严格来说C++并不存在常量引用，因为引用不是一个对象\nconst int &aa = a;\naa++;    //错误，不能改变\n\n//用于形参类型\n//减少参数传递过程中的变量的拷贝\n\nint add(const int &a, const int &b)\n{\n    return a+b;\n}\n```\n\n### 修饰成员函数\n\n```\nclass A\n{\npublic:\n    int a = 12;\n    int b = 13;\n    int  modify_a() const\n    {\n        this->a = 18;//错误，const 函数不能对成员进行修改\n        this->b = 20;//ok    mutable  修饰的成员不受const函数的限定。\n    }\n    int  modify_b() const\n    {\n        this->a = 18;//错误，const 函数不能对成员进行修改\n    }\n\n    int const  modify_c()    const 修饰的是函数的返回值为const\n    {\n        this->a = 18;//OK\n        this->b = 18;//OK\n    }\n\n};\n```\n\n### 顶层 const,底层 const\n\n- 顶层 const 表示指针本身是个常量，它的**值（指向的地址）**不能变。•底层 const 表示指针指向的是常量，它**指向的地址空间的值**不能变。\n\n### constexpr 变量\n\n- 申明为 constexpr 的变量一定是一个常量， 在编译期间就能得到的值。\n\n---\n","tags":["C++"]},{"title":"Vue Router / React Router 两种模式","url":"/202003/VueRouterReactRouter两种模式/","content":"\n# Vue Router / React Router 两种模式\n\nvue: history & hash\n\nreact: BrowserRouter & HashRouter\n\n这两种模式在 `react` 与 `vue` 中表达方式不同，但表现形式是一样的\n\n**history** : 对应 url 表现为 `http://abc.example.com/aa/bb/cc/dd ` 但需要后台服务软件配置，不然刷新时会出现 404\n原理： `popstate` 事件\n在 `history.back` `history.forward` `history.go`会触发\n\n**hash** : 对应 url 表现为 `http://abc.example.com/#/aa/bb/cc/dd`\n原理： `onhashchange` 事件\n","tags":["前端"]},{"title":"React 基础","url":"/202002/React/","content":"\n# JSX\n\n#### 一句话理解\n\n- `JSX` 即在 `JS` 里面写 `HTML` 代码，并且在 `JSX` 中使用{}包裹的内容会被认定为 `JS` 代码\n  - `const j = <h1> hello { console.log(\"world\") } </h1> ` 渲染后页面显示 `hello` 控制台打包 ` world`\n- **实际上，JSX 仅仅只是`React.createElement(component, props, ...children)` 函数的语法糖**\n\n```jsx\n;<button className=\"btn\">Click Me</button>\n//上面会被编译成下面形式\n\nReact.createElement('button', { className: 'btn' }, 'Click Me')\n```\n\n- **这也是为什么即使我们没有用到 React 也需要导入**\n\n```jsx\nimport React, { Component } from 'react'\n```\n\n# Hello World\n\n```react\nReactDOM.render(\n  <h1>Hello, world!</h1>,\n  document.getElementById('root')\n);\n```\n\n# 组件\n\n### 函数式\n\n```react\n//定义一个函数式组件 App，返回JSX UI\nfunction App(props) {\n  return <h2>function component</h2>\n}\nReactDOM.render(<App />, document.getElementById('root'))\n```\n\n### 类继承式\n\n```react\n//继承React.Component，render方法返回JSX UI\nclass App extends React.Component {\n  render() {\n    return (\n      <h2>class component</h2>\n    )\n  }\n}\nReactDOM.render(<App />, document.getElementById('root'))\n```\n\n### Props\n\n- 当需要向组件传递参数时可使用 Props\n\n#### 函数式组件 Props & 对 Props 进行类型限定 & defaultProps\n\n```react\n//函数式组件接收一个props参数\nfunction App(props) {\n  return <h2>function component and {props.name}  {props.msg}</h2>\n}\n\n//对传入组件的props进行类型限定\n//需要安装prop-types  //npm i prop-types 或者引入<script src=\"prop-types.js\"></script>\nApp.propTypes = {\n    name: PropTypes.string.isRequired //规定name为stirng类型且是必须的\n}\n//设置默认name为hello，当使用默认props，同名属性会使propTypes的isRequired无效，但类型检测依然有效\nApp.defaultProps = {\n    msg: \"hello\",\n}\n\nReactDOM.render(<App name=\"app\" />, document.getElementById('root'))\n```\n\n#### 类组件 Props & 对 Props 进行类型限定 & defaultProps\n\n```react\nclass App extends React.Component {\n  static propTypes = {\n    name: PropTypes.string.isRequired\n  }\n\n  static defaultProps = {\n    msg: \"hello world\"\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>{this.props.name}</h1>\n        <h2>{this.props.msg}</h2>\n      </div>\n    )\n  }\n}\nReactDOM.render(<App name=\"app\" />, document.getElementById('root'))\n```\n\n### state 管理组件内部数据\n\n```react\nclass App extends React.Component {\n  state = {date: new Date()};\n\t//或者下面这种形式在构造函数中定义state\n\tconstructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n  render() {\n    return (\n      <div>\n        <h1>{this.state.date.toDateString()}</h1>\n      </div>\n    )\n  }\n}\nReactDOM.render(<App/>, document.getElementById('root'))\n\n```\n\n### 组件生命周期\n\n![Clipboard20200225.png](https://img.hacpai.com/file/2020/02/Clipboard20200225-b3db5da5.png)\n\n# 事件处理\n\n- react 中事件采取小驼峰式\n\n```JSX\nfunction App extends React.Component {\n  constructor(props)  {\n    super(props)\n\n    //这里对于类声明式组件中的实例方法必须显示绑定this\n    //也可以使用ES6的箭头函数免去手动绑定\n    // this.handleClick = this.handleClick.bind(this)\n  }\n\n  handleClick = (e) => {\n    e.preventDefault();//必须显示阻止默认行为,不能return false;\n    console.log('The link was clicked.');\n  }\n\n  return (\n    <a href=\"#\" onClick={handleClick}>\n      Click me\n    </a>\n  )\n}\n```\n\n# 组件通信\n\n### props\n\n父组件传递给子组件的 props 对于子组件来说是只读的，我们不能在子组件中修改 props 中数据的值，而子组件中的 state 又是子组件特有的，父组件不能访问，当需要在子组件对父组件的数据进行修改时，可以通过让父组件传递一个用于修改父组件数据的接口函数供子组件调用\n\n用 `React` 官方的语言来讲就是状态提升，当一个数据的状态是需要**父子组件共同管理**时，将该状态置于父组件的**state**中\n\n当然如果我们需要访问子组件的 `state` 数据时可以给子组件添加 `ref`,再在父组件的 `refs` 中找到对应的 `ref` 并修改，但是不建议这么使用。我们在进行修改数据时最好通过数据的寄主组件修改。\n\n### 消息订阅与发布\n\n- `npm i pubsub-js`\n- 同一消息的发布可以有多个订阅者\n\n#### 发布消息\n\n```jsx\nPubSub.publish('update', data)\n```\n\n#### 订阅消息\n\n```jsx\nPubSub.subscribe('update', (msg, data) => {})\n```\n\n### Context\n\n当一个组件树需要共享数据的时候，可以使用 Context\n\n1. 定义 Context\n\n```jsx\nexport const UserNameContext = React.createContext('Alia') //给定一个默认值可以是对象，数组等\n```\n\n2. 在需要使用的组件树的根组件中导入并使用\n\n```jsx\nimport React, { Component } from 'react'\nimport TodoList from './views/todolist/todolist'\nimport { UserNameContext } from './context-types'\n\nexport default class App extends Component {\n  static state = {}\n  render() {\n    //给定值\n    return (\n      <UserNameContext.Provider value=\"None\">\n        <TodoList />\n      </UserNameContext.Provider>\n    )\n  }\n}\n```\n\n3. 当需要在一个子组件中使用这个全局共享数据时，在该组件内声明 `contextType` 并使用\n\n```JSX\nimport React, {Component} from 'react'\nimport {UserNameContext} from '../../context-types'\nexport default class Item extends Component {\n  static contextType = UserNameContext;\n  render() {\n      return (\n        <div>\n          {/*需要定义contextType*/}\n          <h1>{this.context}</h1>\n\n          {/*也可以根据context来动态处理，这种方式不需要定义contextType*/}\n          <UserNameContext.Consumer>\n            {value=>console.log(value)}\n          </UserNameContext.Consumer>\n        </div>\n      )\n  }\n}\n```\n\n### 多个 context\n\n多个 context 可以嵌套使用\n\n# 高阶组件 HOC(Higher-Order Components])\n\n#### 组件\n\n- 将 props 转换成 UI\n\n#### 高阶组件\n\n- 将组件转成组件\n- 解决代码复用（以前使用 mixins ,Vue 中现在的 mixins ）\n- HOC 中不会修改传入的组件\n- 典型的例子**react-redux**中的 connect 就是一个 HOC\n- 两种用法\n  - 包裹组件\n  - 继承组件\n\n# 非受控组件 受控组件\n\n- 受控组件中，表单数据是由 React 组件来管理\n\n```jsx\n<input type=\"text\" value={this.state.value} onChange={this.handleChange} />\n```\n\n- 非受控组件，表单数据将交由 DOM 节点来处理\n\n```jsx\n<input type=\"text\" ref={(input) => (this.input = input)} />\n```\n\n# Hook\n\n- 它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。\n- 仅仅适用于 function component\n\n#### useState\n\n- 该 Hook 传入一个默认值参数，返回一个数组，数组第一个为该数据的 state ，第二个为修改这个 state 的接口函数\n\n```jsx\nimport React, { useState } from 'react'\n\nfunction Example() {\n  // 声明一个叫 \"count\" 的 state 变量\n  const [count, setCount] = useState(0)\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  )\n}\n```\n\n#### Effect Hook\n\n- `useEffect` 第一个参数接收一个函数 A 参数，当 React 组件在渲染后调用 A 函数，A 函数也可以返回一个 B 函数，返回的 B 函数会在 A 执行之前执行\n- `useEffect` 第二个参数接收一个数组，数组元素为 state 变量，当这些 state 变量有一个变化时才执行\n- `useMemo`：用于缓存一些不变的数\n- `useCallback`： useMeme 第一个参数返回函数的简写\n- `useReducer`\n- `useContext`\n\n# react-router (5.x)\n\n- Router\n  - BrowserRouter\n  - HahRouter\n- Link\n  - NavLink\n    - activeClassName\n    - activeStyle\n    - to\n\n```jsx\n<NavLink\n  to={{\n    pathname: \"/home/list/3\",\n\t\tsearch: \"page=1&limit=10&skip=12\",\n\t\tstate: {\n\t\t\tmsg: \"hello to\"\n    },\n\t\thash: \"Hash\"\n  }}\n  >\n  Home\n</NavLink>\n//对应url : /home/list/3?page=1&limit=10&skip=12#Hash\n\n<NavLink to=\"/about\">about</NavLink>\n//对应url : /about\n\n```\n\n- Switch\n- Route\n\n```JSX\n<Switch>\n  <Route path=\"/about\" children={<Child />} />\n  <Route path=\"/home/list/:id\" children={<Child />} />\n</Switch>\n```\n\n- Redirect\n- useParams\n- useRouteMatch\n- useHistory\n- useLocation\n\n```jsx\n<NavLink\n  to={{\n    pathname: \"/home/list/3\",\n\t\tsearch: \"page=1&limit=10&skip=12\",\n\t\tstate: {\n\t\t\tmsg: \"hello to\"\n\t\t},\n\t\thash: \"Hash\"\n  }}\n  >\n  Home\n</NavLink>\n\nuseParams:{\"id\":\"home\"}\nuseRouteMatch:{\"path\":\"/:id\",\"url\":\"/home\",\"isExact\":false,\"params\":{\"id\":\"home\"}}\nuseHistory:{\"length\":50,\"action\":\"PUSH\",\"location\":{\"pathname\":\"/home/list\",\"search\":\"?page=1&limit=10&skip=12\",\"state\":{\"msg\":\"hello to\"},\"hash\":\"#Hash\",\"keyLength\":12,\"key\":\"fl1wj6\"}}\nuseLocation:{\"pathname\":\"/home/list\",\"search\":\"?page=1&limit=10&skip=12\",\"state\":{\"msg\":\"hello to\"},\"hash\":\"#Hash\",\"keyLength\":12,\"key\":\"fl1wj6\"}\n```\n","tags":["前端"]},{"title":"前端测试框架 mocha+断语库 chai+vue 单元测试","url":"/202002/前端测试框架mocha断语库chaivue单元测试/","content":"\n# Mocha\n\n#### 前端单元测试框架\n\n> https://mochajs.cn/\n\n- example\n\n```typescript\nconst assert = require('assert')\nconst add = (a: number, b: number): number => a + b\n\ndescribe('test function add', function () {\n  it('should return the sum of `a` and `b`', () => {\n    assert.equal(add(1, 2), 3) //使用node提供的断言\n  })\n})\n\n/*\n  test function add\n    √ should return the sum of `a` and `b`\n*/\n```\n\n# Chai\n\n#### 一个断言库\n\n> https://www.chaijs.com/\n\n- 通常的 mocha 框架一起使用\n- should\n\n```typescript\nimport { expect, assert } from 'chai'\nconst should = require('chai').should()\n\nconst str = 'hello world'\n\nit('test should', () => {\n  str.should.be.a('string')\n  str.should.contain('hello')\n})\n\n/*\n\t  √ test should\n*/\n```\n\n- expect\n\n```typescript\nimport { expect, assert } from 'chai'\nconst should = require('chai').should()\n\nconst stringify = (obj: any) => {\n  const arr = []\n  for (let key in obj) {\n    arr.push(`${key}=${obj[key]}`)\n  }\n  return arr.join('&')\n}\n\nit('测试stringify obj-->jsonstr', () => {\n  expect(stringify({ name: 'Aila', age: 23, help: '&aa&;' })).to.be.equal(\n    'name=Aila&age=23&help=&aa&;'\n  )\n})\n\n/*\n\t√ 测试stringify obj-->jsonstr\n*/\n```\n\n- assert\n\n```typescript\nimport { expect, assert } from 'chai'\nconst should = require('chai').should()\n\nconst substring = (str: string, index: number): string => str.slice(index)\n\ndescribe('test function add', function () {\n  it('should return the substring of `str', () => {\n    assert.equal(substring('hello world', 6), 'world1')\n  })\n})\n\n/*\n  1) test function add\n       should return the substring of `str:\n\n      AssertionError: expected 'world' to equal 'world1'\n      + expected - actual\n\n*/\n```\n\n# Vue 单元测试\n\n- `@vue/test-utils`\n\n```vue\n<!--HelloWorld.vue-->\n\n<template>\n  <div class=\"hello\">\n    <h1 id=\"m\">{{ msg }}</h1>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'HelloWorld',\n  props: {\n    msg: String,\n  },\n}\n</script>\n\n<style scoped></style>\n```\n\n```typescript\n// HelloWorld.vue.spec.ts\n\nimport HelloWorld from '@/components/HelloWorld.vue'\nimport Vue from 'vue'\nimport { expect } from 'chai'\nimport { mount } from '@vue/test-utils'\n\ndescribe('HelloWorld.vue', () => {\n  it('原生自己测试vue 传递属性能否正常显示', () => {\n    //原生自己测试vue\n    const Constructor = Vue.extend(HelloWorld)\n    const vm = new Constructor({\n      propsData: { msg: 'hello world' },\n    }).$mount()\n    expect(vm.$el.querySelector('h1')?.innerHTML).to.be.eq('hello world')\n  })\n})\ndescribe('HelloWorld.vue', () => {\n  it('通过 @vue/test-utils 测试 传递属性能否正常显示', () => {\n    const wrapper = mount(HelloWorld, {\n      propsData: { msg: 'hello' },\n    })\n    expect(wrapper.get('h1').text()).to.be.eq('hello world')\n  })\n})\n```\n\n- 结果\n\n```\n  HelloWorld.vue\n    √ 原生自己测试vue 传递属性能否正常显示\n\n  HelloWorld.vue\n    1) 通过 @vue/test-utils 测试 传递属性能否正常显示\n\n\n  1 passing (82ms)\n  1 failing\n\n  1) HelloWorld.vue\n       通过 @vue/test-utils 测试 传递属性能否正常显示:\n\n      AssertionError: expected 'hello' to equal 'hello world'\n      + expected - actual\n\n      -hello\n      +hello world\n\n```\n","tags":["前端"]},{"title":"前端常用库、框架","url":"/202002/前端常用库框架/","content":"\n# Vue.js\n\n> 渐进式 JavaScript 框架\n> https://cn.vuejs.org/\n\n1.x 由个人开发者**尤雨溪**开发\n2.x..已经发展为团队\n\n目前最火（关注多）\n\n# React\n\n> 用于构建用户界面的 JavaScript 库\n> https://react.docschina.org/\n\n一般我们还是叫做框架\n\n2013 年由**Facebook**开源\n\n目前最流行（使用多）\n\n# Angular\n\n> 一套框架，多种平台 移动端 & 桌面端\n> https://angular.cn/\n\n1.x 的版本叫 AngularJs\n2.x 以后称 Angular\n\ngoogle 开源的\n\n# Bootstrap\n\n- Bootstrap 目前流行有两个版本\n\n[Bootstrap3](https://www.bootcss.com/)\n\n[Bootstrap4](https://getbootstrap.net/)\n\n### v3 和 v4 的区别\n\n#### 3\n\n- 使用 Less\n- pc 端多\n\n#### 4\n\n- 使用 Sass\n- flex 布局\n- 移动设备优先\n\n# Font Awesome\n\n> 一套绝佳的图标字体库和 CSS 框架\n> http://fontawesome.dashgame.com/\n> 4.1.0 开始不再支持 IE7\n\n# Animate.css\n\n一个 CSS3 动画库\nhttps://daneden.github.io/animate.css/\n\n# MUI\n\n> https://dev.dcloud.net.cn/mui/\n> 最接近原生 APP 体验的高性能前端框架\n\n# View UI\n\n> 一套基于 Vue.js 的高质量 UI 组件库\n> https://www.iviewui.com/\n\n# Vant\n\n> 轻量、可靠的移动端 Vue 组件库\n> https://youzan.github.io/vant/#/zh-CN/\n\n# Element\n\n> Element，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库\n> https://element.eleme.cn/#/zh-CN\n\n# Layui\n\n> 经典模块化前端框架\n> https://www.layui.com/\n\n# Jquery\n\n> https://www.Jquery.com/\n\n# UIkit\n\n> http://www.getuikit.net/\n> 一个轻量级的模块化前端框架， 用于快速开发强大的 Web 界面。\n\n# Weex\n\n> 编写跨平台应用\n> https://weex.apache.org/zh/guide/\n> 阿里家的，于 2017-02-24 迁移至 Apache 基金会\n\n# Mint UI\n\n> 基于 Vue.js 的移动端组件库\n> https://mint-ui.github.io/#!/zh-cn\n\n# uni-app\n\n> https://uniapp.dcloud.io/ > `uni-app` 是一个使用 [Vue.js](https://vuejs.org/) 开发所有前端应用的框架\n\n# React Native\n\n> 使用 JavaScript 和 React 编写原生移动应用\n> https://reactnative.cn/\n\n# Flutter\n\n> 谷歌的移动 UI 框架\n> https://flutterchina.club/\n> 需要学习 dart\n\n# Chart.js\n\n> http://chartjs.cn/\n> 基于 HTML5 的 JavaScript 图表库\n\n# ECharts\n\n> https://www.echartsjs.com/zh/index.html\n> 使用 JavaScript 实现的开源可视化库\n\n百度的\n\n# Highcharts\n\n> https://www.highcharts.com.cn/\n> 一个用纯 JavaScript 编写的一个图表库\n> 在个人网站、学校网站及非盈利机构中使用 Highcharts 完全不需要经过我们的许可，直接可以任意使用！\n\n**商用要钱的**\n\n# C3.js\n\n> https://c3js.org/\n> D3-based reusable chart library\n\n# D3.js\n\n> https://d3js.org/\n> 数据驱动的文档\n","tags":["前端"]},{"title":"在网页中使用摄像头和共享屏幕","url":"/202002/在网页中使用摄像头和共享屏幕/","content":"\n```\n<div>\n  <button id=\"shareCameraBtn\">开启摄像头</button>\n  <button id=\"shareScreenBtn\">开启屏幕分享</button>\n  <button id=\"photoBtn\">拍照</button>\n</div>\n<div>\n  <video id=\"share\" autoplay=\"autoplay\"></video>\n  <canvas id=\"photo\"></canvas>\n</div>\n<script>\n  var witdh = 900,\n    height = 600\n\n  function getElement(sel) {\n    return document.querySelector(sel)\n  }\n\n  var share = getElement('#share')\n  var shareCameraBtn = getElement('#shareCameraBtn')\n  var shareScreenBtn = getElement('#shareScreenBtn')\n  var photoBtn = getElement('#photoBtn')\n  var photo = getElement('#photo')\n\n  function setWH(obj) {\n    obj.style.width = witdh + 'px';\n    obj.style.height = height + 'px';\n  }\n\n  setWH(share)\n  setWH(photo)\n\n\n  shareCameraBtn.onclick = function () {\n    getMedia(true)\n  }\n  shareScreenBtn.onclick = function () {\n    getMedia(false)\n  }\n\n  photoBtn.onclick = function () {\n    photo.getContext('2d').drawImage(share, 0, 0);\n  }\n\n  function getMedia(camera) {\n    var mediaDevices = (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) ?\n      navigator.mediaDevices : ((navigator.mozGetUserMedia || navigator.webkitGetUserMedia) ? {\n        getUserMedia: function (c) {\n          return new Promise(function (y, n) {\n            (navigator.mozGetUserMedia ||\n              navigator.webkitGetUserMedia).call(navigator, c, y, n);\n          });\n        }\n      } : null);\n    var op = {\n      video: {\n        width: witdh,\n        height: height\n      },\n      audio: true\n    }\n    var media = camera ? mediaDevices.getUserMedia(op) : mediaDevices.getDisplayMedia(op)\n\n    media.then(function (MediaStream) {\n      /* 使用这个MediaStream */\n      share.srcObject = MediaStream;\n      share.play();\n    }).catch(function (err) {\n      console.log(err); // 拒签\n    });\n  }\n\n</script>\n```\n","tags":["tools"]},{"title":"Gulp","url":"/202002/Gulp/","content":"\n# Gulp\n\n一个前端自动化工具，和 grunt 类似，使用的是流(stream)的方式，构建时会将文件**加载到内存**再进行进一步操作，可以异步构建\n\n#### 相关插件\n\n- gulp-autoprefixer 添加浏览器 CSS3 前缀\n- gulp-clean-css 压缩 CSS\n- gulp-uglify 压缩 js\n- gulp-rename 重命名\n- gulp-livereload 实时更新\n- gulp-connect 启动 server\n- gulp-clean-dest 文件清理\n- gulp-htmlmin HTML 压缩\n\n### 配置\n\n```\nconst {src, dest, parallel, task, series} = require('gulp');\nconst gulp = require('gulp');\nconst uglify = require('gulp-uglify');\nconst rename = require('gulp-rename');\nconst concat = require('gulp-concat');\nconst htmlmin = require('gulp-htmlmin');\nconst cleanDest = require('gulp-clean-dest');\nconst cleanCss = require('gulp-clean-css');\nconst gulpCopy = require('gulp-copy');\nconst connect = require('gulp-connect')\nconst livereload = require('gulp-livereload')\n\n\nfunction watch() {\n  livereload.listen({}, server)\n  gulp.watch('gulpfile.js', series(clean, copy, js, css, html))\n  gulp.watch('src/**/*.js', parallel(js))\n  gulp.watch('src/**/*.css', parallel(css))\n  gulp.watch('src/**/*.html', parallel(html))\n\n}\n\nfunction server() {\n  connect.server({\n    root: 'build',\n    port: 8000,\n    livereload: true\n  })\n}\n\nfunction clean() {\n  return src('build/**',)\n    .pipe(cleanDest('build', {extension: ''}))\n\n}\n\nfunction copy() {\n  return src('src/*.png',)\n    .pipe(gulpCopy('', {}))\n    .pipe(dest('build'))\n\n}\n\nfunction html() {\n  return src('src/**/*.html')\n    .pipe(htmlmin({collapseWhitespace: true}))   //去除空格\n    .pipe(dest('build/'))\n    .pipe(livereload())\n    .pipe(connect.reload())\n}\n\n\nfunction css() {\n  return src('src/**/*.css')\n    .pipe(concat('main.css'))\n    .pipe(cleanCss())\n    .pipe(dest('build/'))\n    .pipe(livereload())\n    .pipe(connect.reload())\n}\n\n\nfunction js() {\n  return src('src/**/*.js')\n    .pipe(concat('main.js'))\n    .pipe(uglify())\n    .pipe(rename({suffix: '.min'}))\n    .pipe(dest('build/'))\n    .pipe(livereload())\n    .pipe(connect.reload())\n}\n\ntask('clean', clean)\ntask('copy', copy)\ntask('watch', watch)\ntask('js', js)\ntask('css', css)\ntask('html', html)\ntask('server', series(watch, server))\n\nexports.default = series(clean, parallel(copy, html, js, css));\n\n```\n","tags":["前端"]},{"title":"Grunt","url":"/202002/Grunt/","content":"\n# Grunt\n\n- 前端自动化构建工具，压缩，合并自动化处理，适合小项目使用\n- 相关文档\n\n[GitHub](https://github.com/gruntjs)\n\n### 三步\n\n1. 初始化配置\n2. 加载插件\n3. 注册任务\n\n## 初始化配置\n\n```\n\nmodule.exports =function (grunt)  {\n\n   grunt.initConfig({\n\t...\n\t...\n\t...\n   })\n}\n\n```\n\n## 加载插件\n\n#### 常用插件\n\n```\n  ...\n  ...\n  ...\n  grunt.loadNpmTasks('grunt-contrib-clean');\n  grunt.loadNpmTasks('grunt-contrib-concat');\n  grunt.loadNpmTasks('grunt-contrib-connect');\n  grunt.loadNpmTasks('grunt-contrib-copy');\n  grunt.loadNpmTasks('grunt-contrib-cssmin');\n  grunt.loadNpmTasks('grunt-contrib-htmlmin');\n  grunt.loadNpmTasks('grunt-contrib-imagemin');\n  grunt.loadNpmTasks('grunt-contrib-jshint');\n  grunt.loadNpmTasks('grunt-contrib-jst');\n  grunt.loadNpmTasks('grunt-contrib-uglify');\n  grunt.loadNpmTasks('grunt-contrib-watch');\n\n```\n\n## 注册任务\n\n```\n  grunt.loadNpmTasks('grunt-contrib-watch');\n  ...\n  ...\n  ...\n  grunt.registerTask('default', ['clean', 'uglify']);//注册一个默认任务，后面的参数为该任务的前置任务\n\n```\n\n# 完整实例\n\n```\nmodule.exports = (grunt) => {\n  grunt.initConfig({\n    pkg: grunt.file.readJSON('package.json'),\n    uglify: {       // 任务名字，和插件对应\n      options: {\n        banner: '/*! <%= pkg.name %> <%= grunt.template.today(\"yyyy-mm-dd\") %> */\\n'  //打包后文件的版权声明\n      },\n      build: {\n        src: './src/**/*.js',       // 要打包文件的目录和文件\n        dest: './build/main.min.js'  //打包文件输出的位置与文件名\n      }\n    },\n    clean: ['./build'],\n    copy: {\n      // main:{            //将整个history目录copy到build目录下\n      //   expand: false,\n      //   src:'./history/**',\n      //   dest:'./build/',\n      // },\n      logo: {            //将整个history目录copy到build目录下\n        expand: false,\n        src: './src/logo.png',\n        dest: 'build/logo.png',\n      }\n\n    },\n    cssmin: {\n      options: {\n        mergeIntoShorthands: false,\n        roundingPrecision: -1\n      },\n      build: {      //压缩合并css\n        files: {\n          'build/main.css': ['src/*.css']\n        }\n      }\n    },\n    htmlmin: {\n      dist: {\n        options: {\n          removeComments: true,\n          collapseWhitespace: true\n        },\n        files: {\n          'build/index.html': 'src/index.html',\n        }\n      }\n    },\n    connect: {\n      server: {\n        options: {\n          open:true,    //自动打开浏览器\n          port: 8000,\n          base: './build',\n          hostname: '*',\n          // keepalive: true,     //在命令行运行 grunt connect 后不会立即退出\n          livereload: true  //和watch配合使用，需要设置 keepalive: false,\n        },\n      },\n    },\n    watch: {\n      scripts: {\n        files: ['src/*.js', 'src/*.css', 'src/*.html', 'Gruntfile.js'],\n        tasks: 'build',\n        options: {\n          spawn: false,  //增量更新\n          livereload: true\n        }\n      },\n\n    },\n  });\n\n\n  grunt.loadNpmTasks('grunt-contrib-clean');\n  grunt.loadNpmTasks('grunt-contrib-concat');\n  grunt.loadNpmTasks('grunt-contrib-connect');\n  grunt.loadNpmTasks('grunt-contrib-copy');\n  grunt.loadNpmTasks('grunt-contrib-cssmin');\n  grunt.loadNpmTasks('grunt-contrib-htmlmin');\n  grunt.loadNpmTasks('grunt-contrib-imagemin');\n  grunt.loadNpmTasks('grunt-contrib-uglify');\n  grunt.loadNpmTasks('grunt-contrib-watch');\n\n  // 默认被执行的任务列表。\n  grunt.registerTask('build', ['clean', 'cssmin', 'uglify', 'htmlmin', 'copy']);\n  grunt.registerTask('default', ['build', 'connect','watch']);\n\n}\n\n```\n","tags":["前端"]},{"title":"npm cnpm Yarn 关系与区别","url":"/202002/npmcnpmYarn关系与区别/","content":"\n> 都是用来管理各种依赖包的，npm 是 Node.js 自带的，镜像在国外;\n> cnpm 是解决国内网速问题，使用的淘宝镜像;\n> yarn 优化了可以离线安装本地缓存的依赖。\n> 现在的 npm 已经不是他日的 npm，可以修改源，可以设置缓存，离线安装。\n\n# npm\n\nNode 包管理器\n\n在 npm3.x 以前，npm 安装依赖时会将该包所需要的依赖安装到该包目录下，当多个包依赖同一个包时，就会出现重复安装，导致文件过大\n\nnpm3.x 开始，npm 会将依赖安装到同一目录，更加扁平化\n\n**npm 的镜像在国外，使得国内安装就会非常慢**\n\n#### 常用命令\n\n```\nnpm install [module-name]\nnpm i [module-name]\t//等同 npm install [module-name]\nnpm install -g module-name  //全局安装  等同--global\n\t    -D/--save-dev\t//安装为开发依赖，打包时不会打包，比如webpack css-loader ...\n\t    --save\t\t//安装为上结依赖，打包时会打包\t比如 vue layui...\nnpm remove [module-name] //移除卸载包\n\t    -g \t\t//移除全局包\n\nnpm config ls -l //查看当前所有配置\n\nnpm config get/set key val \t//设置配置\nnpm config set registry https://registry.npm.taobao.org  //使用淘宝镜像\n\n\n\n```\n\n# cnpm\n\n使用国内淘宝的镜像\n\n# Yarn\n\nFacebook, Google, Exponent 和 Tilde 开发的一款新的 JavaScript 包管理工具。\n\n可以离线安装本地缓存的依赖\n\n```\n\nyarn config set registry https://registry.npm.taobao.org\n```\n\n```\nyarn init        \t // 项目初始化,等同于npm的npm init\nyarn / $ yarn install      // 安装package.json中的依赖包,等同于npm install\nyarn add vue        \t// 添加并安装依赖包,等同于npm install vue(现在无需加--save,已经成为默认行为)\nyarn global add vue      // 全局安装包\nyarn remove vue        // 删除依赖包,等同于npm uninstall vue\nyarn upgrade       \t\t // 升级package.json指定的所有依赖包(在package.json指定的版本范围内)\nyarn upgrade --latest     //升级package.json指定的所有依赖包,但忽略package.json指定的版本范围,同时package.json中指定的版本将被重写\nyarn outdated        \t// 列出包的所有依赖项的版本信息。此信息包括当前安装的版本、基于语义版本所需的版本和最新的可用版本\nyarn run        \t\t// 列出包里所有可运行的脚本\nyarn run dev       \t // 运行package.json中scripts定义的脚本命令,等同于 npm runx\n\n```\n\n**为了便于管理使用全局安装里推荐使用 npm install -g , yarn 全局安装目录和 npm 目录不一致，即使改成同一目录后，yarn 安装里会对目录进行重置**\n","tags":["前端"]},{"title":"Docker","url":"/202002/Docker/","content":"\n# Docker\n\n- Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口\n\n相关文档\n\n[Docker 中文文档](http://www.dockerinfo.net/document)\n\n# 虚拟机 与 Docker\n\n![](https://img.hacpai.com/file/2020/02/虚拟机与docker比较-c0c08b14.png '虚拟机与docker比较.png')\n\n# Docker 优势\n\n- 小\n- 启动快\n- 资源占用少\n\n# Image/镜像\n\n- 应用程序和配置打包形成一个镜像\n- 一个镜像可以生成多个同时运行的容器实例\n\n# Container/容器\n\n- 用镜像创建的实例\n- mini 版的 Linux 环境\n\n# 仓库\n\n- 存放许多镜像文件的场所\n\n# Docker logo 含义\n\n`docker` 的 `logo` 是一只鲸鱼稳定的航行在大海中，鲸鱼背上面有很多集装箱。\n\n`dock` 本意码头\n\n`docker` 代表码头上的工人\n\n大海暗指宿主机\n\n`docker` 就是这条鲸鱼\n\n鲸鱼背上的集装箱就是一个一个的容器\n\n# 常用命令\n\n```\n #docker info\ndocker version\ndocker help\n\ndocker images //查看本地所有镜像\ndocker images -a //all 所以镜像，包括中间镜像\n//docker image ls -a\n\t      -q  // 只显示 id\ndocker search \t//查找镜像\ndocker pull     //下载镜像\ndocker image rm // docker rmi  -f 删除镜像\ndocker rmi -f ${docker images -qa}\t//删除全部镜像\n\ndocker run  [options ] image_name/iamge_id \t// --name='容器名字'\n\t\t\t\t\t// -i 以交互模式运行\n\t\t\t\t\t// -t 为容器分配一个伪输入终端\n\t\t\t\t\t// -p 端口映射\n\t\t\t\t\t//\thost_port:container_port\n\t\t\t\t\t//\tip:host_port:container_port //\n\t\t\t\t\t//\tip::container_port\n\t\t\t\t\t//\tcontainer_port\n\t\t\t\t\t// -d 后台运行\t但会立即退出 //Docker容器后台运行，就必须有一个前台进程\n//退出容器\nexit\t//停止容器退出\nctrl+P+Q\t//不停止容器退出\ndocker ps \t//docker container ps\t\t\t//查看正在运行 容器\n\t\t//-a 历史上运行过的\ndocker ps -l\t//上次运行过的\n\t\t// -n 3 上3次运行过的\ndocker start //docker container start/stop/restart\ndocker kill //强制关闭容器\ndocker rm //docker container rm\n\n//删除全部容器\ndocker rm -rf $(docker ps -aq)\t//docker ps -aq | xargs docker rm\n\n//日志\ndocker logs -ft --tial id\n\n//查看容器内运行的进行\ndocker top id\n\n//查看容器的信息//配置等\ndocker inspect id\n\n//进行正在运行的容器//在宿主机外面对容器执行命令\ndocker exec -it id command  //docker exec -it id /usr/bin/bash   此时exit不会停止容器\n\ndocker attach id  //进入容器\n\n//从容器copy文件到宿主机\ndocker cp id:/path/file /path/file\n\n//容器-->镜像\ndocker commit -m=\"msg\" -a=\"author\" id 镜像:[target]\n//docker commit -m=\"这是基于hello world 容器更改后的新镜像\" -a=\"daixiongsheng\"  fea2sdae54245 My_hello_world:latest\n\n```\n\n# 详解 Docker 镜像\n\ndocker 镜像是由一层一层文件系统组成 `UnionFS` ，包括 bootfs `boot file system` 和 rootfs `root file system`\n\nbootfs 主要包含系统的 bootloader 和内核 ，rootfs 主要包含 mini Linux 系统中的标准目录和文件\n\n- 不同的镜像文件大小不一样\n\npull 一个 Hello world 镜像可能只有几 M，一个 CentOS 也就 200+M,但一个 Tomcat 需要 4、500+M\n\n这是因为 hello world 只需要标准的输出控制，而 CentOS、Ubuntu 等都是基于 Linux 的，所以他们相应的镜像中某些功能就可以借助宿主机（比如内核等）,而 Tomcat 不仅需要 Linux 内核，还需要 Java 运行环境（jdk..）所以相对前两者比较大，我们在 pull 一个镜像的时候可以看到下载的不只一个镜像，但最后暴露给用户使用的只能我们需要的那一两个。这种分层镜像就可以**共享资源**\n\n# 容器数据卷\n\n- 将运行产生的数据持久化\n- 数据共享（宿主机到容器..）\n\n```\ndocker run -it -v /宿主机目录:/容器目录 镜像名\n\t\t\t\t\t# --privileged=true\n# 容器停止后，主机仍可修改，待容器重新启动，数据会自己同步\n# docker run -it -v /宿主机目录：/容器目录:ro 镜像名  #readonly\n```\n\n- 数据卷容器\n\n```\n//容器B继承容器A的卷\n\ndocker run --name=A centos\ndocker run --name=B --volumes-from A centos\n\n```\n\n## **Dockerfile**\n\n- 和 `Makefile` 类似\n- `Docker` 镜像的构建文件\n- 每条指令都会创建一个新的镜像层，并对镜像进行提交\n- 指令结构\n\n```\nFROM\t\t\t#基于哪个镜像   scratch是最基的镜像，类似js里面的Object类\nMAINTAINTER\t\t#镜像维护的作者的email\nRUN\t\t\t#构建时需要执行的命令\nEXPOSE\t\t\t#暴露端口\nWORKDIR\t\t\t#终端登陆进来的工作目录\nENV\t\t\t#设置环境变量\tENV MY_PATH /data\nADD\t\t\t#copy并解压缩到指定目录，也可处理url\nCOPY\t\t\t#复制\nVOLUME\t\t\t#容器卷  VALUME[\"/dir1\",\"/dir2\"] 容器内的卷，主机上docker 会产相应的默认目录\nCMD\t\t\t#容器启动运行的命令，有多个命令时，只有最后一个会生效，CMD会在docker run 之后的参数替换\n\t\t\t#  docker\nENTRYPOINT\t\t#容器启动运行的命令，和CMD一样，会追加，多个ENTRYPOINT都会执行,\n\t\t\t#如果Dockrfile 最后一行是 ENTRYPOINT docker run 的参数会叠加给最后的ENTRYPOINT进行组合\n\t\t\t#\nONBUILD\t\t\t#子镜像继承后运行时会触发\n\n```\n\n- [Tomcat Dockerfile](https://github.com/docker-library/tomcat/blob/master/8.5/jdk8/openjdk/Dockerfile)\n\n```\n\nFROM openjdk:8-jdk\n\nENV CATALINA_HOME /usr/local/tomcat\nENV PATH $CATALINA_HOME/bin:$PATH\nRUN mkdir -p \"$CATALINA_HOME\"\nWORKDIR $CATALINA_HOME\n\n...\n...\n...\n\nRUN set -e \\\n\t&& nativeLines=\"$(catalina.sh configtest 2>&1)\" \\\n\t&& nativeLines=\"$(echo \"$nativeLines\" | grep 'Apache Tomcat Native')\" \\\n\t&& nativeLines=\"$(echo \"$nativeLines\" | sort -u)\" \\\n\t&& if ! echo \"$nativeLines\" | grep 'INFO: Loaded APR based Apache Tomcat Native library' >&2; then \\\n\t\techo >&2 \"$nativeLines\"; \\\n\t\texit 1; \\\n\tfi\n\nEXPOSE 8080\nCMD [\"catalina.sh\", \"run\"]\n```\n\n- 构建成镜像\n\n```\ndocker build -f dockerfile -t author/app .\n```\n\n# 发布镜像\n\n1. 镜像来源\\* Dockerfile-->build\n   - container-->commit\n2. aliyun 创建仓库\n3.\n\n```\ndocker login --username=username [仓库地址]\ndocker tag [ImageId] [公网/专有地址]:[镜像版本号]\ndocker push [公网/专有地址]:[镜像版本号]\n```\n\n# Docker 关系\n\n![](https://img.hacpai.com/file/2020/02/Docker关系-69275257.png 'Docker关系.png')\n","tags":["后台"]},{"title":"Webpack4","url":"/202001/Webpack4/","content":"\n![](https://img.hacpai.com/file/2020/01/webpack4-31e1e8eb.png 'webpack4.png')\n\n> 代码转换、文件优化、代码分、模块合并、自动刷新、代码校验、自动发布\n\n1. 一个**模块化**打包工具\n\n相关文档\n\n> [wapack 中文文档](https://webpack.docschina.org/concepts/) > [`Webpack 中文开发手册 - 开发者手册 - 云+社区 - 腾讯云`](https://cloud.tencent.com/developer/chapter/17840)\n\n# 安装\n\n```\nyarn add webpack webpack-cli -D\n```\n\n# 运行\n\n```\nwebpack\n```\n\n# 配置文件\n\n运行时 webpack 会在当前目录下查找 `webpack.config.js` 文件，没有该文件会启动默认配置\n\n### 入口\n\n- 应用的入口，多个或者 1 个\n\n```JS\nmodule.exports = {\n  // entry: './src/index.js',//单入口简写\n  entry: {   //多入口\n    index: './src/index.js',\n    one: './src/one.js',\n    two: './src/two.js',\n  }\n}\n```\n\n### 输出 output\n\n- 打包后输出的文件\n\n```JS\nmodule.exports = {\n  output: {\n    path: path.resolve(__dirname, 'build'),\t// 打包后的目录\n    // filename: 'js/bundle[hash:8].js',\t// 打包后的目录+文件，这里是在build->js目录下\n\t\t\t\t\t\t// [hase:8]的意思是在文件名budle后面加一个hash串，取8位\n    filename: 'js/[name].js',\t\t\t// [name]表示使用entry配置里面的key值作为文件名\n\t\t\t\t\t\t// 通常在多入口情况下使用\n    // publicPath: 'http://localhost/'          // 打包时在html中使用链接时在前面面加的内容\n\t\t\t\t\t\t// 例html 中有一个   <img src=\"a.png\">\n\t\t\t\t\t\t// 打包后：\t    <img src=\"http://localhost/a.png\">\n  },\n}\n```\n\n### 模式 mode（开发/生产）\n\n```\nmodule.exports = {\n  // mode: 'production',\n  // mode: 'development'\n}\n```\n\n### 解析 resolve\n\n- 配置模块如何解析（在 import 时查找的方式）\n\n```JS\nmodule.exports = {\n\n  resolve: {\n    modules: [path.resolve('node_modules')],\t\t// 模块的存放目录\n    // extensions:['.js','.css','.json','.vue'],\t// 解析文件的扩展名  从左往右，找到为止\n    // mainFields:['style','main'],\t\t\t// 从左往右,找到为止\n    // mainFiles:[],//入口名字\t\t\t\t// 决定在 package.json 入使用哪个字段导入\n    alias: { \t\t\t\t\t\t// 导入时别名\n      bootstrap: 'bootstrap/dist/css/bootstrap.css'\n      // import 'bootstrap'  ==  import 'bootstrap/dist/css/bootstrap.css'\n    }\n  }\n};\n```\n\n### 优化 optimization\n\n```JS\nmodule.exports = {\n  optimization: {\t//优化项\n    splitChunks: {\t\t\t\t\t// 多入口打包时  分割代码块\n      cacheGroups: {\n        common: {    \t\t\t\t\t// 公共模块\n          chunks: 'initial',    \t\t\t\t// 开始的时候，大小超过0byte，有2次以上使用时独立出来\n          minSize: 0,\n          minChunks: 2\n        },\n        vendor: {      \t\t\t\t\t// 第三方模块\n          priority: 1,\t\t\t\t\t// 权重 ,\n          test: /node_modules/,\t\t\t// 目录\n          chunks: 'initial',    \t\t\t\t// 开始的时候，大小超过0byte，有2次以上使用\n          minSize: 0,\n          minChunks: 2\n        }\n      }\n    },\n    // namedModules:false,\t//更新的模块路径     配合webpack.HotModuleReplacementPlugin 插件\n    // namedChunks:false,  \t//打印更新的模块路径     配合webpack.HotModuleReplacementPlugin 插件\n    minimizer: [\t\t\t\t\t\t// 使用特定的优化器优化代码\n      new TerserJSPlugin({\t\t\t\t// 优化JS\n        cache: true,\n        parallel: true,\n        sourceMap: true,\n      }),\n      new OptimizeCSSAssetsPlugin()\t\t// 优化CSS\n    ],\n  },\n}\n```\n\n### 开发 devServer\n\n- 配合 webpack-dev-server 调试使用\n  ` yarn add webpack-dev-server -D`\n\n```JS\nmodule.expors = {\n  devServer: {\n     hot:true,\t\t\t\t\t\t// 热更新\n     port: 8000,\t\t\t\t\t// 端口\n     progress: true,\t\t\t\t\t//将运行进度输出到控制台\n     contentBase: path.resolve(__dirname, 'build'), // 目录\n     open: true,\t\t\t// 自动打开浏览器\n\n     //  如果遇到需要模拟数据时，可以使用下面两种方法\n     // 1)  代理请求到服务端\n     proxy: {\n         '/api': {  \t// url 路径\n            target: 'http://localhost:3000',\t\t\t// 代理的服务器路径\n\t    pathRewrite: {'/api': ''}  \t\t\t\t// 重写路径\n            // 这里当前端url 为http://localhost:8000/api/user 里后代理到 http://localhost:3000/user\n     \t}\n     },\n\n     // 2)    钩子\n     before(app) {  \t\t\t\t\t\t// 这里的app是一个Express对象实例\n\t app.get('/api', (req, res) => {\n\t   res.json({\n\t     name: 123\n\t   })\n\t })\n     }\n  }\n}\n```\n\n### 插件 plugins\n\n#### 常用插件\n\n- mini-css-extract-plugin 打包 CSS\n- optimize-css-assets-webpack-plugin 优化 CSS\n- terser-webpack-plugin 打包 JS\n- html-webpack-plugin 打包 HTML\n- clean-webpack-plugin 打包前删除已经打包文件\n- copy-webpack-plugin 复制插件\n- webpack.bannerPlugin 版权插件\n- webpack.IgnorePlugin 忽略模块插件\n- webpack.DllPlugin 打包成动态库\n- webpack.DefinePlugin 定义环境变量\n- webpack.HotModuleReplacementPlugin 热跟新插件\n- webpack.ProvidePlugin 版权标注\n\n```\nmodule.export = {\n  plugins: [\n    new webpack.DefinePlugin({    // 定义环境变量 插件\n      DEV: JSON.stringify('dev'),\n      // DEV:\"'production'\",\n      FLAG: true\n    }),\n    new webpack.HotModuleReplacementPlugin(),  //热跟新插件，不用每次更新时刷新整个网页\n    new webpack.IgnorePlugin(/\\.\\/locale/, /moment/),\n\t//忽略依赖插件，当import 一个包时，该包又导入了其他资源，比如moment的语言包，这个时候就可以选择手动导入，并忽略其他语言包\n\n    new HtmlWebpackPlugin({\t\t// 打包HTML插件\n      template: './src/index.html',\t\t// 打包前的模板文件\n      filename: 'index.html', \t\t\t// 打包后的HTML文件\n       minify: {   //压缩html\n         removeAttributeQuotes: true,\n         collapseWhitespace: true,\n         minifyCSS: true\n      },\n      hash: true   //会在链接后面加一个hash串，避免开发的时候浏览器缓存问题,打包上线时可以关闭\n    }),\n    // new HtmlWebpackPlugin({       //多个输出html\n    //   template: './src/index.html',\n    //   filename: 'home.html', //打包HTML\n    //   chunks:['home'],\n    //   minify: {   //压缩html\n    //     removeAttributeQuotes: true,\n    //     collapseWhitespace: true\n    //   },\n    //   hash: true\n    // }),\n    new MiniCssExtractPlugin({\n      filename: 'css/main.css',  \t\t // 打包CSS [hash:8]\n    }),\n    new webpack.ProvidePlugin({    \t // 在每个模块中都注入$\n      $: 'jquery'\n    }),\n    new CleanWebpackPlugin(),\n    // new CopyWebpackPlugin([\t\t // 打包时复制需要复制的文件插件\n    //   {from: './history', to: 'history'} \t // 在打包目录下新建一个history目录\n    // ]),\n    new webpack.BannerPlugin('make by dxs'),   // 版权相关  在文件第一行/或者新建同名的txt文件 加个声明\n    // new Happypack({             \t\t//多线程打包 配合module->rules规则\n    //   id:'js',\t\t\t\t\t // 多个id  new 多个实例\n    //   use:[\n    //     {\n    //       loader:'babel-loader',\t\t// loader\n    //       options:{\n    //         presets: [\n    //           '@babel/preset-env',\n    //         ]\n    //       }\n    //     }\n    //   ]\n    // })\n  ],\n\n}\n```\n\n### devtool\n\n- 增强调试\n\n```\nmodule.exports = {\n  devtool: 'source-map',            //增加映射文件  可以帮我们调试源代码,会生成单独map文件\n  //devtool: 'eval-source-map',     //增加映射文件  可以帮我们调试源代码,不会产生单独文件，但会显示行列\n  //devtool: 'cheap-source-map',    //增加映射文件  可以帮我们调试源代码,产生单独文件，但不会显示行列\n  //devtool: 'cheap-module-eval-source-map',     //增加映射文件  可以帮我们调试源代码,不产生单独文件，不显示行列，集成在文件中\n}\n```\n\n### watch & watchOptions\n\n```JS\nmodule.exports = {\n    watch: true,//监控，实时打包\n    watchOptions: {//参数\n    poll: 1000,    //每秒询问1000次\n    aggregateTimeout: 500,//防抖，  输入完成后500ms后打包\n    ignored: /node_modules/\n  },\n}\n```\n\n### 模块 module\n\n#### 常用 loader\n\n- autpprefixer 处理浏览器内核 CSS 前缀\n- css-loader 处理 CSS 中的@import\n- style-loader CSS 加入到 head 标签中\n- postcss-loader CSS loader\n- expose-loader 暴露全局 loader\n- eslint-loader JS 代码校验\n- babel-loader ES6 相关\n  - @babel/core 核心\n  - @babel/preset-env ES6-->ES5\n  - @babel/plugin-proposal-class-properties ES6 class 语法\n  - @babel/plugin-proposal-decorators ES6 decorators 语法\n  - @babel/plugin-transform-runtime 开发时需要\n  - @babel/runtime 上线时需要\n  - @babel/polyfill 解决 es6 'foobar'.includes('foo')\n\n```JS\nmodule.exports = {\n  module: {\n    noParse: /jquery/,\t\t//不解析jquery包的依赖\n    rules: [\n       {\n        test: /\\.css$/,\t\t// 一个正则表达式，匹配 .css 结尾的文件\n        use: [\t\t\t// 一个数组，使用的lodaer，每个loader可以是字符串，也可以是对象（options 可以传入参数，）\n          // {\n          //   loader: 'style-loader',\n          //   options: {}\t\t\t//参数写在options对象里面\n          // },\n          MiniCssExtractPlugin.loader,  //处理css合并并在html中引入\n          'css-loader', //处理@import\n          'postcss-loader'  //处理浏览器内核css\n        ]\n      },\n      // {\n      //   test: require.resolve('jquery'),\n      //   use: 'expose-loader?$'\t\t// 暴露$\n      //\n      // },\n      // {\n      //   test: /\\.(png|jpg|gif)$/,\n      //   use: [\n      //     {\n      //       loader: 'file-loader',\t\t// 图片文件打包，推荐使用url-loader,url-loader 对file-loader 进行了加强\n      //       options: {\n      //         esModule: false,\n      //       },\n      //     }\n      //\n      //   ]\n      // },\n\n      {\n        test: /\\.html$/,\n        use: 'html-withimg-loader'\n      },\n      {\n        test: /\\.css$/,\n        use: [\n          // {\n          //   loader: 'style-loader',\n          //   options: {}\n          // },\n          MiniCssExtractPlugin.loader,  //处理css合并并在html中引入\n          'css-loader', //处理@import\n          'postcss-loader'  //处理浏览器内核css\n        ]\n      },\n      {\n        // test: /\\.js$/,\n        // use: {\n        //   loader: 'eslint-loader',\n        //   options:{\n        //     enforce:'pre'//previous post 优先级  pre 前面执行的 normal正常。内联,后置post\n        //   }\n        // },\n\n      },\n      // {             //多线程打包\n      //   test: /\\.js$/,\n      //   use: {\n      //     loader: 'Happypack/loader?id=js',     //id 对应 plugins 里面的id\n      //     options:{\n      //       enforce:'pre'//previous post 优先级\n      //     }\n      //   },\n      //\n      // },\n      {\n        test: /\\.js$/,\n        include: path.resolve(__dirname, 'src'),\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: [\n              '@babel/preset-env'\n            ],\n            plugins: [\n              [\n                '@babel/plugin-proposal-decorators',\n                {\"loose\": true, \"decoratorsBeforeExport\": true}\n              ],\n              ['@babel/plugin-proposal-class-properties',\n                {legacy: true}\n              ],\n              '@babel/plugin-transform-runtime',\n              '@babel/plugin-syntax-dynamic-import',\n            ]\n          }\n        }\n\n      }\n    ]\n  }\n}\n\n```\n\n# 配置文件合并\n\n开发的时候可能需要看看发布后的效果，就需要使用发布的配置文件，开发 mode 的发布 mode 下很多配置是一样的，就可能使用一种类似继承的方式\n\n```\n//webpack.dev.js\n\nconst {smart} = require('webpack-merge')\nconst base = require('./webpack.base.js')\n\nmodule.exports = smart(base, {\n  mode: 'development',\n})\n\n\n\n//webpack.prod.js\n\nconst {smart} = require('webpack-merge')\nconst base = require('./webpack.base.js')\n\n\nmodule.exports = smart(base, {\n  mode: 'production',\n})\n\n```\n","tags":["前端"]},{"title":"mac 不能远程windows ","url":"/202001/mac不能远程windows/","content":"\n1、打开策略组：在开始菜单中打开运行，或者直接按 win+r 键盘组合键打开;在运行框中输入 gpedit.msc 之后，点击确定。\n2、随后：本地计算机策略--> 计算机配置--> 管理模板-->windows 组件--> 远程桌面服务--> 远程桌面会话主机--> 安全--> 远程（RDP）连接要求使用指定的安全层\n3、设置“启用”，另外把安全层调成“RDP”。\n","tags":["skill"]},{"title":"ubuntu 取消 sudo 密码","url":"/202001/ubuntu取消sudo密码/","content":"\n```bash\n/etc/sudoers\n\n%sudo\tALL=(ALL:ALL) ALL\n\n====>\n\n%sudo\tALL=(ALL:ALL) NOPASSWD: ALL\n\n```\n","tags":["skill"]},{"title":"我读过的书更新ing","url":"/201807/我读过的书更新ing/","content":"\n---\n\n# 2018\n\n---\n\n## 1. 人性的弱点 ---卡耐基\n\n对个人的剖析\n\n## 2. 你一年的 8760 小时 ---艾力\n\n一切都不晚\n\n## 3. 大数据时代：生活、工作与思维的大变革 ---维克托•迈尔•舍恩伯格\n\n大数据下的我们是透明的\n\n## 4. 编码：隐匿在计算机软硬件背后的语言 ---查尔斯•佩措尔德\n\n从简单电路到逻辑门，到锁存器寄存器，再到整个系统。\n从简单的 01 到复杂的图形图像等\n\n## 5. Head First Python ---Paul Barry\n\n适合新手学习 Python\n\n## 6.像计算机科学家一样思考 Python ---艾伦 B. 唐尼\n\nptyhon2 的语法 适合入门\n\n## 7. Python 编程：从入门到实践 ---埃里克·马瑟斯\n\n很好的一本 python 书\n语法为 Pytho3\n内容切合书名、\n前章讲 python 语法，还提到了测试驱动开发(TDD)\n后面接着讲了一些框架，pygame,matplotlib,django\n\n## 8. 重构-改善既有代码的设计 ---马丁•福勒\n\n一本程序员的武功秘籍，时不时走一回心法\n\n## 9. 你只是看起来很努力\n\n路走过就一定有他的意义\n感情最重要的是两个人拥有独立的心灵和共同进步，不是一个迁就另一个、一个牵制另一个\n当你决定旅行的时候，最难的一步已经迈出来了。可是，他还有后面一旬，如果你第一步不迈出，永远不知道你 的梦想是多么容易实现。\n\n## 10. 如何阅读一本书 ---轻阅读编写组\n\n读书 4 问\n转述，如果能将书的内容转述给其他尚未读过该书的人是一个很好的体现你对这本书的内容是否清楚明了。\n人与书的交流，人与人的交流\n\n## 11. 小王子 ---安托万•德•圣埃克苏佩里\n\n我也不知道那只羊有没有把那朵花吃了\n\n## 12. 一只特立独行的猪\n\n- 感觉我还不能读进去\n- 王小波的书可能目前我的心态，我的年龄暂时很难理解。\n\n## 13. 万万没想到：用理工科思维理解世界\n\n如题：理性\n\n## 14. 4 点起床：最养生和高效的时间管理\n\n3\\*8 = 24 小时\n\n## 15. 追风筝的人\n\n## 16. 活着\n\n## 17. 必然\n\n## 18. 未来简史\n\n---\n\n# 2019\n\n---\n\n## 1.一辈子很长，要和有趣的人在一起\n\n## 2.Android 编程权威指南(第二版)\n\n- 将 Android 开发架构、整体布局是如何的。\n\n## 3.《汇编语言(第 3 版) 》王爽著\n\n- 汇编可能离现在程序员很远，但还是有必要阅读的。了解计算机的底层是如何工作的。任何一门语言到最后都会变成汇编，这也是能和计算机真实交流的唯一途径。\n\n## 4.The Great Gatsby\n\n## 5.高性能 JavaScript\n\n- 将所有 `<script>` 标签放在尽可能接近 `<body>` 标签底部的位置，尽量减少对整个页面下载的影响\\* 浏览器遇到 script 会下载文件并执行，阻塞页面渲染。\n- 每个 HTTP 请求都会产生额外的性能负担，下载一个 100KB 的文件比下载四个 25KB 的文件要快。\n- defer 指明元素所含脚本不会修改 DOM，可以延迟执行。并行下载，onload 之前执行\n- 当需要多次访问 DOM 时使用局部变量存储 DOM 引用\n- 使用更快的 API `querySelectorAll` `firstElementChild`\n- 使用事件委托\n- 循环使用局部变量存储长度，每次循环 8 次操作\n- 递归改迭代\n- 使用数组的 join 代替字符串相加(书（2015 年 8 月）中给的是建议不要使用，目前测试（Firefox & Chrome ）结果是 join 更快，Edge 更慢)\n- 浏览器一次可以并行的发几个请求，所以不必要为了减少网络请求而网络请求\n\n## 6.爱你就像有生命\n\n## 7.倚天屠龙记\n\n- 因新版倚天屠龙记上映，说是尊重原著，就看了看原著。\n\n---\n\n# 2020\n\n---\n\n## 1.圣女的救济\n\n- 一次完美犯罪 1 年内凶手都在保护被害者，当需要杀害他的时候只需要什么都不做。\n\n## 2.JavaScript DOM 编程艺术\n\n- 古老的书了，现在手动操作 dom 编程已经很少了。\n\n## 3.ECMAScript 6 入门\n\n- ES6 入门的书，细节全面。\n\n## 4.CSS 世界\n\n- 优先级\n  min-height/width>>>max-height/width>>>width:!important>>> 内联 style\n  超越！ important 超越最大\n\n## 5.你不知道的 JavaScript 上卷\n\n### 1.2 理解作用域\n\n- 引擎会为变量 a 进行 LHS（左值）查询。另外一个查找的类型叫作 RHS（右值）\n- RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是试图找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS 并不是真正意义上的“赋值操作的右侧”，更准确地说是“非左侧”。\n\n### 2.1 词法阶段\n\n- 没有任何函数的气泡可以（部分地）同时出现在两个外部作用域的气泡中，就如同没有任何函数可以部分地同时出现在两个父级函数中一样。\n\n### 2.2 欺骗词法\n\n- 在执行`eval(..)`之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态形式插入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找\n- with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。\n\n### 3.2 隐藏内部实现\n\n- 从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际上就是把这些代码“隐藏”起来了。\n\n### 3.3 内容\n\n- 把 configurable 修改成 false 是单向操作，无法撤销！要注意有一个小小的例外：即便属性是`configurable:false`，我们还是可以把`writable`的状态由 true 改为 false，但是无法由 false 改为 true。除了无法修改，`configurable:false`还会禁止删除这个属性：\n- 是否会出现在对象的属性枚举中，比如说 for..in 循环。如果把 enumerable 设置成 false，这个属性就不会出现在枚举中，虽然仍然可以正常访问它。相对地，设置成 true 就会让它出现在枚举中。\n- 如果你想禁止一个对象添加新属性并且保留已有属性，可以使用`Object.prevent Extensions(..)`：\n- `Object.preventExtensions(myObject)`;\n- Object.seal(..)`会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用`Object.preventExtensions(..)`并把所有现有属性标记为`configurable:false`。`\n- `Object.freeze(..)`会创建一个冻结对象，这个方法实际上会在一个现有对象上调用`Object.seal(..)`并把所有“数据访问”属性标记为`writable:false`，这样就无法修改它们的值。\n- in`和`hasOwnProperty(..)`的区别在于是否查找`[[Prototype]]`链，然而，`Object.keys(..)`和`Object.getOwnPropertyNames(..)`都只会查找对象直接包含的属性。\n\n### 3.4 遍历\n\n- 遍历对象属性时的顺序是不确定的，在不同的 JavaScript 引擎中可能不一样。因此，在不同的环境中需要保证一致性时，一定不要相信任何观察到的顺序，它们是不可靠的\n- ES6 增加了一种用来遍历数组的 for..of 循环语法（如果对象本身定义了迭代器的话也可以遍历对象\n- 数组有内置的@@iterator，因此 for..of 可以直接应用在数组上。\n\n```JS\nvar myArray = [ 1, 2, 3 ];\nvar it = myArray[Symbol.iterator]();\nit.next(); // { value:1, done:false }\nit.next(); // { value:2, done:false }\nit.next(); // { value:3, done:false }\nit.next(); // { done:true }\n\n// 可以给任何想遍历的对象定义@@iterator\nconst myObject = { a: 1, b: 2 }\nObject.defineProperty(myObject, Symbol.iterator, {\n    enumerable: false,\n    writable: false,\n    configurable: true,\n    value: function () {\n        var o = this\n        var idx = 0\n        var ks = Object.keys(o)\n        return {\n            next: function () {\n                return { value: o[ks[idx++]], done: idx > ks.length }\n            },\n        }\n    },\n})\n// 手动遍历myObject\nvar it = myObject[Symbol.iterator]()\nit.next() //value:1, done:false\nit.next() //value:2, done:false\nit.next() //value:undefine, done:true\n\n\n```\n\n### 5.1 [[Prototype]]\n\n- 对于默认的`[[Get]]`操作来说，如果无法在对象本身找到需要的属性，就会继续访问对象的`[[Prototype]]`链：\n  1. 如果在`[[Prototype]]`链上层存在名为 foo 的普通数据访问属性并且没有被标记为只读（writable:false），那就会直接在 myObject 中添加一个名为 foo 的新属性，它是屏蔽属性。\n  2. 如果在`[[Prototype]]`链上层存在 foo，但是它被标记为只读（writable:false），那么无法修改已有属性或者在 myObject 上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。\n  3. 如果在`[[Prototype]]`链上层存在 foo 并且它是一个 setter，那就一定会调用这个 setter。foo 不会被添加到（或者说屏蔽于）myObject，也不会重新定义 foo 这个 setter。\n\n### 5.3 （原型）继承\n\n- Bar.prototype = Object.create(Foo.prototype)。调用 Object.create(..)会凭空创建一个“新”对象并把新对象内部的`[[Prototype]]`关联到你指定的对象（本例中是 Foo.prototype）。换句话说，这条语句的意思是：“创建一个新的 Bar.prototype 对象并把它关联到`Foo.prototype`”。\n- // ES6 之前需要抛弃默认的 Bar.prototype\n  Bar.ptototype = Object.create(Foo.prototype);\n  // ES6 开始可以直接修改现有的 Bar.prototype\n  Object.setPrototypeOf(Bar.prototype, Foo.prototype);\n- bind(..)函数来生成一个硬绑定函数，该函数是没有`.prototype`属性的\n- .**proto**`看起来很像一个属性，但是实际上它更像一个 getter/setter。\n\n### 6.1 面向委托的设计\n\n- Chrome 会动态跟踪并把实际执行构造过程的函数名当作一个内置属性，但是其他浏览器并不会跟踪这些额外的信息。\n- Chrome 内部跟踪（只用于调试输出）“构造函数名称”的方法是 Chrome 自身的一种扩展行为，并不包含在 JavaScript 的规范中。\n- JavaScript 中的函数之所以可以访问 call(..)、apply(..)和 bind(..)（，就是因为函数本身是对象。而函数对象同样有[[Prototype]]属性并且关联到 Function.prototype 对象，因此所有函数对象都可以通过委托调用这些默认方法。\n\n### 6.4 更好的语法\n\n- 匿名函数没有 name 标识符，这会导致：1．调试栈更难追踪；2．自我引用（递归、事件（解除）绑定，等等）更难；3．代码（稍微）更难理解。\n\n## 6.生命不息，折腾不止\n\n- 罗老师\n\n## 7.React 技术栈\n\n```JS\ncomponentWillUpdate\ncomponentDidUpdate\nrender\n中调用\nsetState会死循环\n```\n\n## 8.高效能人的七个习惯\n\n- 由内而外\n- 积极主动\n- 要事第一\n- 统合综效\n- 双赢\n\n## [9.JavaScript 教程](https://wangdoc.com/javascript/index.html)\n\n## 10.《你不知道的 JavaScript（中卷）》\n\n### 第 1 章 类型\n\n- ECMAScript 语言类型包括`Undefined、Null、Boolean、String、Number和Object`。\n- typeof null === \"object\"`; // true\n  正确的返回结果应该是\"null\"，但这个 bug 由来已久，在 JavaScript 中已经存在了将近二十年，也许永远也不会修复，因为这牵涉到太多的 Web 系统，“修复”它会产生更多的 bug，令许多系统无法正常工作。\n- vaScript 中的变量是没有类型的，只有值才有。\n- 大多数开发者倾向于将 undefined 等同于 undeclared（未声明），但在 JavaScript 中它们完全是两回事。\n\n```JS\nif (typeof DEBUG !== \"undefined\") {\n    console.log( \"Debugging is starting\" );\n}\n```\n\n### 第 2 章 值\n\nIEEE 754 标准来\n\nJavaScript 使用的是“双精度”格\n\n`a.toExponential(); // \"5e+10\"`\n\n因此数字值可以调用 Number.prototype 中的方法\n\n`tofixed(..)`方法可指定小数部分的显示位数：\n\n`toPrecision(..)`方法用来指定有效数位的显示位数：\n\nES6 开始，严格模式（strict mode）不再支持 0363 八进制格式\n\n```JS\nES6支持以下新格式：\n0o363;      // 243的八进制\n0O363;      // 同上\n0b11110011; // 243的二进制\n0B11110011; // 同上\n```\n\n二进制浮点数最大的问题（不仅 JavaScript，所有遵循 IEEE 754 规范的语言都是如此），是会出现如下情况：\n`0.1 + 0.2 === 0.3; // false`\n\n最常见的方法是设置一个误差范围值，通常称为“机器精度”（machine epsilon），对 JavaScript 的数字来说，这个值通常是 2^-52 (2.220446049250313e-16)。从 ES6 开始，该值定义在 Number.EPSILON 中，我们可以直接拿来用，也可以为 ES6 之前的版本写 polyfill：\n\n```JS\nif (! Number.EPSILON) {\n  Number.EPSILON = Math.pow(2, -52);\n}\n```\n\n能够被“安全”呈现的最大整数是`2^53-1`，即`9007199254740991`，在 ES6 中被定义为`Number.MAX_SAFE_INTEGER`。最小整数是`-9007199254740991`，在 ES6 中被定义为`Number.MIN_SAFE_INTEGER`。\n\nnull 指空值（empty value）\nundefined 指没有值（missing value）\n或者：\nundefined 指从未赋值• null 指曾赋过值，但是目前没有值 null 是一个特殊关键字，不是标识符，我们不能将其当作变量来使用和赋值。然而 undefined 却是一个标识符，可以被当作变量来使用和赋值。\n\n永远不要重新定义 undefined。\n\nvoid 并不改变表达式的结果，只是让表达式不返回值：\n\n简单值（即标量基本类型值，scalar primitive）总是通过值复制的方式来赋值/传递，包括 null、undefined、字符串、数字、布尔和 ES6 中的 symbol。\n\n复合值（compound value）——对象（包括数组和封装对象，参见第 3 章）和函数，则总是通过引用复制的方式来赋值/传递。\n\n### 第 3 章 原生函数\n\n`String.prototype.XYZ`简写为`String#XYZ`\n\n### 第 4 章 强制类型转换\n\n- 对普通对象来说，除非自行定义，否则 toString()（Object.prototype.toString()）返回内部属性`[[Class]]`的值，如`\"[object Object]\"`。\n- 如果对象中定义了`toJSON()`方法，JSON 字符串化时会首先调用该方法，然后用它的返回值来进行序列化。\n- toJSON()返回的应该是一个适当的值，可以是任何类型，然后再由`JSON.stringify(..)`对其进行字符串化。也就是说，`toJSON()`应该“返回一个能够被字符串化的安全的 JSON 值”，而不是“返回一个 JSON 字符串”。\n- 我们可以向 JSON.stringify(..)传递一个可选参数 replacer，它可以是数组或者函数，用来指定对象序列化过程中哪些属性应该被处理，哪些应该被排除，和 toJSON()很像。如果 replacer 是一个数组，那么它必须是一个字符串数组，其中包含序列化要处理的对象的属性名称，除此之外其他的属性则被忽略。如果 replacer 是一个函数，它会对对象本身调用一次，然后对对象中的每个属性各调用一次，每次传递两个参数，键和值。如果要忽略某个键就返回 undefined，否则返回指定的值。\n- JSON.stringify 还有一个可选参数 space，用来指定输出的缩进格式。space 为正整数时是指定每一级缩进的字符数，它还可以是字符串，此时最前面的十个字符被用于每一级的缩进：\n- ToNumber 对以 0 开头的十六进制数并不按十六进制处理，而是按十进制。\n- 一元运算+被普遍认为是显式强制类型转换。\n- 一元运算符+的另一个常见用途是将日期（Date）对象强制类型转换为数字，返回结果为 Unix 时间戳，以毫秒为单位（从 1970 年 1 月 1 日 00:00:00 UTC 到当前时间）：\n\n```JS\nvar d = new Date( \"Mon, 18 Aug 2014 08:53:06 CDT\" );\n+d; // 1408369986000\n```\n\n- JavaScript 有一处奇特的语法，即构造函数没有参数时可以不用带()\n- 字位运算符只适用于 32 位整数，运算符会强制操作数使用 32 位格式\n- ~`。它首先将值强制类型转换为 32 位数字，然后执行字位操作“非”（对每一个字位进行反转）。\n- x`大致等同于`-(x+1)`。很奇怪，但相对更容易说明问题： `~42; // -(42+1) ==> -43\n- `在`-(x+1)`中唯一能够得到`0（或者严格说是-0）`的x值是-1。也就是说如果x为-1时，`~`和一些数字值在一起会返回假值 0，其他情况则返回真值。~\n- `有什么用处了！~和 indexOf()一起可以将结果强制类型转换（实际上仅仅是转换）为真/假值：\n- `~~`中的第一个~执行 ToInt32 并反转字位，然后第二个`~`再进行一次字位反转，即将所有字位反转回原值，最后得到的仍然是 ToInt32 的结果。\n- ~~`我们要多加注意。首先它只适用于32位数字，更重要的是它对负数的处理与`Math.floor(..)`不同。\n- x`能将值截除为一个32位整数，`x | 0`也可以，而且看起来还更简洁。\n- Infinity（1/0 的结果）\n- `parseInt(\"Infinity\", 19)`。第一个字符是\"I\"，以 19 为基数时值为 18。第二个字符\"n\"不是一个有效的数字字符，解析到此为止，和\"42px\"中的\"p\"一样。\n- 如果两边的值中有 true 或者 false，千万不要使用`==`。如果两边的值中有[]、\"\"或者 0，尽量不要使用==。\n- 根据规范 a <= b 被处理为 b < a，然后将结果反转\n- JavaScript 中`<=`是“不大于”的意思（即！`(a > b)`，处理为`!(b < a)`）\n\n### 第 5 章 语法\n\n- 语句都有一个结果值\n- 获得结果值最直接的方法是在浏览器开发控制台中输入语句，默认情况下控制台会显示所执行的最后一条语句的结果值。\n- 规范定义 var 的结果值是 undefined\n- `++a++`为例，它首先执行`a++`（根据运算符优先级，如下），返回 42，然后执行++42，这时会产生 ReferenceError 错误，因为++无法直接在 42 这样的值上产生副作用。\n- 如果操作成功，delete 返回 true，否则返回 false。\n- foo: bar()`这样奇怪的语法为什么也合法呢？这里涉及 JavaScript 中一个不太为人知（也不建议使用）的特性，叫作“标签语句”（labeledstatement）。foo 是语句 bar()的标签（后面没有；，参见 5.3 节）。标签语句具体是做什么用的呢？如果 JavaScript 有 goto 语句，理论上我们可以使用 goto foo 跳转到 foo 处执行。goto 被公认为是一种极为糟糕的编码方式，它会让代码变得晦涩难懂（也叫作 spaghetti code），好在 JavaScript 不支持 goto。\n- JavaScript 通过标签跳转能够实现 goto 的部分功能。continue 和 break 语句都可以带一个标签，因此能够像 goto 那样进行跳转。例如：contine foo`并不是指“跳转到标签 foo 所在位置继续执行”，而是“执行 foo 循环的下一轮循环”。所以这里的 foo 并非 goto。标签的循环跳转一个更大的用处在于，和**break 一起使用可以实现从内层循环跳转到外层循环**。没有它们的话实现起来有时会非常麻烦：break foo 不是指“跳转到标签 foo 所在位置继续执行”，而是“**跳出标签 foo 所在的循环/代码块，继续执行后面的代码**”。因此它并非传统意义上的 goto。\n- SON 属性名必须使用双引号\n- 通过`<script src=..>`标签加载 JavaScript 文件，其中只包含 JSON 数据（比如某个 API 返回的结果），那它就会被当作合法的事实上 JavaScript 没有`else if`，但 if 和 else 只包含单条语句的时候可以省略代码块的{ }else if`极为常见，能省掉一层代码缩进，所以很受青睐。但这只是我们自己发明的用法，切勿想当然地认为这些都属于JavaScript语法的范畴。`\n- 运算符的优先级比=低`。所以`b = a++`, a其实可以理解为`(b = a++), a\n- &&运算符的优先级高于||，而||的优先级又高于？:\n\n## 10.《你不知道的 JavaScript（下卷）》\n\n### 第 1 章 异步：现在与将来\n\n- setTimeout(..)并没有把你的回调函数挂在事件循环队列中。它所做的是设定一个定时器。当定时器到时后，环境会把你的回调函数放在事件循环中，这样，在未来某个时刻的 tick 会摘下并执行这个回调。\n- 并发是指两个或多个事件链随时间发展交替执行，以至于从更高的层次来看，就像是同时在运行（尽管在任意时刻只处理一个事件）。\n\n### 第 5 章 程序性能\n\n- Web Worker 的新增特性的探索过程中，这些都是很好的问题。这是浏览器（即宿主环境）的功能，实际上和 JavaScript 语言本身几乎没什么关系。也就是说，JavaScript 当前并没有任何支持多线程执行的功能。\n- Worker 可以访问几个重要的全局变量和功能的本地复本，包括 navigator、location、JSON 和 applicationCache。\n- 你还可以通过 importScripts(..)向 Worker 加载额外的 JavaScript 脚本： // 在 Worker 内部 importScripts( \"foo.js\", \"bar.js\" );这些脚本加载是同步的。也就是说，importScripts(..)调用会阻塞余下 Worker 的执行，直到文件加载和执行完成。\n- Web Worker 通常应用于哪些方面呢？• 处理密集型数学计算• 大数据集排序• 数据处理（压缩、音频分析、图像处理等）• 高流量网络通信\n- 当然，所有权传递是可以双向进行的。如果选择 Transferable 对象的话，其实不需要做什么。任何实现了 Transferable 接口（http://developer.mozilla.org/en-US/docs/Web/API/Transferable）的数据结构就自动按照这种方式传输（Firefox和Chrome都支持）。\n\n## 11.《九型人格》\n\n- 人类的三种体验世界的方式\n  - 思考\n  - 感觉\n  - 感官\n- 九型人格\n  1. 完美主义者\n     - 希望绝对\n     - 喜欢批判自己与他人\n     - 高标准\n  2. 给予者\n     - 主动\n     - 乐于助人\n     - 乐观\n     - 慷慨大方\n  3. 实践者\n     - 工作狂\n  4. 浪漫主义者\n     - 艺术气质\n     - 多情\n  5. 观察者\n     - 审慎\n     - 高度隐私\n     - 杰出的决策者和有创意的知识分子\n  6. 质问者\n     - 把世界看作威胁\n     - 不喜欢权威\n  7. 享乐主义者\n     - 乐观\n     - 精力充沛\n     - 迷人\n     - 难以捉摸\n     - 未来向导者\n  8. 支配者\n     - 独断\n     - 有时具有攻击性\n     - 一不做二不休\n     - 领导或者极端孤立者\n  9. 媒介者\n     - 和平使者\n     - 不知道自己想要什么\n     - 喜欢和谐而舒适的生活\n\n```mermaid\ngraph RL;\n    完美主义者-->浪漫主义者;\n    给予者-->支配者;\n    实践者-->媒介者;\n    浪漫主义者-->给予者;\n    观察者-->享乐主义者;\n    质问者-->实践者;\n    享乐主义者-->完美主义者;\n    支配者-->观察者;\n    媒介者-->质问者;\n```\n\n## 12. 《编程珠玑》\n\n### 给程序员的 10 条建议\n\n1. 解决正确的问题\n2. 探索所有可能的方案\n3. 观察数据\n4. 使用粗略计算\n5. 利用对称性\n6. 利用组件做设计\n7. 建立原型\n8. 必要时进行权衡\n9. 保持简单\n10. 追求完美\n\n### 代码调优法则\n\n- 时间换空间\n- 空间换时间\n- 循环法则\n- 逻辑法则\n  - 等价的代数表达式换逻辑表达式\n- 过程法则\n  - 内联\n- 表达式法则\n  - if 替换取模% 运算\n\n## 13. 《有些路，只能一个人走》\n\n- 态度不可以改变世界，但可以改变自己\n- 距离高考已经过去 4 年了，4 年里自己改变了什么，自己是否还记得高中时自己想要成为的那个自己。 **生哥**，“我不喜欢别人叫我生哥”。我似乎也忘了我曾经为什么要这么说，不过还有一个人记得。我得想想我当时这么说的原因。\n- 别讲着别人的故事，忘了自己的。\n- 时间是最伟大的治疗师。是这么个道理，4 年了，当初高中毕业时那种喜欢一个的人劲现在好像也不知还在不在，不知道如果现在我们又变成同桌我还会不会有从前的感觉了。可能留下的只是美好的祝愿。我现在还记得，我当初给自己的保证，保证自己一定能够回到从前。回到从前的那个灿烂。保证在现在依旧在内心有效，不过也不可能真实的去实现这个过程了。\n- 你认为的不一定是你想的，你想的不一定是你看到的，你看到的不一定是真实的。同上，我认为我能保证，但是不是，也无从验证。\n- 自我忍耐与调节：遇到成绩看窗外,遇到问题看镜子。\n- 真正的爱情：未来\n- 规划，倒推 OKR\n- 是谁陪我们到最后的\n\n## 14. 《代码整洁之道》\n\n### 整洁的代码\n\n- 优雅，高效，减少依赖，优美的散文，让你的营地比来时更干净\n\n---\n\n### 有意义的命名\n\n- 下标的意义 说清楚 == -1\n\n- 值的意义\n\n- 要能读得出来\n\n- ```typescript\n  getActiveAccount()\n  getActiveAccounts()\n  getActiveAccountInfo()\n  ```\n\n- 不必使用成员变量前缘，调用者很快会无视这个前缀\n\n- 类名和对象名应当是名词或者名词短语\n\n- 方法名应该是动词或者动词短语\n\n- 避免同一单词不同意义，双关语\n\n- 添加**有意义**语境\n\n  - firstName,lastName,street,city,state,zipcode 放在一起时很明确是一个地址信息\n  - 当单独拆开时不明其意，可以添加适当的语境。addrFirstName, addrLastName,addrCity,addrZipcode\n\n---\n\n### 函数\n\n- 第一规则：短小，第二规则：还要更短小。\n- 只做一件事，做好这一件事。\n- 自顶向下，每一个函数为一个抽象层级。看看源码\n- 使用描述性名称，描述函数做的事\n- 别害怕长名称，长而具有描述性的名称比短页而令人费解的名称好。\n  - getHomeOpenStatusByActivityId\n  - getHomeOpenStatusByDepId\n  - 前端在 webpack 打包时也会压缩\n- 参数\n  - 无参数**最理想**\n  - 其次一个参数，两个参数\n  - 避免出现三个级以上参数\n    - 多个参数在写 test 的时候要能写出确保各种组合运行正常的测试用例\n    - 如果需要多个参数，那说明其中一些可以封装成类了\n- 函数要么做什么事，要么回答什么事。\n- 使用异常代替错误返回码\n- 结构化编程\n  - 每个函数只有一个入口，一个出口（ 一个 return）\n  - 循环中不能有 break 和 continue\n\n### 注释\n\n- 注释的恰当用法是**弥补**我们在用代码表达意图遭遇的失败\n- 注释是一种失败\n- 注释应当少\n- **注释是对意图的解释**\n- 注释要能提供信息\n- TODO 应当是程序员认为应该做的，但现在还没有做的工作\n- 不要写无用的注释和废话注释\n- 删掉注释的代码\n\n### 类\n\n- 一个类应该短小\n- 单一权责原则\n- 类中每个方法应当操作一个或者一种变量\n- 开闭原则。对拓展开发，对修改封闭。jQuery.extend\n\n## 15.张爱玲传\n\n- 记得别人的小恩惠\n- 你若了解的我过去，你便会原谅现在的我。\n- 人总是容易崇拜一个在你弱势的方面显得强势的人。\n- 生命中总有这样的时候，对我们重要的一些人有可能就在身边我们却不知，不到那一刻完全没明白宿命的安排，像面纱一样罩着。\n- 一个天才的女人忽然结了婚。\n- 中国人向来不喜欢异类。\n- 爱情中的女人，一如既往的付出，为了对得起自己的青春。\n- 性格相似的同类适合做朋友，但不适合生活在一起，性格互补的异性更适合在一起，因为很少有冲突，---只要互补的是个性，相似的是兴趣爱好，便是绝佳的组合。\n- 精神是想通。\n- 最擅长写爱情，却恋爱都没谈过。\n- 噢，你也在这里吗？\n- 定情信物。\n- 溃烂早已愈合，那酱紫色的难堪却还在。\n- 见了他，她变得很低很低，低到尘埃里，但她心里是欢喜的，从尘埃里开出花来。\n- 最幸福的事莫过于你喜欢的人，他刚好也喜欢你。\n- 生活是一袭华美的袍， 上面爬满了虱子。\n- 年经的女孩子不需要美貌，只青春就够了。\n- 五六十岁的外国背包客。\n\n# 2021\n\n---\n\n## 1. 重构\n\n- 重构本来就不是一件应该特别拨出时间做的事情，重构应该随时随地进行。你不应该为重构而重构，你之所以重构，是因为你想做别的什么事，而重构可以帮助你把那些事做好。\n- 看见不规范的、可以优化的不敢改。\n  - 不敢改，你写什么代码嘛。\n- 需要重构的是你不知这段代码在干什么，不了解它的行为。对于了解其行为的说明还不是那么迫切需要重构。\n\n### 法则\n\n- 事不过三，三则重构。\n  - 第一次做某件事时只管去做;第二次做类似的事会产生反感，但无论如何还是可以去做;第三次再做类似的事，就应该重构。\n- 添加功能时重构\n- 修补错误时重构 代码还不够清晰----没有清晰到让你能一眼看出 bug。\n- 复审代码时重构 code review\n\n### 坏代码\n\n- 重复的代码\n- 过长的函数\n- 过大的类\n- 过长的参数列表\n- 发散式变化\n  - 由最初的功能单一在进行后期的迭代扩展后，功能不再单一，功能形成发散式的变化\n- 霰弹式修改\n  - 遇到功能变化时需要在多个类中进行许多小修改\n- 依恋情节\n  - 一个函数为计算某个值从某个类取了许多值，过渡依恋这个类，就可以把这个方法写入到这个类中\n  - 保证数据和操作数据的行为在一个地方\n- 数据泥团\n  - 相同的几项数据，几个类拥有几个差不多的属性，几个方法的参数差不多\n- switch\n  - 使用多态替换\n- 过渡的消息链\n  - 用户向一个对象请求另一个对象，再通过这个获取的对象去获取另一个对象\n  - 但不是任何函数链都是坏代码\n- 过多的注释\n  - 如果需要注释来解释一块代码做了什么，试着提炼出方式\n  - 如果还需要注释来解释其行为，试试修改函数名\n  - 如果还需要注释来说明某些系统的需求规格，试试引入断言\n  - 如果不知道要做什么，这个时候才该说注释\n\n重构的前提需要一个可靠的测试环境，但对于前端来说，单测较少，更多的是需要 QA 的 RD 的自测，这可能也是在前端不愿意修改旧代码的原因。\n\n### 重构列表（方法）\n\n#### 1.提炼函数\n\n这也是我们在重构/编码过程中使用到最多的方式\n\n让函数名表明它的意图，尽量让一个函数没有过多的注释来表明它的意图。\n\n#### 2.内联函数\n\n当函数内部的代码足够简短到表达这个函数的意图时，可以将这个函数去掉。\n\n或者在重构一个大的函数时，将内部的小函数进行重新拆解并重新组合。\n\n#### 3.内联临时变量\n\n一个临时变量只被赋值过一次，且只被使用过一次时，就可以消除这个临时变量\n\n#### 4.以查询代替临时变量\n\n临时变量是临时（计算出来）的，只有在函数内部使用，就可以通过将这变量包装成一个函数。\n\n类似 vue 的计算属性\n\n#### 5.引入注释性变量\n\n将一个复杂的表达式的结果放进一个临时变量，用变量名来解释对应的用途。\n\n也类似 vue 的计算属性\n\n#### 6.分解临时变量\n\n一个临时变量被多次赋值，但不同阶段表达的意思不同时，就可以使用多个临时变量代替\n\n#### 7.移出对参数的赋值\n\n参数的值尽量只在函数被调用时赋值，函数体内不必再对这个参数进行重新赋值，提高代码的清晰度，在函数内部任何地方使用是，参数的指向都是唯一确定的\n\n#### 8.以函数对象取代函数\n\n当存在一个大型的函数，内部局部变量使用的情况导致不能再提炼更小的函数时，将这个函数放入一个对象中，函数的局部变量就变成为个对象的字段，这个时候再把这个大型函数提炼成多个小的函数。\n\n#### 9.替换算法\n\n换一种更清晰的算法\n\n### 重构列表（在对象之间）\n\n#### 1.搬移函数\n\n类 A 中的一个函数 F 与另一个类 B 进行的交流更多，F 调用类 B，B 调用 F。可以将这个 F 搬移到 B 中。\n\n#### 2.搬移字段\n\n类 A 中的一个字段 P 与另一个类 B 进行的交流更多，P 调用类 B，B 调用 P。可以将这个 P 搬移到 B 中。\n\n#### 4.提炼类\n\n一个类做了由两个类做的事，可以新建一个类，将相应的功能拆分。\n\n#### 5.内联类\n\n一个类没有做太多的事，可以将其萎缩塞进另一个类中。\n\n### 简化表达式\n\n#### 1.分解表达式\n\n把多个 if-else 拆分成独立的函数，让函数表达该表达式的含义\n\n#### 2.合并表达式\n\n判断条件不同，但行为是一致的（比如:return） 奖这个抽取成一个单独函数\n\n#### 3.合并重复的条件判断\n\n一组表达式的所有分支都执行相应的代码，就可以抽取到外部\n\n#### 4.以卫语句取代嵌套条件表达式\n\n卫语句： 单独检查的语句。代表它比较特殊，全部 if-else 会让每个条件都显得重要性一致，使用单独的判断表示这个条件的特殊性.\n\n### 简化函数调用\n\n#### 1.给函数取个名字\n\n函数的名称应该准确表达它的用途。给函数命名有一个好办法：首先考虑应该给这个函数写上一句怎样的注释，然后想办法将注释变成函数名称。\n\n#### 2.以明确函数取代参数\n\n有一个函数，其中完全取决于参数值而采取不同行为。针对该参数的每一个可能值，建立一个独立函数。\n\n#### 3.以函数取代参数\n\n当一个函数的参数为另一个函数的返回值时，让参数接受者内部去调用这个函数\n\n#### 3.隐藏函数\n\n一个类的某些函数没有在其他地方使用时，将其设为 private\n\n## 2.人月神话\n\n### 杂\n\n- 编程乐趣\n  - 一种创建事件的纯粹快乐\n  - 开发出对他人有用，自己的劳动成果能够被他人使用\n  - 系统开发过程的魅力，将各个零部件组装在一起，以精妙的方式运行着，并收到预期的效果。\n  - 凭自己的想象建造自己的城堡。\n- 编程的苦恼\n  - 来自追求完美\n  - 对其他人的依赖是一件痛苦的事（在别人的项目上进行二次开发）\n  - 寻找 bug 是一个重复性的活动，枯燥。\n  - 投入大量时间当完成时，去显得陈旧过时。\n  - 这次肯定会运行，，我刚刚找出最后一个 bug\n- 软件任务进度安排\n  - 1/3 计划\n  - 1/6 编码\n  - 1/4 软件测试和早期系统测试\n  - 1/4 系统测试，所有的构件已完成\n- Brooks 法则\n  - 向进度落后的项目上增加人手，只会使项目更加落后。\n\n### 外科手术队伍\n\n```mermaid\ngraph TB;\n外科医生 --> 管理员\n管理员 --> 文秘1\n外科医生 --> 编辑\n编辑 --> 文秘2\n外科医生 --> 副手\n外科医生 --> 程序职员\n外科医生 --> 工具维护人员\n外科医生 --> 测试人员\n外科医生 --> 语言专家\n```\n\n- 外科医生\n  - 首席程序员，定义功能和性能技术，设计程序，编制源代码、测试，技术文档\n- 副手\n  - 设计的思考者、讨论者和评估人员。主要是讨论\n- 管理员\n  - 外科医生的老板\n  - 在管理人员、薪酬、办公空间有决定权，但不能花太多时候\n  - 一个文秘\n    - 专业管理人员。\n- 编辑\n  - 外科医生负责文档的生成。编辑根据外科医生的草稿，口述，进行分析和重组，提供各种文档\n  - 一个文秘\n- 两个文秘\n  - 属于管理员和编辑\n- 程序职员\n  - 所有的团队技术记录，接收文秘性质的培训，所有计算机输入的汇总点。\n- 工具维护人员\n  - 检查外科医生需要的工具，需要开发一些实用程序。\n- 测试人员\n  - 测试\n- 语言专家\n  - 掌握复杂编程语言专家。\n\n## 2.云边有个小卖部\n\n我这一生只向世界问候过 3 次，刚好每次都遇到了你。\n\n## 3. 时间的朋友（2015-2017）\n\n## 4. 了不起的 Node.js\n\n## 4. 更了不起的 Node.js 卷一\n\n- 深入到源码，从源码理解 Node.js\n","tags":["书"]}]